
# مقدمه

طراحی سیستم فرآیند تعریف عناصر یک سیستم و همچنین تعاملات و روابط آنها برای برآورده کردن مجموعه ای از الزامات خاص است.

این شامل گرفتن یک صورت مسئله، شکستن آن به اجزای کوچکتر و طراحی هر جزء برای کارکرد موثر با هم برای دستیابی به هدف کلی سیستم است. این فرآیند به طور معمول شامل تجزیه و تحلیل سیستم فعلی (در صورت وجود) و تعیین هر گونه نیازمندی و ایجاد یک برنامه دقیق برای سیستم جدید و آزمایش طراحی برای اطمینان از مطابقت آن با الزامات است. این یک فرآیند تکرارشونده است که ممکن است شامل چندین دور طراحی، آزمایش و اصلاح باشد.

در مهندسی نرم افزار، طراحی سیستم مرحله ای در فرآیند توسعه نرم افزار است که بر روی طراحی سطح بالای یک سیستم نرم افزاری از جمله معماری و اجزا، تمرکز می‌کند.

این همچنین یکی از جنبه‌های مهم فرآیند مصاحبه برای مهندسان نرم افزار است. اکثر شرکت‌ها یک دور مصاحبه اختصاصی برای طراحی سیستم دارند، جایی که از نامزدها می‌خواهند سیستمی را برای یک صورت مسئله خاص طراحی کنند. از انتظار می‌رود که نامزدها با یک طراحی دقیق از سیستم، از جمله معماری، اجزا و تعاملات آنها ارائه شوند. همچنین انتظار می‌رود که آنها در مورد معاوضه‌های موجود در طراحی خود و گزینه‌های جایگزینی که در نظر گرفته‌اند بحث کنند.

## کارایی در برابر مقیاس‌پذیری

یک سرویس مقیاس‌پذیر (scalable) است که  افزایش منابع اضافه شده منجر به افزایش **کارایی برنامه** شده باشد. به طور کلی، افزایش کارایی به معنای ارائه واحدهای کاری و عملیاتی بیشتر است، اما همچنین می‌تواند به معنای مدیریت واحدهای کاری و عملیاتی بزرگتر، مانند زمانی که مجموعه داده‌ها افزایش می‌یابد، باشد.

یک راه دیگر برای نگاه کردن به عملکرد در برابر مقیاس پذیری:

- اگر مشکل **عملکرد** دارید، سیستم شما برای یک کاربر کند است.
- اگر مشکل **مقیاس پذیری** دارید، سیستم شما برای یک کاربر سریع است اما تحت بار سنگین کند است.


# پایگاه‌داده‌ها


انتخاب پایگاه‌داده مناسب برای یک سیستم، یک تصمیم حیاتی است، زیرا می‌تواند تأثیر قابل توجهی بر عملکرد، مقیاس‌پذیری و موفقیت کلی سیستم داشته باشد. برخی از دلایل کلیدی که چرا انتخاب پایگاه‌داده مناسب مهم است عبارتند از:

* **کارایی (Performance):** پایگاه‌داده‌های مختلف، ویژگی‌های عملکردی متفاوتی دارند و انتخاب اشتباه می‌تواند منجر به عملکرد ضعیف و زمان پاسخگویی کند شود.
* **مقیاس‌پذیری (Scalability):** با رشد سیستم و افزایش حجم داده‌ها، پایگاه‌داده باید بتواند به طور مناسب مقیاس‌بندی شود. برخی از پایگاه‌داده‌ها برای مدیریت حجم زیادی از داده‌ها نسبت به سایرین مناسب‌تر هستند.
* **مدل‌سازی داده (Data Modeling):** پایگاه‌داده‌های مختلف قابلیت‌های مدل‌سازی داده متفاوتی دارند و انتخاب گزینه مناسب می‌تواند به حفظ انسجام و سازماندهی داده‌ها کمک کند.
* **یکپارچگی داده (Data Integrity):** پایگاه‌داده‌های مختلف قابلیت‌های متفاوتی برای حفظ یکپارچگی داده، مانند اعمال محدودیت‌ها دارند و می‌توانند سطوح مختلفی از امنیت داده را ارائه دهند.
* **پشتیبانی و نگهداری (Support and maintenance):** برخی از پایگاه‌داده‌ها جوامع فعال‌تر و مستندات بهتری دارند و یافتن کمک و منابع را آسان‌تر می‌کنند.

به طور کلی، با انتخاب پایگاه‌داده مناسب، می‌توانید اطمینان حاصل کنید که سیستم شما عملکرد خوبی خواهد داشت، در صورت نیاز مقیاس‌بندی می‌شود و در بلندمدت قابل نگهداری است.

## SQL  در مقایسه با noSQL

پایگاه‌داده‌های SQL مثل MySQL و PostgreSQL برای داده‌های ساختاریافته و رابطه‌ای با اسکیمای ثابت مناسب‌تر هستند. این پایگاه‌داده‌ها تراکنش‌های ACID (اتمسیت، سازگاری، جداسازی، دوام) قوی و پشتیبانی از پرس‌وجوهای پیچیده و JOIN را ارائه می‌دهند.

پایگاه‌داده‌های NoSQL مثل MongoDB و Cassandra برای داده‌های غیرساختاریافته و غیررابطه‌ای با اسکیمای انعطاف‌پذیر مناسب‌تر هستند. آن‌ها مقیاس‌پذیری و عملکرد بالایی را برای حجم زیادی از داده ارائه می‌دهند و اغلب در وب‌سایت‌های بلادرنگ و داده‌های حجیم به کار می‌روند.

بهترین انتخاب بین SQL و NoSQL به نیازمندی‌ها و سناریوی خاص پروژه بستگی دارد. اگر نیاز به ذخیره و پرس‌وجوی داده‌های ساختاریافته با روابط پیچیده دارید، پایگاه‌داده SQL گزینه بهتری است. در صورتی که نیاز به ذخیره و پرس‌وجوی حجم زیادی از داده‌های غیرساختاریافته با مقیاس‌پذیری و عملکرد بالا دارید، پایگاه‌داده NoSQL می‌تواند انتخاب مناسب‌تری باشد.

## NoSQL


NoSQL مجموعه‌ای از داده‌ها است که به صورت key-value store، document store، wide column store یا graph database نمایش داده می‌شود. داده‌ها در این نوع پایگاه‌داده غیرعادی‌سازی شده‌اند (denormalized) و اتصالات (join) معمولا در کد برنامه انجام می‌شوند. 

اکثر پایگاه‌داده‌های NoSQL از تراکنش‌های ACID واقعی پشتیبانی نمی‌کنند و قوام نهایی (eventual consistency) را ترجیح می‌دهند.

از واژه BASE (Basically Available, Soft state, Eventual consistency) برای توصیف ویژگی‌های پایگاه‌داده‌های NoSQL استفاده می‌شود. BASE در مقایسه با قضیه CAP، در دسترس‌بودن را بر قوام ترجیح می‌دهد.

* **Basically Available (در دسترس بودن اساسی):** سیستم در دسترس بودن را تضمین می‌کند.
* **Soft state (حالت نرم):** وضعیت سیستم ممکن است حتی بدون ورودی در طول زمان تغییر کند.
* **Eventual consistency (سازگاری احتمالی):** سیستم در نهایت و با گذشت زمان سازگاری و یکپارچگی پیدا می‌کند، به شرطی که در آن مدت ورودی جدیدی به سیستم وارد نشود.

## پایگاه داده سندگرا (Document Store)

واحد اساسی داده در یک ستون‌ گسترده، یک ستون (جفت نام/مقدار) است. ستون‌ها را می‌توان در خانواده‌های ستونی (مشابه یک جدول SQL) گروه بندی کرد. اَبَر خانواده‌های ستونی، گروهی از خانواده‌های ستونی را سازماندهی می‌کنند. شما می‌توانید به هر ستون به طور مستقل با یک کلید ردیف (row key) دسترسی داشته باشید و ستون‌هایی با کلید ردیف یکسان، یک ردیف را تشکیل می‌دهند. هر مقدار برای کنترل نسخه و حل تضاد، شامل یک برچسب زمانی (timestamp) است.

گوگل با معرفی Bigtable، اولین ستون‌گستر پهن را ارائه کرد که بر HBase متن‌باز، اغلب استفاده‌شده در اکوسیستم Hadoop، و Cassandra از فیس‌بوک تأثیرگذار بود. ذخیره‌سازهایی مانند Bigtable، HBase و Cassandra کلیدها را به ترتیب واژه‌نامه‌ای (lexicographic order) نگهداری می‌کنند که امکان بازیابی کارآمد محدوده‌های کلید انتخابی را فراهم می‌کند.

## پایگاه داده رابطه‌ای (RDBMS)

پایگاه داده رابطه‌ای، مانند پایگاه‌داده‌های SQL، مجموعه‌ای از داده‌ها است که در جداول سازماندهی شده‌اند. ACID مجموعه‌ای از ویژگی‌های تراکنش‌های پایگاه‌داده رابطه‌ای است.

* **اتمسیت (Atomicity):‏** هر تراکنش به صورت کامل انجام می‌شود یا اصلاً انجام نمی‌شود.
* **سازگاری (Consistency):‏** هر تراکنش پایگاه داده را از یک وضعیت معتبر به وضعیت معتبر دیگری منتقل می‌کند.
* **جداسازی (Isolation):‏** اجرای همزمان تراکنش‌ها نتایجی مشابه با اجرای سریال تراکنش‌ها به دست می‌دهد.
* **دوام (Durability):‏** پس از اینکه یک تراکنش کامیت شد (committed)، برای همیشه پایدار باقی می‌ماند.

  برای مقیاس‌بندی یک پایگاه داده رابطه‌ای تکنیک‌های زیادی وجود دارد، از جمله: تکثیر اصلی-فرعی (master-slave replication)، تکثیر اصلی-اصلی (master-master replication)، فدراسیون (federation)، پارتیشن‌بندی (sharding)، غیرعادی‌سازی (denormalization) و تنظیم SQL (SQL tuning).
## تکثیر (Replication)

تکثیر فرآیند کپی کردن داده از یک پایگاه داده به پایگاه داده دیگر است. از تکثیر برای افزایش در دسترس‌بودن و مقیاس‌پذیری پایگاه‌های داده استفاده می‌شود. دو نوع اصلی تکثیر وجود دارد: اصلی-فرعی (master-slave) و اصلی-اصلی (master-master).

###  تکثیر اصلی-فرعی (Master-slave Replication)

در این نوع تکثیر، پایگاه داده اصلی (master) مسئولیت عملیات خواندن و نوشتن را بر عهده دارد و به‌صورت همزمان، عملیات نوشتن را بر روی یک یا چند پایگاه داده فرعی (slave) تکرار می‌کند. پایگاه‌های داده فرعی تنها قادر به خواندن داده‌ها هستند. این پایگاه‌های فرعی همچنین می‌توانند داده‌ها را بر روی سایر پایگاه‌های داده فرعی دیگر تکثیر کنند که این کار به شکل درختی انجام می‌شود. اگر پایگاه داده اصلی از دسترس خارج شود، سیستم می‌تواند در حالت فقط خواندن به کار خود ادامه دهد تا زمانی که یکی از پایگاه‌های داده فرعی به عنوان اصلی ارتقا پیدا کند یا یک پایگاه داده اصلی جدید راه‌اندازی شود.

### تکثیر اصلی-اصلی (Master-master Replication)

در تکثیر اصلی-اصلی، هر دو پایگاه داده اصلی می‌توانند عملیات خواندن و نوشتن را انجام دهند و در زمان عملیات نوشتن، با یکدیگر هماهنگ می‌شوند. اگر یکی از پایگاه‌های داده اصلی از کار بیفتد، سیستم می‌تواند همچنان به کار خود ادامه دهد و هر دو عملیات خواندن و نوشتن را انجام دهد.

## فدراسیون (Federation)

فدراسیون (یا پارتیشن بندی عملکردی) پایگاه داده‌ها را بر اساس عملکرد آن تقسیم می‌کند. به عنوان مثال، به جای یک پایگاه داده واحد و یکپارچه، می‌توانید سه پایگاه داده داشته باشید: انجمن‌ها، کاربران و محصولات، در نتیجه ترافیک خواندن و نوشتن کمتری برای هر پایگاه داده و در نتیجه تاخیر کمتری در تکرار وجود دارد. پایگاه داده‌های کوچکتر منجر به داده‌های بیشتری می‌شوند که می‌توانند در حافظه قرار بگیرند، که به نوبه خود به دلیل بهبود موقعیت حافظه کَش، بازدیدهای کَش بیشتری را به همراه دارد. بدون نوشتن سریال اصلی مرکزی واحد، می‌توانید به صورت موازی بنویسید و توان عملیاتی را افزایش دهید.

## غیرعادی‌سازی (Denormalization)

غیرعادی‌سازی (Denormalization) روشی است برای بهبود عملکرد خواندن با فدا کردن بخشی از عملکرد نوشتن. برای اجتناب از اتصالات پرهزینه (joins) در بانک‌های اطلاعاتی رابطه‌ای، کپی‌های اضافی از داده‌ها در جداول چندگانه نوشته می‌شوند. برخی از سیستم‌های مدیریت پایگاه‌داده رابطه‌ای مانند PostgreSQL و Oracle از نماهای مادی (materialized views) پشتیبانی می‌کنند که وظیفه ذخیره اطلاعات اضافی و همگام نگه داشتن کپی‌های اضافی را برعهده دارند.

با توزیع داده‌ها با تکنیک‌هایی مانند فدراسیون و پارتیشن‌بندی (sharding)، مدیریت اتصالات بین مراکز داده (data centers) پیچیدگی بیشتری پیدا می‌کند. غیرعادی‌سازی می‌تواند نیاز به چنین اتصالات پیچیده‌ای را دور بزند.


## ذخیره سازی کَش (Caching)

ذخیره سازی کَش (Caching) فرآیندی است که در آن داده‌های پرکاربرد به صورت موقت در مکانی به نام حافظه کَش (cache) ذخیره می‌شوند تا بازیابی سریع آنها بدون نیاز به مراجعه مستقیم به منبع اصلی داده انجام شود. این کار با کاهش تعداد دفعات دسترسی به منبع اصلی داده، باعث بهبود عملکرد برنامه می‌شود.

چندین استراتژی برای ذخیره سازی کَش وجود دارد، از جمله:

* ‏Refresh Ahead: با نزدیک شدن به زمان انقضای داده در حافظه کَش، داده‌های جدید از منبع اصلی فراخوانده و جایگزین داده‌های قدیمی در حافظه کَش می‌شوند.
* نوشتن پس‌زمینه (Write-Behind):  داده‌ها ابتدا در حافظه کَش نوشته شده و سپس با تاخیر به منبع اصلی داده نوشته می‌شوند.
* نوشتن همزمان (Write-Through): همزمان با نوشتن داده در حافظه کَش، داده در منبع اصلی نیز نوشته می‌شود.
*  Cache Aside: در این روش، منطق اصلی برنامه برای خواندن و نوشتن داده بدون در نظر گرفتن حافظه کَش نوشته می‌شود. سپس، یک لایه جداگانه برای بررسی حافظه کَش قبل از دسترسی به منبع اصلی داده اضافه می‌شود.

حافظه کَش همچنین می‌تواند در مکان‌های مختلفی قرار گیرد، از جمله:

* حافظه کَش کاربر (Client Caching): حافظه کَشی که در دستگاه کاربر قرار دارد.
* حافظه کَش توزیع محتوا (CDN Caching): حافظه کَشی که در شبکه توزیع محتوا (CDN) قرار دارد.
* حافظه کَش وب سرور (Web Server Caching): حافظه کَشی که در وب سرور قرار دارد.
* حافظه کَش پایگاه داده (Database Caching): حافظه کَشی که در کنار پایگاه داده قرار دارد.
* حافظه کَش برنامه (Application Caching): حافظه کَشی که درون برنامه تعبیه شده است.

الگوهای سازگاری به روش‌هایی اشاره دارند که داده در یک سیستم توزیع‌شده ذخیره و مدیریت می‌شود و چگونه این داده در دسترس کاربران و برنامه‌ها قرار می‌گیرد. سه نوع اصلی از الگوهای سازگاری وجود دارد:

* **سازگاری قوی (Strong consistency):**  در این الگو، تمام گره‌های (nodes) سیستم یک نسخه یکسان و به‌روز از داده را در هر لحظه در اختیار دارند. هر تغییری در داده بلافاصله به همه گره‌ها منتقل می‌شود. این الگو بیشترین سازگاری را ارائه می‌دهد، اما دستیابی به آن در سیستم‌های توزیع‌شده می‌تواند دشوار و پرهزینه باشد.
* **سازگاری ضعیف (Weak consistency):** در این الگو، الزامی برای اینکه همه گره‌ها بلافاصله از به‌روزرسانی داده مطلع شوند، وجود ندارد. ممکن است مدتی طول بکشد تا تغییرات به همه گره‌ها منتقل شود و کاربران یا برنامه‌ها ممکن است نسخه‌های متفاوتی از داده را در زمان‌های مختلف مشاهده کنند. این الگو می‌تواند عملکرد و مقیاس‌پذیری را بهبود بخشد، اما برای برنامه‌هایی که به داده‌های کاملاً به‌روز نیاز دارند، مناسب نیست.
* **سازگاری احتمالی (Eventual consistency):**  این الگو تضمین می‌کند که در نهایت، همه گره‌ها نسخه یکسانی از داده را در اختیار خواهند داشت. با این حال، ممکن است مدتی طول بکشد تا این اتفاق بیفتد. این الگو معمولاً در سیستم‌هایی که تأخیر در به‌روزرسانی داده قابل قبول است و در اولویت قرار دادن در دسترس بودن و مقیاس‌پذیری است، استفاده می‌شود.

انتخاب هر یک از این الگوها به نیازمندی‌های خاص برنامه یا سیستم بستگی دارد. برای مثال، یک سیستم بانکی ممکن است به سازگاری قوی برای اطمینان از صحت تراکنش‌ها نیاز داشته باشد، در حالی که یک شبکه اجتماعی ممکن است از سازگاری احتمالی برای بهینه‌سازی عملکرد استفاده کند.


----------------

------------------
--------------

## ناهمزمانی (Asynchronism)

گردش کارهای ناهمزمان (Asynchronism) به کاهش زمان پاسخگویی برای عملیات پرهزینه‌ای که به صورت درون خطی (همزمان) انجام می‌شوند، کمک می‌کنند. همچنین می‌توانند با انجام کارهای زمان بر به صورت مناسب تر، مانند تجمیع دوره‌ای داده ها، به بهبود عملکرد سیستم کمک کنند.
## عملیات ایدمپوتنت (Idempotent Operations)

عملیات ایدمپوتنت، عملیاتی هستند که می‌توان آن‌ها را چندین بار اجرا کرد بدون اینکه نتیجه نهایی فراتر از اولین اجرا تغییر کند. به عبارتی دیگر، اگر یک عملیات ایدمپوتنت باشد، فرقی نمی‌کند که یکبار یا چندین بار آن را اجرا کنید، نتیجه نهایی یکسان خواهد بود.

درک مزایای عملیات ایدمپوتنت، به خصوص هنگام استفاده از صف‌های پیام یا task که پردازش دقیقاً یکبار را تضمین نمی‌کنند، بسیار مهم است. بسیاری از سیستم‌های صف، تحویل یا پردازش پیام "حداقل یکبار" را تضمین می‌کنند. این سیستم‌ها به طور کامل همزمان سازی نشده اند، به عنوان مثال در سراسر مناطق جغرافیایی، که برخی از جنبه‌های پیاده سازی یا طراحی آنها را ساده می‌کند. طراحی عملیات اجرا شده توسط یک صف وظیفه برای اینکه ایدمپوتنت باشند، به فرد اجازه می‌دهد تا از سیستم صف بندی استفاده کند که این مصالحه طراحی را پذیرفته است.

## فشار معکوس (Back Pressure)

زمانی که صف‌ها (queue) به طور قابل توجهی رشد می‌کنند، اندازه صف می‌تواند از حافظه فراتر رود و در نتیجه منجر به خطاهای حافظه کَش (cache miss)، خواندن از دیسک و در نهایت عملکرد پایین‌تر شود. «فشار معکوس» با محدود کردن اندازه صف به حفظ نرخ خروجی بالا و زمان پاسخگویی مناسب برای کارهایی که قبلاً در صف قرار دارند، کمک می‌کند.

هنگامی که صف پر می‌شود، سرور به کلاینت‌ها (clients) سیگنال "سرور مشغول است" یا کد وضعیت HTTP 503 ارسال می‌کند تا بعداً دوباره تلاش کنند. کلاینت‌ها می‌توانند درخواست را در زمان دیگری، احتمالاً با تأخیر تصاعدی (exponential backoff)، دوباره امتحان کنند.

## صف‌های وظیفه (Task Queues)

صف‌های وظیفه، وظایف (task) و داده‌های مرتبط با آن‌ها را دریافت می‌کنند، آن‌ها را اجرا کرده و سپس نتایج را تحویل می‌دهند. این صف‌ها می‌توانند زمان‌بندی را پشتیبانی کنند و برای اجرای کارهای محاسباتی سنگین در پس‌زمینه مورد استفاده قرار گیرند.

یکی از ابزارهای محبوب برای صف‌های وظیفه، **Celery** است که از زمان‌بندی پشتیبانی می‌کند و عمدتاً از زبان برنامه‌نویسی پایتون (Python) پشتیبانی می‌کند. 

## صف‌های پیام (Message Queues)

صف‌های پیام، پیام‌ها را دریافت، نگهداری و تحویل می‌دهند.  اگر انجام یک عملیات به صورت درون‌خطی (inline)  بسیار زمانبر است، می‌توانید با استفاده از یک صف پیام و با گردش کار زیر، آن را بهبود بخشید:

* یک برنامه، یک کار (job) را در صف منتشر و سپس  وضعیت کار  را به کاربر اطلاع می‌دهد.
* یک پردازشگر (worker)، کار را از صف برداشته، آن را پردازش کرده و سپس تکمیل کار را اعلام می‌کند.
* کاربر مسدود نشده و کار در پس زمینه پردازش می‌شود. در این مدت، کاربر (اختیاری) می‌تواند کارهای کوچک دیگری را برای نمایش پیشرفت کار انجام دهد. به عنوان مثال، هنگام ارسال یک توییت، ممکن است بلافاصله در تایم‌لاین شما ارسال شود، اما ممکن است مدتی طول بکشد تا واقعاً برای همه دنبال کنندگان شما ارسال شود.

برخی از صف‌های پیام محبوب به شرح زیر هستند:

* **Redis:** به عنوان یک کارگزار ساده پیام (message broker) مفید است، اما پیام‌ها ممکن است از بین بروند.
* **RabbitMQ:** محبوب است، اما نیازمند سازگاری با پروتکل AMQP و مدیریت گره‌های خود (nodes) است.
* **AWS SQS:** میزبانی شده است، اما می‌تواند تأخیر زیادی داشته باشد و احتمال ارسال دو باره پیام‌ها وجود دارد.
* **Apache Kafka:** یک پلتفرم توزیع شده برای ذخیره رویدادها (event store) و پردازش جریان (stream-processing) است.

--------------
--------------
--------------



## توزیع کننده بار (Load Balancers)

توزیع کننده بار وظیفه توزیع درخواست‌های ورودی از سمت کاربران (client) به منابع محاسباتی مانند سرورهای برنامه و پایگاه‌های داده را بر عهده دارد. در هر مورد، توزیع کننده بار پاسخ را از منبع محاسباتی به کاربر مربوطه ارسال می‌کند. توزیع کننده‌های بار در موارد زیر موثر هستند:

* **جلوگیری از ارسال درخواست به سرورهای معیوب:** با توزیع بار، درخواست‌ها به سرورهای سالم هدایت شده و از ارسال به سرورهای از کار افتاده جلوگیری می‌شود.
* **جلوگیری از اضافه بار منابع:** توزیع کننده بار با مدیریت ترافیک ورودی مانع از بارگذاری بیش از حد منابع محاسباتی می‌شود.
* **حذف نقطه واحد شکست (Single Point of Failure):** با حذف وابستگی به یک سرور واحد، در صورت خرابی یک سرور، سایر سرورها همچنان به سرویس‌دهی ادامه می‌دهند.

توزیع کننده بار را می‌توان به صورت سخت‌افزاری (پرهزینه) یا نرم‌افزاری مانند HAProxy پیاده‌سازی کرد. مزایای اضافی توزیع کننده بار شامل موارد زیر است:

* **اتمام SSL:** رمزگشایی درخواست‌های ورودی و رمزگذاری پاسخ‌های سرور به گونه‌ای که سرورهای پشتیبان نیازی به انجام این عملیات پرهزینه نداشته باشند.
* **حذف نیاز به نصب گواهینامه‌های X.509 روی هر سرور:** با اتمام SSL توسط توزیع کننده بار، دیگر نیازی به نصب جداگانه این گواهینامه‌ها روی تک تک سرورها نیست.
* **پایداری نشست (Session Persistence):** صدور کوکی (cookie) و مسیریابی درخواست‌های یک کاربر خاص به همان نمونه سرور (در صورتی که برنامه‌های وب، خودشان مدیریت نشست را انجام ندهند).

**معایب توزیع کننده بار:**

* **تبدیل شدن به گلوگاه عملکردی (Performance Bottleneck):** در صورتی که توزیع کننده بار منابع کافی نداشته باشد یا به درستی پیکربندی نشود، خود می‌تواند به یک گلوگاه عملکرد تبدیل شود و باعث کاهش کارایی شود.
* **افزایش پیچیدگی:** معرفی یک توزیع کننده بار برای حذف نقطه واحد شکست، منجر به افزایش پیچیدگی سیستم می‌شود.
* **نقطه واحد شکست در توزیع کننده بار:** خود توزیع کننده بار نیز می‌تواند یک نقطه واحد ضعف و شکست باشد. پیکربندی چندین توزیع کننده بار برای رفع این مشکل، پیچیدگی را بیش از پیش افزایش می‌دهد.


یع کننده بار در مقابل پروکسی معکوس (Load Balancer vs Reverse Proxy)

در نگاه اول، توزیع کننده بار (Load Balancer) و پروکسی معکوس (Reverse Proxy) ممکن است شبیه به هم به نظر برسند، اما در واقع نقش‌های متفاوتی در یک سیستم توزیع شده ایفا می‌کنند. در اینجا به بررسی تفاوت‌های کلیدی آن‌ها می‌پردازیم:

**توزیع کننده بار (Load Balancer):**

* **کاربرد:** در صورتی که چندین سرور داشته باشید که یک کارکرد مشابه را انجام می‌دهند، توزیع کننده بار مفید است. 
* **وظیفه:** وظیفه اصلی توزیع کننده بار، هدایت و توزیع درخواست‌های ورودی از سمت کاربران (client) به سرورهای مختلف است. این توزیع با در نظر گرفتن عواملی مانند بار کاری سرورها و سلامت آن‌ها انجام می‌شود.
* **مزایا:**
    * جلوگیری از ارسال درخواست به سرورهای معیوب
    * جلوگیری از اضافه بار سرورها
    * حذف نقطه واحد شکست (Single Point of Failure)
* **معایب:**
    * تبدیل شدن به گلوگاه عملکرد در صورت عدم پیکربندی صحیح یا کمبود منابع
    * افزایش پیچیدگی با معرفی توزیع کننده بار

**پروکسی معکوس (Reverse Proxy):**

* **کاربرد:** پروکسی معکوس حتی با یک سرور وب یا سرور برنامه نیز کاربردی است.
* **وظیفه:** پروکسی معکوس به عنوان واسطه‌ای بین کاربر و سرور عمل می‌کند. درخواست‌های کاربر را دریافت کرده و ممکن است پیش از ارسال به سرور اصلی، تغییراتی روی آن‌ها اعمال کند (مانند مسیریابی، امنیت، کش). سپس پاسخ سرور را دریافت و برای کاربر ارسال می‌کند.
* **مزایا:**
    * امنیت: پروکسی معکوس می‌تواند برخی از وظایف امنیتی مانند اتمام SSL را انجام دهد.
    * بهبود عملکرد: با استفاده از کَش می‌توان سرعت دسترسی به منابع را افزایش داد.
    * مدیریت بار: در حد ابتدایی می‌تواند به مدیریت بار روی سرور اصلی کمک کند.
* **معایب:**
    * افزایش پیچیدگی با معرفی پروکسی معکوس
    * نقطه واحد شکست در صورت استفاده از تک پروکسی معکوس

**نکات کلیدی:**

* توزیع کننده بار برای توزیع ترافیک بر روی چندین سرور با کارکرد مشابه استفاده می‌شود.
* پروکسی معکوس واسطه‌ای بین کاربر و سرور اصلی است و می‌تواند وظایف مختلفی مانند امنیت، کش و مدیریت ابتدایی بار را انجام دهد.
* راه‌کارهایی مانند NGINX و HAProxy از هر دو قابلیت توزیع بار و نقش پروکسی معکوس در لایه ۷ (لایه اپلیکیشن) پشتیبانی می‌کنند.

## الگوریتم‌های توزیع بار (Load Balancing Algorithms)

توزیع کننده بار (load balancer) یک دستگاه نرم افزاری یا سخت افزاری است که از اضافه بارگذاری روی هر یک از سرورها جلوگیری می‌کند. الگوریتم توزیع بار منطقی است که توزیع کننده بار از آن برای توزیع ترافیک شبکه بین سرورها استفاده می‌کند (الگوریتم مجموعه ای از قوانین از پیش تعریف شده است).

دو رویکرد اصلی برای توزیع بار وجود دارد:

* **توزیع بار پویا (Dynamic load balancing):** در این روش، الگوریتم‌ها با در نظر گرفتن وضعیت فعلی هر سرور، ترافیک را توزیع می‌کنند. به عنوان مثال، ممکن است سروری شلوغ باشد در حالی که سرور دیگری بیکار باشد. الگوریتم توزیع بار پویا، ترافیک را به سمت سرور کم کار هدایت می‌کند تا بار به طور مساوی توزیع شود.
* **توزیع بار ایستا (Static load balancing):** در این روش، ترافیک بدون در نظر گرفتن وضعیت سرورها توزیع می‌شود.  برخی از الگوریتم‌های ایستا، ترافیک را به طور مساوی بین سرورها توزیع می‌کنند، این توزیع می‌تواند به صورت گردشی (round robin) یا تصادفی (random) باشد.

در اینجا برخی از رایج ترین الگوریتم‌های توزیع بار آورده شده است:

* **Round Robin (گردشی):** این الگوریتم ساده، درخواست‌ها را به صورت نوبت به سرورهای موجود ارسال می‌کند. 
* **Least Connections (کمترین اتصال):** در این روش، سروری که در حال حاضر کمترین تعداد اتصال را دارد، برای درخواست بعدی انتخاب می‌شود. 
* **Weighted Round Robin (گردشی با وزن):** این الگوریتم مشابه گردشی (round robin) است، اما به هر سرور وزنی اختصاص داده می‌شود. سرورهای با وزن بالاتر، درخواست‌های بیشتری را دریافت می‌کنند. این روش برای سرورهایی با توانایی پردازش متفاوت مناسب است.
* **Least Response Time (کمترین زمان پاسخ):** در این روش، سروری که کمترین زمان پاسخگویی را در آخرین بررسی‌ها داشته، برای درخواست بعدی انتخاب می‌شود.

انتخاب الگوریتم مناسب به عوامل مختلفی از جمله تعداد سرورها، نوع ترافیک و نیازمندی‌های برنامه بستگی دارد.


## توزیع بار لایه 7 (Layer 7 Load Balancing)

توزیع کننده بار لایه 7 با بررسی لایه کاربرد (application layer) تصمیم می‌گیرد که درخواست‌ها را چگونه توزیع کند. این بررسی می‌تواند شامل محتویات هدر (header)، پیام و کوکی‌ها (cookies) باشد. توزیع کننده بار لایه 7 ترافیک شبکه را خاتمه می‌دهد، پیام را می‌خواند، تصمیم توزیع بار را می‌گیرد و سپس اتصالی را به سرور انتخاب شده باز می‌کند. به عنوان مثال، یک توزیع کننده بار لایه 7 می‌تواند ترافیک ویدیو را به سرورهایی که میزبان ویدیوها هستند هدایت کند و در عین حال ترافیک حساس‌تر صورتحساب کاربران را به سرورهایی با امنیت بالا هدایت کند.


## توزیع بار لایه 4 (Layer 4 Load Balancing)

توزیع کننده بار لایه 4 با بررسی اطلاعات موجود در لایه حمل و نقل (transport layer) شبکه، در مورد توزیع درخواست‌ها تصمیم گیری می‌کند. به طور کلی، این اطلاعات شامل آدرس‌های IP منبع و مقصد و پورت‌ها در هدر بسته (packet header) می‌شود، اما محتوای داخل بسته در نظر گرفته نمی‌شود. توزیع کننده بار لایه 4 بسته‌های شبکه را به سرورهای بالادستی (upstream servers) ارسال و از آنها دریافت می‌کند و در عین حال ترجمه آدرس شبکه (NAT) را انجام می‌دهد.

## مقیاس‌بندی افقی (Horizontal Scaling)

توزیع کننده‌های بار همچنین می‌توانند با مقیاس‌بندی افقی به بهبود عملکرد و در دسترس بودن سیستم کمک کنند. 
مقیاس‌بندی با استفاده از سخت‌افزارهای رایج از نظر هزینه مؤثرتر است و منجر به در دسترس بودن بالاتری نسبت به ارتقای یک سرور واحد با سخت‌افزار گران‌تر (مقیاس‌بندی عمودی) می‌شود. همچنین استخدام افرادی که روی سخت‌افزارهای رایج کار می‌کنند، نسبت به سیستم‌های تخصصی سازمانی آسان‌تر است.

## معایب مقیاس‌بندی افقی

مقیاس‌بندی افقی باعث افزایش پیچیدگی شده و شامل کلون کردن سرورها می‌شود.
سرورها باید stateless باشند: یعنی نباید هیچ داده مرتبط با کاربر مانند جلسات یا تصاویر پروفایل را در خود ذخیره کنند.
جلسات (Sessions) را می‌توان در یک ذخیره‌گاه داده مرکزی مانند پایگاه داده (SQL، NoSQL) یا یک حافظه کَش دائمی (Redis، Memcached) ذخیره کرد.
سرورهای پایین‌دستی مانند حافظه‌های کَش و پایگاه‌های داده با افزایش سرورهای بالادستی نیاز به مدیریت اتصالات همزمان بیشتری دارند.

## میکروسرویس‌ها (Microservices)

مایکروسرویس‌ها وجود دارند که می‌توان آن‌ها را مجموعه‌ای از سرویس‌های مستقل، کوچک و ماژولار توصیف کرد که قابلیت استقرار مستقل دارند. هر سرویس یک فرآیند منحصر به فرد را اجرا می‌کند و از طریق یک مکانیزم سبک و از پیش تعریف شده برای خدمت به یک هدف تجاری خاص، ارتباط برقرار می‌کند.

به عنوان مثال، پینترست می‌تواند دارای میکروسرویس‌های زیر باشد: پروفایل کاربری، دنبال‌کننده، فید، جستجو، آپلود عکس و غیره.



## کشف سرویس (Service Discovery)

در سیستم‌های توزیع‌شده‌ای که از میکروسرویس‌ها استفاده می‌شود، سرویس‌ها برای برقراری ارتباط با یکدیگر به روشی برای کشف هم نیاز دارند. کشف سرویس به این معنی است که سرویس‌ها بتوانند موقعیت (آدرس و پورت) سایر سرویس‌ها را پیدا کنند.

ابزارهایی مانند Consul، Etcd و Zookeeper به کشف سرویس کمک می‌کنند. این ابزارها با ثبت نام سرویس‌ها به همراه نام، آدرس و پورت آن‌ها، به سایر سرویس‌ها امکان می‌دهند موقعیت یکدیگر را پیدا کنند.

علاوه بر کشف سرویس، این ابزارها اغلب از بررسی‌های سلامت (Health Checks) نیز پشتیبانی می‌کنند. بررسی‌های سلامت با استفاده از یک نقطه انتهایی HTTP (معمولا یک API) انجام می‌شود تا از در دسترس بودن و سلامت سرویس‌ها اطمینان حاصل شود.

برخی از این ابزارها مانند Consul و Etcd همچنین دارای یک حافظه کلید-مقدار (Key-Value Store) داخلی هستند که برای ذخیره مقادیر پیکربندی (Configuration Values) و سایر داده‌های مشترک بین سرویس‌ها مفید است.

##  failover

Failover یک الگوی در دسترس بودن (availability) است که برای اطمینان از ادامه کارکرد یک سیستم در صورت بروز خرابی استفاده می‌شود. این شامل داشتن یک مؤلفه یا سیستم پشتیبان است که می‌تواند در صورت خرابی، مسئولیت را بر عهده گیرد.

در یک سیستم Failover، یک مؤلفه اصلی وجود دارد که وظیفه رسیدگی به درخواست‌ها را بر عهده دارد و یک مؤلفه ثانویه (یا پشتیبان) به صورت آماده به کار (standby) وجود دارد. مؤلفه اصلی برای خرابی‌ها مانیتور می‌شود و در صورت خرابی، مؤلفه ثانویه برای انجام وظایف آن فعال می‌شود. این امر به سیستم اجازه می‌دهد تا با حداقل اختلال به کار خود ادامه دهد.

Failover را می‌توان به روش‌های مختلفی مانند فعال-پسیو، فعال-فعال و آماده به کار گرم (hot-standby) اجرا کرد.

### فعال-پسیو (Active-Passive)

با Failover فعال-پسیو، سیگنال‌هایی معروف به ضربان قلبی(heartbeats) بین سرور فعال و سرور آماده به کار رد و بدل می‌شود. اگر این سیگنال قطع شود، سرور آماده به کار، آدرس IP سرور فعال را به عهده گرفته و سرویس دهی را از سر می‌گیرد.

مدت زمان خرابی بستگی به این دارد که آیا سرور آماده به کار از قبل در حالت "گرم" (hot) اجرا شده باشد یا اینکه نیاز به راه اندازی از حالت "سرد" (cold) داشته باشد. فقط سرور فعال ترافیک را مدیریت می‌کند.

Failover فعال-پسیو را همچنین می‌توان Failover اصلی-فرعی (master-slave) نامید.

### فعال-فعال (Active-Active)

در حالت فعال-فعال، هر دو سرور ترافیک را مدیریت می‌کنند و بار را بین خود تقسیم می‌کنند.

اگر سرورها رو به بیرون (public-facing) باشند، DNS باید از IP‌های عمومی هر دو سرور مطلع باشد. اگر سرورها رو به داخل (internal-facing) باشند، منطق برنامه باید از هر دو سرور مطلع باشد.

Failover فعال-فعال را همچنین می‌توان Failover اصلی-اصلی (master-master) نامید.


## معایب Failover

Failover سخت افزار بیشتر و پیچیدگی بیشتری را به همراه دارد.
در صورتی که سیستم فعال قبل از تکثیر داده‌های تازه نوشته شده به سیستم غیرفعال، با مشکل مواجه شود، احتمال از دست رفتن داده‌ها وجود دارد.


## تکثیر داده (Replication)

تکثیر داده یک الگوی در دسترس بودن است که شامل داشتن چندین کپی از داده‌های یکسان در مکان‌های مختلف است. در صورت خرابی، داده‌ها را می‌توان از مکان دیگری بازیابی کرد. دو نوع اصلی تکثیر وجود دارد: تکثیر اصلی-اصلی (Master-Master) و تکثیر اصلی-فرعی (Master-Slave).

### تکثیر اصلی-اصلی (Master-Master):

در این نوع تکثیر، چندین سرور به عنوان "اصلی" پیکربندی می‌شوند و هر کدام می‌توانند عملیات خواندن و نوشتن را انجام دهند. این امر به در دسترس بودن بالا و امکان جانشینی هر یک از سرورها در صورت خرابی یکی از آنها کمک می‌کند. با این حال، این نوع تکثیر در صورت به‌روزرسانی همزمان داده‌های یکسان توسط چندین سرور در یک زمان، می‌تواند منجر به تضاد شود، بنابراین برای رسیدگی به این موضوع به یک مکانیزم حل تضاد نیاز است.

### تکثیر اصلی-فرعی (Master-Slave):‏

در این نوع تکثیر، یک سرور به عنوان "اصلی" تعیین می‌شود و تمام عملیات نوشتن را کنترل می‌کند، در حالی که چندین سرور "فرعی" عملیات خواندن را انجام می‌دهند. اگر سرور اصلی با مشکل مواجه شود، یکی از سرورهای فرعی می‌تواند ارتقا پیدا کند و جایگزین آن شود. راه اندازی و نگهداری این نوع تکثیر نسبت به تکثیر اصلی-اصلی ساده تر است.



## شبکه توزیع محتوا (Content Delivery Networks - CDN)

شبکه توزیع محتوا (CDN) شبکه‌ای سراسری از سرورهای واسط (proxy server) است که محتوا را از مکان‌هایی نزدیک‌تر به کاربر ارائه می‌دهد. به طور کلی، فایل‌های استاتیک مانند HTML/CSS/JS، عکس‌ها و ويديوها از طریق CDN ارائه می‌شوند، اگرچه برخی از CDNها مانند CloudFront آمازون از محتوای پویا نیز پشتیبانی می‌کنند. تفکیک‌پذیری DNS سایت به کاربران می‌گوید که با کدام سرور تماس بگیرند.

ارائه محتوا از طریق CDN می‌تواند عملکرد را از دو طریق به طور قابل توجهی بهبود بخشد:

* کاربران محتوا را از مراکز داده نزدیک به خود دریافت می‌کنند.
* سرورهای شما مجبور نیستند به درخواست‌هایی که CDN برآورده می‌کند، پاسخ دهند.

## کارهای پس‌زمینه (Background Jobs)

در طراحی سیستم، کارهای پس‌زمینه به وظایفی گفته می‌شود که به صورت مجزا از جریان اجرای اصلی سیستم، در پس‌زمینه اجرا می‌شوند. این وظایف معمولاً به جای کاربر یا عامل خارجی دیگر، توسط خود سیستم آغاز می‌گردند.

کارهای پس‌زمینه را می‌توان برای اهداف مختلفی به کار گرفت، از جمله:

* **انجام وظایف نگهداری:** مانند پاکسازی داده‌های قدیمی، تهیه گزارش یا پشتیبان‌گیری از پایگاه داده.
* **پردازش حجم زیادی از داده‌ها:** مانند وارد کردن داده‌ها، خروجی گرفتن داده‌ها یا تبدیل داده‌ها.
* **فرستادن اعلان‌ها یا پیام‌ها:** مانند ارسال ایمیل‌های اطلاع‌رسانی یا   push notification به کاربران.
* **انجام محاسبات طولانی‌مدت:** مانند یادگیری ماشین یا تحلیل داده‌ها.
## تأخیر (Latency) در مقابل توان عملیاتی (Throughput)

تأخیر (Latency) و توان عملیاتی (Throughput) دو معیار مهم برای سنجش عملکرد یک سیستم هستند.

* **تأخیر (Latency):** مدت زمانی است که طول می‌کشد تا یک سیستم به یک درخواست پاسخ دهد. تأخیر کم نشان دهنده پاسخگویی سریع سیستم است. برای مثال، تأخیر کم در هنگام بارگذاری یک صفحه وب به معنای نمایش سریعتر صفحه برای کاربر است.
* **توان عملیاتی (Throughput):** تعداد درخواست‌هایی است که یک سیستم می‌تواند در یک دوره زمانی مشخص مدیریت کند. توان عملیاتی بالا نشان می‌دهد که سیستم ظرفیت پاسخگویی به حجم زیادی از درخواست‌ها را دارد. برای مثال، توان عملیاتی بالای یک سرور وب به این معنی است که می‌تواند به طور همزمان به درخواست‌های کاربران زیادی پاسخ دهد.

به طور کلی، شما باید به دنبال حداکثر توان عملیاتی با تأخیر قابل قبول باشید. در حالت ایده‌آل، می‌خواهید سیستم شما بتواند درخواست‌های زیادی را به طور همزمان مدیریت کند (توان عملیاتی بالا) در حالی که همچنان پاسخگویی سریعی برای هر درخواست (تأخیر کم) داشته باشد. 

این دو معیار اغلب با هم در ارتباط هستند. برای مثال، افزایش توان عملیاتی گاهی می‌تواند منجر به افزایش تأخیر شود، زیرا سیستم با حجم بیشتری از درخواست‌ها سروکار دارد. 

بنابراین، هنگام تنظیم و بهینه‌سازی یک سیستم، باید تعادلی بین تأخیر و توان عملیاتی برقرار کنید. 


ان مبتنی بر رویداد (Event-Driven Invocation)

فراخوان مبتنی بر رویداد (Event-Driven Invocation) از یک رویداد محرک (trigger) برای شروع کارهای پس‌زمینه استفاده می‌کند. نمونه‌هایی از استفاده از محرک‌های مبتنی بر رویداد عبارتند از:

* رابط کاربری (UI) یا یک کار پس‌زمینه دیگر، پیامی را در یک صف (queue) قرار می‌دهد. این پیام حاوی داده‌هایی در مورد عملی است که انجام شده است، مانند ثبت سفارش توسط کاربر.
* کار پس‌زمینه به این صف گوش می‌دهد و رسیدن یک پیام جدید را تشخیص می‌دهد. این کار پیام را خوانده و از داده‌های موجود در آن به عنوان ورودی برای کار پس‌زمینه استفاده می‌کند. این الگو به عنوان ارتباط ناهمزمان مبتنی بر پیام شناخته می‌شود (Asynchronous Message-Based Communication).
* رابط کاربری یا یک کار پس‌زمینه دیگر، مقداری را در حافظه ذخیره‌سازی کرده یا به‌روزرسانی می‌کند. کار پس‌زمینه، حافظه ذخیره‌سازی را کنترل کرده و تغییرات را تشخیص می‌دهد. این کار داده‌ها را خوانده و از آنها به عنوان ورودی برای کار پس‌زمینه استفاده می‌کند.
* رابط کاربری یا یک کار پس‌زمینه دیگر درخواستی را به یک نقطه انتهایی (endpoint)، مانند یک URI HTTPS یا یک API که به عنوان یک سرویس وب در معرض دید قرار گرفته است، ارسال می‌کند. این درخواست، داده‌های مورد نیاز برای تکمیل کار پس‌زمینه را به عنوان بخشی از درخواست منتقل می‌کند. نقطه انتهایی یا سرویس وب، کار پس‌زمینه را فراخوانی می‌کند که از داده‌ها به عنوان ورودی خود استفاده می‌کند.

در فراخوان مبتنی بر رویداد، به جای اینکه مستقیماً یک کار پس‌زمینه را راه‌اندازی کنید، رویدادی را ایجاد می‌کنید که نشان‌دهنده نیاز به انجام یک کار خاص است. این رویداد به عنوان محرک عمل می‌کند و کار پس‌زمینه در زمان مناسب با توجه به رویداد شروع می‌شود. این رویکرد مزایای مختلفی از جمله:

* **کوپِلینگ شل (Loose Coupling):** اجزای سیستم به هم وابسته نیستند. هر جزء می‌تواند رویدادها را منتشر کند و به رویدادهای مورد علاقه‌اش گوش دهد، بدون اینکه بداند چه کسی رویدادها را تولید یا مصرف می‌کند.
* **مقیاس‌پذیری (Scalability):** شما می‌توانید به راحتی کارهای پس‌زمینه بیشتری را برای پردازش رویدادها اضافه کنید تا با افزایش حجم کار مطابقت داشته باشید.
* **انعطاف‌پذیری (Resilience):** اگر یک کار پس‌زمینه با مشکل مواجه شود، رویداد همچنان در صف باقی می‌ماند و بعداً توسط یک کارگر دیگر پردازش می‌شود.