درخواست‌های ارسال شده به سرویس‌ها را اولویت‌بندی کنید تا درخواست‌های دارای اولویت بالاتر سریع‌تر از درخواست‌هایی با اولویت پایین‌تر دریافت و پردازش شوند. این الگو در برنامه هایی مفید است که ضمانت های سطح خدمات متفاوتی را به مشتریان فردی ارائه می دهند.

## Context and problem

برنامه‌ها می‌توانند وظایف خاصی را به سرویس‌های دیگر واگذار کنند، به عنوان مثال، برای انجام پردازش پس‌زمینه یا ادغام با سایر برنامه‌ها یا خدمات. در ابر، یک صف پیام معمولاً برای واگذاری وظایف به پردازش پس‌زمینه استفاده می‌شود. در بسیاری از موارد، ترتیب دریافت درخواست‌ها توسط یک سرویس مهم نیست. با این حال، در برخی موارد، اولویت بندی درخواست های خاص ضروری است. این درخواست‌ها باید زودتر از درخواست‌های با اولویت پایین‌تر که قبلاً توسط برنامه ارسال شده‌اند، پردازش شوند.

## Solution

یک صف معمولاً یک ساختار اولین ورود، اولین خروج (FIFO) است و مصرف کنندگان معمولاً پیام ها را به همان ترتیبی که در صف ارسال می شوند دریافت می کنند. با این حال، برخی از صف های پیام از پیام رسانی اولویت دار پشتیبانی می کنند. برنامه‌ای که پیامی را ارسال می‌کند می‌تواند اولویتی را تعیین کند. پیام‌های موجود در صف به‌طور خودکار مرتب می‌شوند تا پیام‌هایی که اولویت بالاتری دارند قبل از پیام‌هایی که اولویت کمتری دارند دریافت شوند. این نمودار روند را نشان می دهد:

![[Pasted image 20231205112924.png]]

```
توجه داشته باشید  
  
اکثر پیاده سازی های صف پیام از چندین مصرف کننده پشتیبانی می کنند. (به الگوی مصرف کنندگان رقیب مراجعه کنید.) تعداد فرآیندهای مصرف کننده را می توان بر اساس تقاضا کم و زیاد کرد.
```


در سیستم‌هایی که از صف‌های پیام مبتنی بر اولویت پشتیبانی نمی‌کنند، یک راه‌حل جایگزین حفظ یک صف جداگانه برای هر اولویت است. برنامه وظیفه ارسال پیام ها به صف مناسب را بر عهده دارد. هر صف می تواند یک مجموعه جداگانه از مصرف کنندگان داشته باشد. صف‌های با اولویت بالاتر می‌توانند تعداد بیشتری از مصرف‌کنندگان داشته باشند که با سخت‌افزار سریع‌تر از صف‌های با اولویت پایین‌تر کار می‌کنند. این نمودار استفاده از صف های پیام جداگانه برای هر اولویت را نشان می دهد:

![[Pasted image 20231205112950.png]]

یک تغییر در این استراتژی، پیاده‌سازی یک مجموعه واحد از مصرف‌کنندگان است که ابتدا پیام‌ها را در صف‌های اولویت بالا بررسی می‌کنند و تنها پس از آن شروع به واکشی پیام‌ها از صف‌های با اولویت پایین‌تر می‌کنند. تفاوت‌های معنایی بین راه‌حلی که از یک مجموعه واحد از فرآیندهای مصرف‌کننده استفاده می‌کند (یا با یک صف که از پیام‌هایی با اولویت‌های متفاوت پشتیبانی می‌کند یا با صف‌های متعدد که هر کدام پیام‌های با اولویت واحد را مدیریت می‌کنند) و راه‌حلی که از چندین صف استفاده می‌کند وجود دارد. با یک استخر مجزا برای هر صف.  
  
در رویکرد تک استخر، پیام‌های با اولویت بالاتر همیشه قبل از پیام‌های با اولویت پایین‌تر دریافت و پردازش می‌شوند. در تئوری، پیام های با اولویت پایین می توانند به طور مداوم جایگزین شوند و ممکن است هرگز پردازش نشوند. در رویکرد استخر چندگانه، پیام‌های با اولویت پایین‌تر همیشه پردازش می‌شوند، اما نه به سرعت پیام‌های با اولویت بالاتر (بسته به اندازه نسبی استخرها و منابع موجود برای آنها).  
  
استفاده از مکانیزم صف بندی اولویت می تواند مزایای زیر را به همراه داشته باشد:

* این به برنامه‌ها اجازه می‌دهد تا نیازمندی‌های تجاری را برآورده کنند که نیازمند اولویت‌بندی در دسترس بودن یا عملکرد هستند، مانند ارائه سطوح مختلف خدمات به گروه‌های مختلف مشتریان.  
  
* می تواند به کاهش هزینه های عملیاتی کمک کند. اگر از روش تک صف استفاده می کنید، می توانید در صورت نیاز تعداد مصرف کنندگان را کاهش دهید. پیام‌های با اولویت بالا همچنان ابتدا پردازش می‌شوند (اگرچه احتمالاً آهسته‌تر) و پیام‌های با اولویت پایین‌تر ممکن است برای مدت بیشتری به تأخیر بیفتند. اگر رویکرد صف پیام چندگانه را با مجموعه‌های جداگانه مصرف‌کننده برای هر صف پیاده‌سازی کنید، می‌توانید تعداد مصرف‌کنندگان را برای صف‌های با اولویت پایین‌تر کاهش دهید. حتی می‌توانید پردازش برخی از صف‌های با اولویت بسیار پایین را با متوقف کردن تمام مصرف‌کنندگانی که در آن صف‌ها به پیام‌ها گوش می‌دهند، متوقف کنید.  
  
* رویکرد صف پیام چندگانه می‌تواند با پارتیشن‌بندی پیام‌ها بر اساس نیازهای پردازش، به حداکثر کردن عملکرد و مقیاس‌پذیری برنامه کمک کند. به عنوان مثال، می‌توانید وظایف حیاتی را اولویت‌بندی کنید تا توسط گیرنده‌هایی که بلافاصله اجرا می‌شوند، و وظایف کمتر مهم پس‌زمینه توسط گیرنده‌هایی که قرار است در زمان‌هایی که شلوغ کمتری دارند اجرا شوند، انجام شوند.

## Considerations

هنگام تصمیم گیری در مورد نحوه اجرای این الگو به نکات زیر توجه کنید:  
  
* اولویت ها را در چارچوب راه حل تعریف کنید. به عنوان مثال، یک پیام با اولویت بالا می تواند به عنوان پیامی تعریف شود که باید در عرض 10 ثانیه پردازش شود. الزامات مربوط به رسیدگی به موارد با اولویت بالا و منابعی را که باید برای برآورده کردن معیارهای شما تخصیص داده شود، شناسایی کنید.  
  
* تصمیم بگیرید که آیا همه موارد با اولویت بالا باید قبل از هر مورد با اولویت پایین تر پردازش شوند یا خیر. اگر پیام‌ها توسط یک مجموعه از مصرف‌کنندگان پردازش می‌شوند، باید مکانیزمی ارائه کنید که می‌تواند کاری را که در حال مدیریت یک پیام با اولویت پایین است، در صورتی که پیامی با اولویت بالاتر وارد صف شود، از پیش گرفته و به حالت تعلیق درآورد.  
  
* در رویکرد چند صف، وقتی از یک مجموعه واحد از فرآیندهای مصرف‌کننده استفاده می‌کنید که به همه صف‌ها گوش می‌دهند نه یک مجموعه اختصاصی مصرف‌کننده برای هر صف، مصرف‌کننده باید الگوریتمی را اعمال کند که تضمین کند همیشه پیام‌ها را از صف‌های با اولویت بالاتر قبل از پیام‌هایی از سمت پایین‌تر ارائه می‌کند. صف های اولویت دار  
  
* سرعت پردازش را در صف‌های با اولویت بالا و پایین کنترل کنید تا مطمئن شوید که پیام‌های موجود در آن صف‌ها با نرخ‌های مورد انتظار پردازش می‌شوند.  
  
* اگر می‌خواهید تضمین کنید که پیام‌های با اولویت پایین پردازش می‌شوند، رویکرد صف پیام‌های چندگانه را با مجموعه‌های متعدد مصرف‌کننده اجرا کنید. از طرف دیگر، در صفی که از اولویت بندی پیام پشتیبانی می کند، می توانید به صورت پویا اولویت یک پیام در صف را با افزایش سن افزایش دهید. با این حال، این رویکرد به صف پیام ارائه کننده این ویژگی بستگی دارد.  
  
* استراتژی استفاده از صف های جداگانه بر اساس اولویت پیام برای سیستم هایی توصیه می شود که دارای چند اولویت کاملاً مشخص هستند.  
  
* سیستم می تواند به طور منطقی اولویت های پیام را تعیین کند. برای مثال، به جای داشتن پیام‌های صریح با اولویت بالا و پایین، می‌توانید پیام‌ها را به‌عنوان «مشتری پرداخت‌کننده» یا «مشتری بدون پرداخت» تعیین کنید. سپس سیستم شما می تواند منابع بیشتری را به پردازش پیام های مشتریان پرداخت کننده اختصاص دهد.  
  
* ممکن است هزینه‌های مالی و پردازشی مربوط به بررسی یک صف برای یک پیام باشد. به عنوان مثال، برخی از سیستم‌های پیام‌رسان تجاری هر بار که پیامی پست یا بازیابی می‌شود، هزینه کمی دریافت می‌کنند، و هر بار که یک صف برای پیام‌ها درخواست می‌شود. این هزینه زمانی افزایش می یابد که چندین صف را بررسی کنید.  
  
* شما می توانید به صورت پویا اندازه یک مجموعه از مصرف کنندگان را بر اساس طول صفی که استخر در حال سرویس دهی است، تنظیم کنید. برای اطلاعات بیشتر، به راهنمای مقیاس خودکار مراجعه کنید.

## When to use this pattern

این الگو در سناریوهایی مفید است که:  
  
* سیستم باید وظایف متعددی را انجام دهد که اولویت های متفاوتی دارند.  
  
* به کاربران یا مستاجران مختلف باید با اولویت های متفاوت خدمات داده شود.

## Example

Azure مکانیزم صف بندی را ارائه نمی دهد که به طور بومی از اولویت بندی خودکار پیام ها از طریق مرتب سازی پشتیبانی کند. با این حال، موضوعات Azure Service Bus، اشتراک‌های Service Bus را ارائه می‌کند که از مکانیزم صف‌بندی پشتیبانی می‌کند که فیلتر پیام را فراهم می‌کند، و طیف وسیعی از قابلیت‌های انعطاف‌پذیر که Azure را برای اکثر پیاده‌سازی‌های صف اولویت ایده‌آل می‌کند.  
  
یک راه‌حل Azure می‌تواند یک موضوع Service Bus را پیاده‌سازی کند که یک برنامه می‌تواند پیام‌ها را به آن ارسال کند، درست همانطور که آنها را در یک صف ارسال می‌کند. پیام‌ها می‌توانند حاوی متادیتا به شکل ویژگی‌های سفارشی تعریف‌شده توسط برنامه باشند. می‌توانید اشتراک‌های سرویس اتوبوس را با موضوع مرتبط کنید، و اشتراک‌ها می‌توانند پیام‌ها را بر اساس ویژگی‌هایشان فیلتر کنند. هنگامی که یک برنامه کاربردی پیامی را به موضوعی ارسال می کند، پیام به اشتراک مناسب هدایت می شود، جایی که مصرف کننده می تواند آن را بخواند. فرآیندهای مصرف کننده می توانند پیام ها را از یک اشتراک با استفاده از همان معنایی که در صف پیام استفاده می کنند، بازیابی کنند. (اشتراک یک صف منطقی است.) این نمودار نحوه اجرای یک صف اولویت را با استفاده از موضوعات و اشتراک های سرویس اتوبوس نشان می دهد:

![[Pasted image 20231205113150.png]]

در نمودار قبلی، برنامه چندین پیام ایجاد می کند و یک ویژگی سفارشی به نام اولویت را در هر پیام اختصاص می دهد. اولویت دارای مقدار High یا Low است. برنامه این پیام ها را به یک موضوع ارسال می کند. موضوع دارای دو اشتراک مرتبط است که پیام ها را بر اساس ویژگی Priority فیلتر می کند. یک اشتراک پیام هایی را می پذیرد که ویژگی Priority روی High تنظیم شده است. دیگری پیام هایی را با ویژگی Priority روی Low می پذیرد. مجموعه ای از مصرف کنندگان پیام های هر اشتراک را می خوانند. اشتراک با اولویت بالا دارای یک استخر بزرگتر است و این مصرف کنندگان ممکن است روی رایانه های قدرتمندتری که منابع در دسترس بیشتری نسبت به رایانه های دارای اولویت پایین دارند، کار کنند.  
  
هیچ چیز خاصی در مورد تعیین پیام های با اولویت بالا و پایین در این مثال وجود ندارد. آنها صرفاً برچسب هایی هستند که در هر پیام به عنوان ویژگی مشخص می شوند. آنها برای هدایت پیام ها به یک اشتراک خاص استفاده می شوند. در صورت نیاز به اولویت‌های اضافی، ایجاد اشتراک‌ها و مجموعه‌های بیشتری از فرآیندهای مصرف‌کننده برای رسیدگی به این اولویت‌ها نسبتاً آسان است.  
  
راه حل PriorityQueue در GitHub بر اساس این رویکرد است. این راه حل شامل پروژه های Azure Function با نام های PriorityQueueConsumerHigh و PriorityQueueConsumerLow می باشد. این پروژه های Azure Function از طریق تریگرها و اتصالات با سرویس گذرگاه یکپارچه می شوند. آنها به اشتراک های مختلفی که در ServiceBusTrigger تعریف شده اند متصل می شوند و به پیام های دریافتی واکنش نشان می دهند.

```csharp
public static class PriorityQueueConsumerHighFn
{
    [FunctionName("HighPriorityQueueConsumerFunction")]
    public static void Run(
      [ServiceBusTrigger("messages", "highPriority", Connection = "ServiceBusConnection")]string highPriorityMessage,
      ILogger log)
    {
        log.LogInformation($"C# ServiceBus topic trigger function processed message: {highPriorityMessage}");
    }
}
```

به‌عنوان سرپرست، می‌توانید پیکربندی کنید که عملکردهای Azure App Service به چند نمونه می‌توانند مقیاس شوند. شما می توانید این کار را با پیکربندی گزینه Enforce Scale Out Limit از پورتال Azure انجام دهید و حداکثر محدودیت مقیاس را برای هر عملکرد تعیین کنید. شما معمولاً باید نمونه های بیشتری از تابع PriorityQueueConsumerHigh نسبت به تابع PriorityQueueConsumerLow داشته باشید. این پیکربندی تضمین می‌کند که پیام‌های با اولویت بالا سریع‌تر از پیام‌های با اولویت پایین خوانده می‌شوند.  
  
پروژه دیگری، PriorityQueueSender، حاوی یک تابع Azure با زمان راه اندازی است که برای اجرا هر 30 ثانیه پیکربندی شده است. این تابع از طریق اتصال خروجی با سرویس گذرگاه ادغام می شود و دسته ای از پیام های با اولویت پایین و بالا را به یک شی IAsyncCollector ارسال می کند. وقتی تابع پیام‌هایی را به موضوعی ارسال می‌کند که با اشتراک‌های استفاده شده توسط توابع PriorityQueueConsumerHigh و PriorityQueueConsumerLow مرتبط است، اولویت را با استفاده از ویژگی سفارشی Priority مشخص می‌کند، همانطور که در اینجا نشان داده شده است:

```csharp
public static class PriorityQueueSenderFn
{
    [FunctionName("PriorityQueueSenderFunction")]
    public static async Task Run(
        [TimerTrigger("0,30 * * * * *")] TimerInfo myTimer,
        [ServiceBus("messages", Connection = "ServiceBusConnection")] IAsyncCollector<ServiceBusMessage> collector)
    {
        for (int i = 0; i < 10; i++)
        {
            var messageId = Guid.NewGuid().ToString();
            var lpMessage = new ServiceBusMessage() { MessageId = messageId };
            lpMessage.ApplicationProperties["Priority"] = Priority.Low;
            lpMessage.Body = BinaryData.FromString($"Low priority message with Id: {messageId}");
            await collector.AddAsync(lpMessage);

            messageId = Guid.NewGuid().ToString();
            var hpMessage = new ServiceBusMessage() { MessageId = messageId };
            hpMessage.ApplicationProperties["Priority"] = Priority.High;
            hpMessage.Body = BinaryData.FromString($"High priority message with Id: {messageId}");
            await collector.AddAsync(hpMessage);
        }
    }
}
```

## Next steps

منابع زیر ممکن است هنگام اجرای این الگو برای شما مفید باشد:  
  
* نمونه ای که این الگو را در GitHub نشان می دهد.  
  
* آغازگر پیام رسانی ناهمزمان. یک سرویس مصرف کننده که یک درخواست را پردازش می کند، ممکن است نیاز به ارسال پاسخ به نمونه برنامه ای که درخواست را ارسال کرده است داشته باشد. این مقاله اطلاعاتی در مورد استراتژی هایی ارائه می دهد که می توانید برای اجرای پیام درخواست/پاسخ استفاده کنید.  
  
* راهنمای مقیاس خودکار. گاهی اوقات می‌توانید اندازه مجموعه فرآیندهای مصرف‌کننده‌ای را که یک صف را مدیریت می‌کنند، بر اساس طول صف تغییر دهید. این استراتژی می تواند به شما در بهبود عملکرد کمک کند، به خصوص برای استخرهایی که پیام های دارای اولویت بالا را مدیریت می کنند.

## Related resources

الگوهای زیر ممکن است هنگام اجرای این الگو برای شما مفید باشد:  
  
* الگوی مصرف کنندگان رقابتی برای افزایش توان عملیاتی صف ها، می توانید چندین مصرف کننده را پیاده سازی کنید که به یک صف گوش می دهند و وظایف را به صورت موازی پردازش می کنند. این مصرف کنندگان برای پیام ها با هم رقابت می کنند، اما فقط یک نفر باید بتواند هر پیام را پردازش کند. این مقاله اطلاعات بیشتری در مورد مزایا و معایب اجرای این روش ارائه می دهد.  
  
* الگوی دریچه گاز. شما می توانید throttling را با استفاده از صف اجرا کنید. می‌توانید از پیام‌های اولویت‌دار برای اطمینان از اینکه درخواست‌های برنامه‌های مهم یا برنامه‌هایی که توسط مشتریان با ارزش اجرا می‌شوند، نسبت به درخواست‌های برنامه‌های کمتر مهم اولویت دارند استفاده کنید.