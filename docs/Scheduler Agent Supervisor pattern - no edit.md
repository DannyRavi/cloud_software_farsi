مجموعه ای از اقدامات توزیع شده را به عنوان یک عملیات واحد هماهنگ کنید. اگر هر یک از اقدامات شکست خورد، سعی کنید شکست ها را به طور شفاف مدیریت کنید، یا در غیر این صورت کار انجام شده را لغو کنید، بنابراین کل عملیات به طور کلی با موفقیت یا شکست مواجه می شود. این می‌تواند انعطاف‌پذیری را به یک سیستم توزیع‌شده اضافه کند، و آن را قادر می‌سازد تا اقداماتی را که به دلیل استثناهای گذرا، خطاهای طولانی‌مدت و خرابی‌های فرآیند شکست می‌خورند، بازیابی و دوباره امتحان کند.

## Context and problem

یک برنامه کاربردی وظایفی را انجام می دهد که شامل تعدادی مرحله است که برخی از آنها ممکن است خدمات راه دور را فراخوانی کنند یا به منابع راه دور دسترسی پیدا کنند. گام‌های جداگانه ممکن است مستقل از یکدیگر باشند، اما توسط منطق برنامه‌ای که وظیفه را اجرا می‌کند، هماهنگ می‌شوند.  
  
در صورت امکان، برنامه باید اطمینان حاصل کند که کار تا پایان کامل می شود و هر گونه نقصی را که ممکن است هنگام دسترسی به خدمات یا منابع راه دور رخ دهد برطرف کند. شکست می تواند به دلایل زیادی رخ دهد. به عنوان مثال، ممکن است شبکه از کار افتاده باشد، ارتباطات ممکن است قطع شود، یک سرویس راه دور ممکن است پاسخگو نباشد یا در حالت ناپایدار باشد، یا یک منبع راه دور ممکن است به طور موقت غیرقابل دسترسی باشد، شاید به دلیل محدودیت منابع. در بسیاری از موارد خرابی ها گذرا هستند و با استفاده از الگوی Retry قابل کنترل هستند.  
  
اگر برنامه یک خطای دائمی تری را تشخیص دهد که نمی تواند به راحتی آن را بازیابی کند، باید بتواند سیستم را به حالت ثابت بازگرداند و از یکپارچگی کل عملیات اطمینان حاصل کند.

## Solution

الگوی Scheduler Agent Supervisor بازیگران زیر را تعریف می کند. این بازیگران مراحلی را که قرار است به عنوان بخشی از وظیفه کلی اجرا شوند هماهنگ می کنند.

* ئ Scheduler  مراحلی را که وظیفه را تشکیل می دهند ترتیب می دهد تا اجرا شوند و عملیات آنها را هماهنگ می کند. این مراحل را می توان در یک خط لوله یا گردش کار ترکیب کرد. Scheduler مسئول اطمینان از اینکه مراحل این گردش کار به ترتیب درست انجام شده است. همانطور که هر مرحله انجام می شود، Scheduler وضعیت گردش کار را ثبت می کند، مانند «گام هنوز شروع نشده است»، «گام در حال اجرا» یا «مرحله تکمیل شده است». اطلاعات وضعیت همچنین باید شامل حد بالایی از زمان مجاز برای اتمام مرحله باشد که به آن زمان تکمیل می‌گویند. اگر مرحله ای نیاز به دسترسی به یک سرویس یا منبع راه دور داشته باشد، Scheduler عامل مناسب را فراخوانی می کند و جزئیات کاری را که باید انجام شود به آن ارسال می کند. Scheduler معمولاً با استفاده از پیام‌های درخواست/پاسخ ناهمزمان با یک عامل ارتباط برقرار می‌کند. این را می توان با استفاده از صف ها پیاده سازی کرد، اگرچه می توان از سایر فناوری های پیام رسانی توزیع شده به جای آن استفاده کرد.  
  
* ئ Scheduler عملکردی مشابه Process Manager در الگوی Process Manager انجام می دهد. گردش کار واقعی معمولاً توسط یک موتور گردش کار که توسط Scheduler کنترل می شود، تعریف و اجرا می شود. این رویکرد منطق کسب و کار در گردش کار را از Scheduler جدا می کند.  
  
* ئ Agent حاوی منطقی است که یک تماس با یک سرویس راه دور یا دسترسی به یک منبع راه دور را که توسط یک مرحله در یک کار به آن ارجاع می شود، محصور می کند. هر Agent معمولاً تماس‌ها را به یک سرویس یا منبع منفرد می‌پیوندد و منطق مدیریت خطا و امتحان مجدد مناسب را پیاده‌سازی می‌کند (با توجه به محدودیت زمانی که بعداً توضیح داده شد). هنگام اجرای منطق تلاش مجدد، یک شناسه پایدار را در بین تمام تلاش‌های مجدد ارسال کنید تا سرویس راه دور بتواند از آن برای هر منطق حذف مجددی که ممکن است داشته باشد استفاده کند. اگر مراحل در گردش کار که توسط Scheduler اجرا می شود از چندین سرویس و منبع در مراحل مختلف استفاده می کنند، هر مرحله ممکن است به یک Agent متفاوت اشاره کند (این جزییات پیاده سازی الگو است).  
  
* ئ سرپرست وضعیت مراحل انجام وظیفه توسط زمانبند را نظارت می کند. به صورت دوره ای اجرا می شود (فرکانس مربوط به سیستم خواهد بود)، و وضعیت مراحل نگهداری شده توسط Scheduler را بررسی می کند. اگر مواردی را شناسایی کند که به پایان رسیده یا شکست خورده اند، ترتیبی می دهد که Agent مناسب مرحله را بازیابی کند یا اقدام اصلاحی مناسب را انجام دهد (این ممکن است شامل تغییر وضعیت یک مرحله باشد). توجه داشته باشید که اقدامات بازیابی یا اصلاحی توسط Scheduler و Agents اجرا می شود. سرپرست باید به سادگی درخواست کند که این اقدامات انجام شود.

Scheduler، Agent و Supervisor اجزای منطقی هستند و اجرای فیزیکی آنها به فناوری مورد استفاده بستگی دارد. به عنوان مثال، چندین عامل منطقی ممکن است به عنوان بخشی از یک وب سرویس واحد پیاده سازی شوند.  
  
Scheduler اطلاعات مربوط به پیشرفت کار و وضعیت هر مرحله را در یک انبار داده بادوام، به نام ذخیره‌گاه حالت، نگهداری می‌کند. سرپرست می تواند از این اطلاعات برای کمک به تعیین اینکه آیا یک مرحله شکست خورده است استفاده کند. شکل رابطه بین زمانبند، نمایندگان، سرپرست و فروشگاه دولتی را نشان می دهد.

![[Pasted image 20231205114553.png]]

```
توجه داشته باشید  
  
این نمودار یک نسخه ساده شده از الگو را نشان می دهد. در یک پیاده‌سازی واقعی، ممکن است نمونه‌های زیادی از زمان‌بندی که همزمان اجرا می‌شوند، وجود داشته باشد که هر کدام زیرمجموعه‌ای از وظایف هستند. به طور مشابه، سیستم می تواند چندین نمونه از هر عامل یا حتی چندین سرپرست را اجرا کند. در این مورد، سرپرستان باید کار خود را با دقت با یکدیگر هماهنگ کنند تا اطمینان حاصل کنند که برای بازیابی مراحل و وظایف ناموفق مشابه رقابت نمی کنند. الگوی انتخاب رهبر یک راه حل ممکن برای این مشکل ارائه می دهد.
```


هنگامی که برنامه برای اجرای یک کار آماده است، درخواستی را به Scheduler ارسال می کند. Scheduler اطلاعات وضعیت اولیه مربوط به کار و مراحل آن (مثلاً مرحله ای که هنوز شروع نشده است) را در ذخیره سازی وضعیت ثبت می کند و سپس شروع به انجام عملیات تعریف شده توسط گردش کار می کند. زمانی که Scheduler هر مرحله را شروع می‌کند، اطلاعات مربوط به وضعیت آن مرحله را در ذخیره‌سازی وضعیت به‌روزرسانی می‌کند (مثلاً مرحله اجرا).  
  
اگر مرحله ای به یک سرویس یا منبع راه دور اشاره کند، زمانبند پیامی را به نماینده مربوطه ارسال می کند. پیام حاوی اطلاعاتی است که عامل باید به سرویس منتقل کند یا به منبع دسترسی داشته باشد، علاوه بر زمان کامل عملیات. اگر Agent عملیات خود را با موفقیت انجام دهد، پاسخی را به Scheduler برمی گرداند. سپس Scheduler می‌تواند اطلاعات وضعیت را در ذخیره‌سازی وضعیت به‌روزرسانی کند (مثلاً مرحله تکمیل شده) و مرحله بعدی را انجام دهد. این روند تا زمانی که کل کار کامل شود ادامه می یابد.  
  
یک Agent می‌تواند هر منطقی را که برای انجام کارش لازم است، پیاده‌سازی کند. با این حال، اگر Agent کار خود را قبل از انقضای دوره کامل به پایان نرساند، زمان‌بندی‌کننده فرض می‌کند که عملیات شکست خورده است. در این حالت، Agent باید کار خود را متوقف کند و سعی نکند چیزی را به Scheduler بازگرداند (حتی یک پیام خطا) یا هر نوع بازیابی را امتحان کند. دلیل این محدودیت این است که، پس از اتمام زمان یا شکست یک مرحله، ممکن است نمونه دیگری از Agent برای اجرای مرحله شکست برنامه‌ریزی شود (این فرآیند در ادامه توضیح داده می‌شود).  
  
اگر Agent ناموفق باشد، زمانبند پاسخی دریافت نخواهد کرد. این الگو بین مرحله ای که به پایان رسیده و مرحله ای که واقعاً شکست خورده است، تمایزی قائل نمی شود.  
  
اگر یک مرحله به پایان برسد یا ناموفق باشد، ذخیره‌سازی حالت حاوی رکوردی است که نشان می‌دهد مرحله در حال اجرا است، اما زمان کامل به پایان رسیده است. Supervisor به دنبال چنین مراحلی می گردد و سعی می کند آنها را بازیابی کند. یکی از استراتژی‌های ممکن این است که Supervisor مقدار کامل توسط را به‌روزرسانی کند تا زمان در دسترس برای تکمیل مرحله را افزایش دهد و سپس پیامی را به Scheduler بفرستد که مرحله‌ای را که زمان آن تمام شده است را شناسایی کند. سپس Scheduler می تواند سعی کند این مرحله را تکرار کند. با این حال، این طراحی مستلزم آن است که وظایف ناتوان باشد. سیستم باید دارای زیرساخت برای حفظ ثبات باشد. برای اطلاعات بیشتر، زیرساخت‌های تکرارپذیر، برنامه‌های Architect Azure برای انعطاف‌پذیری و در دسترس بودن، و راهنمای تصمیم‌گیری سازگاری منابع را ببینید.  
  
ممکن است ناظر نیاز داشته باشد که در صورت عدم موفقیت یا اتمام مراحل مشابه، از تکرار مجدد آن جلوگیری کند. برای انجام این کار، سرپرست می‌تواند برای هر مرحله یک تعداد تلاش مجدد را به همراه اطلاعات وضعیت در ذخیره‌سازی حالت حفظ کند. اگر این تعداد از آستانه از پیش تعریف شده فراتر رود، سرپرست می‌تواند یک استراتژی انتظار برای مدت طولانی را پیش از اطلاع به زمان‌بند که باید مرحله را دوباره امتحان کند، اتخاذ کند، به این امید که خطا در این دوره برطرف شود. از طرف دیگر، سرپرست می‌تواند پیامی به زمان‌بند ارسال کند تا با اجرای یک الگوی تراکنش جبران‌کننده، تمام کار را لغو کند. این رویکرد بستگی به این دارد که برنامه‌ریز و عوامل اطلاعات لازم را برای اجرای عملیات جبران‌کننده برای هر مرحله که با موفقیت انجام شده است ارائه دهند.

> هدف سوپروایزر نظارت بر زمانبند و نمایندگان نیست و در صورت شکست آنها را مجددا راه اندازی می کند. این جنبه از سیستم باید توسط زیرساختی که این اجزا در آن اجرا می شوند مدیریت شود. به طور مشابه، سرپرست نباید از عملیات تجاری واقعی که وظایفی که توسط زمانبند انجام می شود (از جمله نحوه جبران در صورت شکست این وظایف) اطلاع نداشته باشد. ). این هدف منطق گردش کار پیاده سازی شده توسط Scheduler است. مسئولیت انحصاری سرپرست این است که تعیین کند آیا یک مرحله شکست خورده است و ترتیبی دهد که آن مرحله تکرار شود یا کل کار حاوی مرحله شکست خورده لغو شود.


اگر Scheduler پس از خرابی مجدداً راه اندازی شود، یا گردش کار در حال انجام توسط Scheduler به طور غیرمنتظره ای خاتمه یابد، زمانبند باید بتواند وضعیت هر وظیفه پروازی را که در هنگام شکست انجام می داد، تعیین کند و آماده باشد که این کار را از آن زمان از سر بگیرد. نقطه. جزئیات پیاده سازی این فرآیند احتمالاً مختص سیستم است. اگر کار قابل بازیابی نیست، ممکن است لازم باشد کاری که قبلاً توسط آن انجام شده است لغو شود. این ممکن است به اجرای یک تراکنش جبرانی نیز نیاز داشته باشد.  
  
مزیت کلیدی این الگو این است که سیستم در مواقع خرابی موقت یا غیرقابل جبران غیرمنتظره انعطاف پذیر است. این سیستم را می توان طوری ساخت که خود ترمیم کننده باشد. به عنوان مثال، اگر یک نماینده یا برنامه‌ریزی شکست بخورد، می‌توان کار جدیدی را شروع کرد و سرپرست می‌تواند ترتیبی دهد که یک کار از سر گرفته شود. اگر Supervisor شکست بخورد، نمونه دیگری را می توان شروع کرد و می تواند از جایی که خرابی رخ داده است، اداره شود. اگر برنامه ریزی شده است که Supervisor به صورت دوره ای اجرا شود، یک نمونه جدید می تواند به طور خودکار پس از یک بازه از پیش تعریف شده شروع شود. فروشگاه ایالتی را می توان برای دستیابی به درجه انعطاف پذیری بیشتر تکرار کرد.

## Issues and considerations

هنگام تصمیم گیری در مورد نحوه اجرای این الگو باید نکات زیر را در نظر بگیرید:  
  
* اجرای این الگو ممکن است دشوار باشد و نیاز به آزمایش کامل هر حالت خرابی احتمالی سیستم دارد.  
  
* منطق بازیابی/تلاش مجدد پیاده‌سازی شده توسط Scheduler پیچیده و وابسته به اطلاعات وضعیت موجود در ذخیره‌سازی حالت است. همچنین ممکن است لازم باشد اطلاعات مورد نیاز برای اجرای یک تراکنش جبرانی در یک فروشگاه داده بادوام ثبت شود.  
  
* اینکه ناظر چند وقت یکبار اجرا می شود مهم خواهد بود. باید به اندازه کافی اجرا شود تا مانع از مسدود شدن هر گونه گام ناموفق برنامه برای مدت طولانی شود، اما نباید آنقدر اجرا شود که تبدیل به سربار شود.  
  
* مراحل انجام شده توسط Agent را می توان بیش از یک بار اجرا کرد. منطقی که این مراحل را اجرا می کند باید ناتوان باشد.
## When to use this pattern

از این الگو زمانی استفاده کنید که فرآیندی که در یک محیط توزیع شده اجرا می شود، مانند ابر، باید در برابر خرابی ارتباطات و/یا شکست عملیاتی مقاوم باشد.  
  
این الگو ممکن است برای کارهایی که از خدمات راه دور استفاده نمی کنند یا به منابع راه دور دسترسی ندارند، مناسب نباشد.

## Example

یک برنامه وب که یک سیستم تجارت الکترونیک را پیاده سازی می کند در Microsoft Azure مستقر شده است. کاربران می توانند این اپلیکیشن را برای مرور محصولات موجود و ثبت سفارش اجرا کنند. رابط کاربری به عنوان یک نقش وب اجرا می شود و عناصر پردازش سفارش برنامه به عنوان مجموعه ای از نقش های کارگر پیاده سازی می شوند. بخشی از منطق پردازش سفارش شامل دسترسی به یک سرویس راه دور است و این جنبه از سیستم می تواند مستعد خطاهای گذرا یا طولانی مدت باشد. به همین دلیل، طراحان از الگوی Scheduler Agent Supervisor برای پیاده سازی عناصر پردازش سفارش سیستم استفاده کردند.  
  
هنگامی که یک مشتری سفارشی را ارسال می کند، برنامه پیامی می سازد که سفارش را توصیف می کند و این پیام را در یک صف ارسال می کند. یک فرآیند ارسال جداگانه که در نقش کارگر اجرا می‌شود، پیام را بازیابی می‌کند، جزئیات سفارش را در پایگاه داده سفارش‌ها درج می‌کند و یک رکورد برای فرآیند سفارش در فروشگاه دولتی ایجاد می‌کند. توجه داشته باشید که درج ها در پایگاه داده سفارشات و ذخیره سازی حالت به عنوان بخشی از همان عملیات انجام می شود. فرآیند ارسال به گونه ای طراحی شده است که اطمینان حاصل شود که هر دو درج با هم کامل می شوند.  
  
اطلاعات وضعیتی که فرآیند ارسال برای سفارش ایجاد می کند شامل:

* شماره سفارش. شناسه سفارش در پایگاه سفارشات.  
  
* LockedBy. شناسه نمونه نقش کارگری که سفارش را مدیریت می کند. ممکن است چندین نمونه فعلی از نقش کارگر در حال اجرای Scheduler وجود داشته باشد، اما هر سفارش فقط باید توسط یک نمونه مدیریت شود.  
  
* CompleteBy. زمانی که سفارش باید پردازش شود.  
  
* Process State. وضعیت فعلی وظیفه رسیدگی به سفارش. حالت های ممکن عبارتند از:  
  
	* انتظار. سفارش ایجاد شده است اما پردازش هنوز شروع نشده است.  
	* در حال پردازش. سفارش در حال حاضر در حال پردازش است.  
	* فرآوری شده. سفارش با موفقیت پردازش شد.  
	* خطا. پردازش سفارش ناموفق بود.  

* تعداد شکست. تعداد دفعاتی که پردازش برای سفارش انجام شده است.

در این اطلاعات وضعیت، قسمت OrderID از شناسه سفارش سفارش جدید کپی می شود. فیلدهای LockedBy و CompleteBy روی null، قسمت ProcessState روی Pending و فیلد FailureCount روی 0 تنظیم شده است.

```
توجه داشته باشید  
  
در این مثال، منطق رسیدگی به سفارش نسبتاً ساده است و فقط یک مرحله دارد که یک سرویس راه دور را فراخوانی می کند. در یک سناریوی چند مرحله‌ای پیچیده‌تر، فرآیند ارسال احتمالاً شامل چندین مرحله می‌شود، و بنابراین چندین رکورد در فروشگاه State ایجاد می‌شود - هر کدام وضعیت یک مرحله جداگانه را توصیف می‌کنند.
```


Scheduler همچنین به عنوان بخشی از نقش کارگر اجرا می شود و منطق تجاری که سفارش را مدیریت می کند، پیاده سازی می کند. نمونه‌ای از نظرسنجی Scheduler برای سفارش‌های جدید، ذخیره‌سازی حالت را برای سوابقی بررسی می‌کند که در آن فیلد LockedBy تهی است و قسمت ProcessState در انتظار است. هنگامی که Scheduler یک سفارش جدید پیدا می کند، بلافاصله فیلد LockedBy را با ID نمونه خود پر می کند، فیلد CompleteBy را روی زمان مناسب تنظیم می کند و قسمت ProcessState را روی پردازش تنظیم می کند. این کد به گونه ای طراحی شده است که انحصاری و اتمی باشد تا اطمینان حاصل شود که دو نمونه همزمان از Scheduler نمی توانند به طور همزمان یک سفارش را مدیریت کنند.  
  
سپس Scheduler گردش کار تجاری را اجرا می کند تا سفارش را به صورت ناهمزمان پردازش کند و مقدار آن را در قسمت OrderID از فروشگاه state ارسال می کند. گردش کاری که سفارش را مدیریت می کند، جزئیات سفارش را از پایگاه داده سفارشات بازیابی می کند و کار خود را انجام می دهد. هنگامی که مرحله ای در گردش کار پردازش سفارش نیاز به فراخوانی سرویس راه دور دارد، از یک Agent استفاده می کند. مرحله گردش کار با استفاده از یک جفت صف پیام Azure Service Bus که به عنوان کانال درخواست/پاسخ عمل می کنند، با عامل ارتباط برقرار می کند. شکل یک نمای سطح بالا از راه حل را نشان می دهد.

![[Pasted image 20231205120735.png]]

پیامی که از یک مرحله گردش کار به نماینده ارسال می‌شود، سفارش را توصیف می‌کند و شامل زمان کامل می‌شود. اگر Agent قبل از انقضای زمان کامل، پاسخی از سرویس راه دور دریافت کند، یک پیام پاسخ را در صف سرویس اتوبوس که جریان کار در حال گوش دادن است، ارسال می کند. هنگامی که مرحله گردش کار پیام پاسخ معتبر را دریافت می کند، پردازش خود را کامل می کند و Scheduler فیلد ProcessState وضعیت سفارش را روی پردازش شده تنظیم می کند. در این مرحله، پردازش سفارش با موفقیت به پایان رسید.  
  
اگر قبل از اینکه نماینده پاسخی از سرویس راه دور دریافت کند، زمان تکمیل به پایان برسد، نماینده به سادگی پردازش آن را متوقف می کند و رسیدگی به سفارش را خاتمه می دهد. به طور مشابه، اگر گردش کار رسیدگی به سفارش از زمان تکمیل سفارش بیشتر شود، آن نیز خاتمه می یابد. در هر دو حالت، وضعیت سفارش در فروشگاه ایالتی همچنان روی پردازش تنظیم شده است، اما زمان تکمیل نشان می‌دهد که زمان پردازش سفارش گذشته است و فرآیند ناموفق تلقی می‌شود. توجه داشته باشید که اگر عاملی که به سرویس راه دور دسترسی دارد، یا گردش کاری که سفارش را مدیریت می کند (یا هر دو) به طور غیرمنتظره ای خاتمه یابد، اطلاعات موجود در فروشگاه ایالتی دوباره روی پردازش تنظیم شده باقی می ماند و در نهایت دارای یک مقدار کامل منقضی شده خواهد بود.  
  
اگر Agent در حین تماس با سرویس راه دور، خطای غیرقابل جبران و غیر گذرا را شناسایی کند، می‌تواند یک پاسخ خطا را به گردش کار ارسال کند. Scheduler می تواند وضعیت سفارش را به صورت خطا تنظیم کند و رویدادی را مطرح کند که به اپراتور هشدار می دهد. سپس اپراتور می تواند سعی کند دلیل خرابی را به صورت دستی حل کند و مرحله پردازش ناموفق را دوباره ارسال کند.  
  
ناظر به صورت دوره ای فروشگاه ایالتی را بررسی می کند و به دنبال سفارش هایی با ارزش تمام شده منقضی شده است. اگر Supervisor رکوردی را پیدا کند، فیلد FailureCount را افزایش می‌دهد. اگر مقدار شمارش خرابی کمتر از مقدار آستانه مشخص شده باشد، Supervisor فیلد LockedBy را به null بازنشانی می‌کند، فیلد CompleteBy را با یک زمان انقضا جدید به‌روزرسانی می‌کند و فیلد ProcessState را در حالت انتظار تنظیم می‌کند. یک نمونه از Scheduler می تواند این سفارش را دریافت کند و پردازش آن را مانند قبل انجام دهد. اگر مقدار تعداد خرابی از یک آستانه مشخص فراتر رود، دلیل شکست غیر گذرا فرض می شود. Supervisor وضعیت سفارش را روی خطا تنظیم می کند و رویدادی را مطرح می کند که به اپراتور هشدار می دهد.

> در این مثال، Supervisor در یک نقش کارگر مجزا پیاده سازی شده است. می‌توانید از استراتژی‌های مختلفی برای ترتیب دادن اجرای کار Supervisor استفاده کنید، از جمله استفاده از سرویس Azure Scheduler (در این الگو نباید با مؤلفه Scheduler اشتباه گرفته شود). برای اطلاعات بیشتر در مورد سرویس Azure Scheduler، به صفحه Scheduler مراجعه کنید.

اگرچه در این مثال نشان داده نشده است، ممکن است زمان‌بندی‌کننده نیاز داشته باشد برنامه‌ای را که سفارش را ارسال کرده است، در مورد پیشرفت و وضعیت سفارش مطلع کند. برنامه و Scheduler از یکدیگر جدا می شوند تا هر گونه وابستگی بین آنها حذف شود. برنامه هیچ اطلاعی از این که کدام نمونه از زمان‌بند سفارش را مدیریت می‌کند، ندارد و برنامه‌ریز از کدام نمونه برنامه خاص سفارش را پست کرده است.  
  
برای اجازه دادن به گزارش وضعیت سفارش، برنامه می تواند از صف پاسخ خصوصی خود استفاده کند. جزئیات این صف پاسخ به عنوان بخشی از درخواست ارسال شده به فرآیند ارسال، که شامل این اطلاعات در فروشگاه ایالتی می شود، گنجانده می شود. سپس برنامه‌ریز پیام‌هایی را به این صف ارسال می‌کند که وضعیت سفارش را نشان می‌دهد (درخواست دریافت، سفارش تکمیل شده، سفارش ناموفق است و غیره). باید شناسه سفارش را در این پیام‌ها لحاظ کند تا بتوان آنها را با درخواست اصلی برنامه مرتبط کرد.

## Next steps

راهنمایی زیر ممکن است هنگام اجرای این الگو نیز مرتبط باشد:  
  
* آغازگر پیام رسانی ناهمزمان. اجزای موجود در الگوی Scheduler Agent Supervisor معمولاً جدا از یکدیگر اجرا می شوند و به صورت ناهمزمان ارتباط برقرار می کنند. برخی از رویکردهایی را که می‌توان برای پیاده‌سازی ارتباطات ناهمزمان بر اساس صف‌های پیام استفاده کرد، توضیح می‌دهد.  
  
* مرجع 6: حماسه ای در مورد حماسه ها. مثالی که نشان می دهد چگونه الگوی CQRS از یک مدیر فرآیند استفاده می کند (بخشی از راهنمای سفر CQRS).  
  
Microsoft Azure Scheduler

## Related resources

الگوهای زیر نیز ممکن است هنگام اجرای این الگو مرتبط باشند:  
  
* الگو را دوباره امتحان کنید. یک Agent می تواند از این الگو برای آزمایش مجدد شفاف عملیاتی استفاده کند که به یک سرویس یا منبع راه دور دسترسی پیدا می کند که قبلاً شکست خورده است. زمانی استفاده کنید که انتظار می رود علت شکست زودگذر باشد و قابل اصلاح باشد.  
  
* الگوی مدار شکن. یک Agent می تواند از این الگو برای رسیدگی به خطاهایی استفاده کند که تصحیح آنها زمان متغیری در هنگام اتصال به یک سرویس یا منبع راه دور نیاز دارد.  
  
* الگوی تراکنش جبرانی اگر گردش کاری که توسط یک زمانبند انجام می شود نتواند با موفقیت تکمیل شود، ممکن است لازم باشد هر کاری که قبلا انجام شده است لغو شود. الگوی تراکنش جبرانی توضیح می دهد که چگونه می توان به این امر برای عملیاتی که از مدل سازگاری نهایی پیروی می کند، دست یافت. این نوع عملیات معمولاً توسط یک Scheduler اجرا می شود که فرآیندها و گردش های کاری پیچیده را انجام می دهد.  
  
* الگوی انتخاب رهبر ممکن است لازم باشد اقدامات چندین نمونه از یک سرپرست هماهنگ شود تا از تلاش آنها برای بازیابی همان فرآیند ناموفق جلوگیری شود. الگوی انتخاب رهبر نحوه انجام این کار را توضیح می دهد.  
  
Cloud Architecture: The Scheduler-Agent-Supervisor الگوی در وبلاگ Clemens Vasters  
  
الگوی مدیر فرآیند