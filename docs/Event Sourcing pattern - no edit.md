به جای ذخیره فقط وضعیت فعلی داده ها در یک دامنه، از یک فروشگاه فقط ضمیمه برای ثبت مجموعه کامل اقدامات انجام شده روی آن داده استفاده کنید. فروشگاه به عنوان سیستم رکورد عمل می کند و می تواند برای تحقق اشیاء دامنه استفاده شود. این می‌تواند وظایف را در حوزه‌های پیچیده، با اجتناب از نیاز به همگام‌سازی مدل داده و حوزه کسب‌وکار، ساده‌سازی کند، در حالی که عملکرد، مقیاس‌پذیری و پاسخ‌دهی را بهبود می‌بخشد. همچنین می‌تواند یکپارچگی برای داده‌های تراکنش فراهم کند و مسیرهای حسابرسی و سابقه کامل را حفظ کند که می‌تواند اقدامات جبران‌کننده را فعال کند.

## Context and problem

بیشتر برنامه ها با داده ها کار می کنند و رویکرد معمولی این است که برنامه با به روزرسانی آن به عنوان کاربران با آن ، وضعیت فعلی داده ها را حفظ کند. به عنوان مثال ، در مدل سنتی ایجاد ، خواندن ، به روزرسانی و حذف (CRUD) یک فرآیند داده معمولی خواندن داده ها از فروشگاه ، ایجاد برخی از اصلاحات در آن و به روزرسانی وضعیت فعلی داده ها با مقادیر جدید است - با استفاده از معاملات که داده ها را قفل می کنند.  
  
رویکرد CRUD محدودیت هایی دارد:

* سیستم‌های CRUD عملیات به‌روزرسانی را مستقیماً در مقابل یک فروشگاه داده انجام می‌دهند. این عملیات می تواند عملکرد و پاسخگویی را کاهش دهد و به دلیل سربار پردازشی که نیاز دارد، مقیاس پذیری را محدود کند.  
  
* در یک دامنه مشترک با بسیاری از کاربران همزمان، تداخل به‌روزرسانی داده‌ها بیشتر محتمل است زیرا عملیات به‌روزرسانی روی یک مورد از داده‌ها انجام می‌شود.  
  
* مگر اینکه مکانیزم حسابرسی دیگری وجود داشته باشد که جزئیات هر عملیات را در یک گزارش جداگانه ثبت کند، تاریخچه از بین می رود.

## Solution

الگوی منبع یابی رویداد رویکردی را برای مدیریت عملیات روی داده ها تعریف می کند که توسط یک توالی از رویدادها هدایت می شود که هر یک از آنها فقط در یک فروشگاه ضمیمه ثبت می شوند. کد برنامه مجموعه‌ای از رویدادها را ارسال می‌کند که به طور ضروری هر عملی را که روی داده‌ها رخ داده است، به فروشگاه رویداد می‌فرستد، جایی که آنها ادامه دارند. هر رویداد نشان دهنده مجموعه ای از تغییرات در داده ها است (مانند AddedItemToOrder).

رویدادها در یک فروشگاه رویداد که به عنوان سیستم ثبت (منبع معتبر داده) در مورد وضعیت فعلی داده ها عمل می کند، باقی می مانند. فروشگاه رویداد معمولاً این رویدادها را منتشر می کند تا مصرف کنندگان بتوانند از آن مطلع شوند و در صورت نیاز بتوانند به آنها رسیدگی کنند. برای مثال، مصرف‌کنندگان می‌توانند وظایفی را آغاز کنند که عملیات‌های رویدادها را در سیستم‌های دیگر اعمال می‌کند، یا هر اقدام مرتبط دیگری را که برای تکمیل عملیات لازم است انجام دهند. توجه داشته باشید که کد برنامه ای که رویدادها را تولید می کند از سیستم هایی که در رویدادها مشترک هستند جدا شده است.

استفاده معمولی از رویدادهای منتشر شده توسط فروشگاه رویداد برای حفظ نماهای واقعی از موجودیت ها در حالی که اقدامات در برنامه آنها را تغییر می دهد و برای ادغام با سیستم های خارجی است. برای مثال، یک سیستم می‌تواند یک نمای مادی از تمام سفارش‌های مشتری که برای پر کردن بخش‌هایی از UI استفاده می‌شود، حفظ کند. این برنامه سفارشات جدید را اضافه می کند، موارد سفارش را اضافه یا حذف می کند و اطلاعات حمل و نقل را اضافه می کند. رویدادهایی که این تغییرات را توصیف می‌کنند، می‌توانند برای به‌روزرسانی نمای تحقق‌یافته مدیریت و استفاده شوند.

در هر نقطه، این امکان برای برنامه‌ها وجود دارد که تاریخچه رویدادها را بخوانند. سپس می توانید از آن برای تحقق وضعیت فعلی یک موجودیت با پخش و مصرف تمام رویدادهای مربوط به آن موجودیت استفاده کنید. این فرآیند می تواند در صورت تقاضا برای تحقق یک شی دامنه در هنگام رسیدگی به یک درخواست رخ دهد. یا، این فرآیند از طریق یک کار زمان‌بندی شده اتفاق می‌افتد، به طوری که وضعیت موجودیت می‌تواند به‌عنوان یک نمای مادی‌شده ذخیره شود تا از لایه ارائه پشتیبانی کند.

شکل یک نمای کلی از الگو را نشان می‌دهد، از جمله برخی از گزینه‌های استفاده از جریان رویداد مانند ایجاد نمای واقعی، ادغام رویدادها با برنامه‌ها و سیستم‌های خارجی، و پخش مجدد رویدادها برای ایجاد پیش‌بینی وضعیت فعلی موجودیت‌های خاص.


![[Pasted image 20231201231623.png]]

الگوی منبع یابی رویداد مزایای زیر را ارائه می دهد:


* رویدادها تغییر ناپذیر هستند و می‌توانند با استفاده از یک عملیات فقط پیوست ذخیره شوند. رابط کاربری، گردش کار یا فرآیندی که یک رویداد را آغاز کرده است می‌تواند ادامه یابد و کارهایی که رویدادها را مدیریت می‌کنند می‌توانند در پس‌زمینه اجرا شوند. این فرآیند، همراه با این واقعیت که در طول پردازش تراکنش‌ها هیچ مناقشه‌ای وجود ندارد، می‌تواند عملکرد و مقیاس‌پذیری برنامه‌ها را به‌ویژه برای سطح ارائه یا رابط کاربری بسیار بهبود بخشد.

* رویدادها اشیاء ساده ای هستند که برخی از اقدامات انجام شده را به همراه هر داده مرتبطی که برای توصیف عمل نمایش داده شده توسط رویداد مورد نیاز است، توصیف می کنند. رویدادها مستقیماً یک فروشگاه داده را به روز نمی کنند. آنها به سادگی برای جابجایی در زمان مناسب ثبت می شوند. استفاده از رویدادها می تواند پیاده سازی و مدیریت را ساده کند.

* رویدادها معمولاً برای متخصص دامنه معنی دارند، در حالی که عدم تطابق امپدانس شی - رابطه می تواند جداول پایگاه داده پیچیده را به سختی درک کند. جداول ساختارهای مصنوعی هستند که وضعیت فعلی سیستم را نشان می دهند، نه رویدادهایی که رخ داده اند.

* منبع‌یابی رویداد می‌تواند به جلوگیری از ایجاد تداخل به‌روزرسانی‌های همزمان کمک کند، زیرا از نیاز به به‌روزرسانی مستقیم اشیاء در فروشگاه داده جلوگیری می‌کند. با این حال، مدل دامنه همچنان باید به گونه‌ای طراحی شود که از خود در برابر درخواست‌هایی که ممکن است منجر به وضعیت ناسازگار شود، محافظت کند.

* ذخیره‌سازی ضمیمه رویدادها یک مسیر حسابرسی را فراهم می‌کند که می‌توان از آن برای نظارت بر اقدامات انجام شده علیه یک ذخیره‌سازی داده استفاده کرد. می‌تواند با پخش مجدد رویدادها در هر زمان، وضعیت فعلی را به‌عنوان نماها یا پیش‌بینی‌های تحقق‌یافته بازسازی کند و می‌تواند به آزمایش و اشکال‌زدایی سیستم کمک کند. علاوه بر این، الزام به استفاده از رویدادهای جبران‌کننده برای لغو تغییرات می‌تواند تاریخچه‌ای از تغییراتی را ارائه دهد که معکوس شده‌اند. اگر مدل حالت فعلی را ذخیره می کرد، این قابلیت وجود نداشت. لیست رویدادها همچنین می تواند برای تجزیه و تحلیل عملکرد برنامه و تشخیص روندهای رفتار کاربر استفاده شود. یا می توان از آن برای به دست آوردن اطلاعات مفید تجاری دیگر استفاده کرد.

* فروشگاه رویداد رویدادها را افزایش می دهد و وظایف در پاسخ به آن رویدادها عملیات انجام می دهند. این جداسازی وظایف از رویدادها، انعطاف پذیری و گسترش را فراهم می کند. Tasks در مورد نوع رویداد و داده های رویداد می دانند، اما در مورد عملیاتی که رویداد را آغاز کرده است، اطلاع ندارند. علاوه بر این، چندین کار می تواند هر رویداد را مدیریت کند. این امکان ادغام آسان با سایر سرویس ها و سیستم هایی را فراهم می کند که فقط به رویدادهای جدید مطرح شده توسط فروشگاه رویداد گوش می دهند. با این حال، رویدادهای منبع یابی رویداد معمولا سطح بسیار پایینی دارند، و ممکن است لازم باشد به جای آن رویدادهای یکپارچه سازی خاصی ایجاد شود.

>منبع یابی رویداد معمولا با الگوی CQRS با انجام وظایف مدیریت داده در پاسخ به رویدادها و با تحقق نماها از رویدادهای ذخیره شده ترکیب می شود.


--------------
p1
--------------

## Issues and considerations

هنگام تصمیم گیری در مورد نحوه اجرای این الگو به نکات زیر توجه کنید:  
  
این سیستم در نهایت تنها در هنگام ایجاد نماهای تحقق یافته یا تولید پیش بینی داده ها با پخش مجدد رویدادها سازگار خواهد بود. بین افزودن رویدادها به فروشگاه رویداد در نتیجه رسیدگی به درخواست، رویدادهای منتشر شده و مصرف کنندگان رویدادها که آنها را مدیریت می کنند، مقداری تأخیر وجود دارد. در طول این دوره، رویدادهای جدیدی که تغییرات بیشتر در نهادها را توصیف می‌کنند ممکن است به فروشگاه رویداد رسیده باشند. این سیستم باید به گونه ای طراحی شود که سازگاری نهایی در این سناریوها را در نظر بگیرد.

```
توجه داشته باشید  
  
برای اطلاعات در مورد سازگاری نهایی به پرایمر سازگاری داده مراجعه کنید.
```


فروشگاه رویداد منبع دائمی اطلاعات است و بنابراین داده های رویداد هرگز نباید به روز شوند. تنها راه برای به‌روزرسانی یک موجودیت برای لغو تغییر، افزودن یک رویداد جبران‌کننده به فروشگاه رویداد است. اگر قالب (به‌جای داده‌ها) رویدادهای پایدار نیاز به تغییر داشته باشد، شاید در طول مهاجرت، ترکیب رویدادهای موجود در فروشگاه با نسخه جدید دشوار باشد. ممکن است لازم باشد همه رویدادهایی که تغییرات ایجاد می‌کنند تکرار شوند تا با قالب جدید مطابقت داشته باشند، یا رویدادهای جدیدی اضافه کنید که از قالب جدید استفاده می‌کنند. برای حفظ هر دو قالب رویداد قدیمی و جدید، از یک مهر نسخه در هر نسخه از طرح رویداد استفاده کنید.

برنامه های چند رشته ای و چند نمونه از برنامه ها ممکن است رویدادها را در فروشگاه رویداد ذخیره کنند. سازگاری رویدادها در فروشگاه رویداد حیاتی است، مانند ترتیب رویدادهایی که بر یک موجودیت خاص تأثیر می‌گذارند (ترتیبی که تغییرات روی یک موجودیت رخ می‌دهد بر وضعیت فعلی آن تأثیر می‌گذارد). افزودن مهر زمانی به هر رویداد می تواند به جلوگیری از مشکلات کمک کند. یکی دیگر از روش های رایج، حاشیه نویسی هر رویداد ناشی از یک درخواست با یک شناسه افزایشی است. اگر دو اقدام برای افزودن رویدادها برای یک موجودیت به طور همزمان تلاش کنند، فروشگاه رویداد می‌تواند رویدادی را که با شناسه موجود موجود و شناسه رویداد مطابقت دارد رد کند.  
  
هیچ رویکرد استاندارد یا مکانیزم های موجود مانند پرس و جوهای SQL برای خواندن رویدادها برای به دست آوردن اطلاعات وجود ندارد. تنها داده ای که می توان استخراج کرد، جریانی از رویدادها با استفاده از یک شناسه رویداد به عنوان معیار است. شناسه رویداد معمولاً به نهادهای جداگانه نگاشت می شود. وضعیت فعلی یک موجودیت را می توان تنها با پخش مجدد همه رویدادهایی که به آن مربوط می شود در برابر وضعیت اصلی آن موجودیت تعیین کرد.

طول هر جریان رویداد بر مدیریت و به‌روزرسانی سیستم تأثیر می‌گذارد. اگر جریان‌ها بزرگ هستند، در فواصل زمانی خاص مانند تعداد مشخصی از رویدادها، عکس‌های فوری ایجاد کنید. وضعیت فعلی موجودیت را می توان از عکس فوری و با پخش مجدد هر رویدادی که پس از آن نقطه از زمان رخ داده است به دست آورد. برای اطلاعات بیشتر در مورد ایجاد عکس های فوری از داده ها، به تکرار عکس فوری اولیه-فرعی مراجعه کنید.  
  
حتی اگر منبع رویداد شانس به‌روزرسانی‌های متناقض داده‌ها را به حداقل می‌رساند، برنامه همچنان باید بتواند با ناهماهنگی‌هایی که از ثبات نهایی و فقدان تراکنش‌ها ناشی می‌شود، مقابله کند. به عنوان مثال، رویدادی که نشان‌دهنده کاهش موجودی موجودی است ممکن است در حین ثبت سفارش برای آن کالا به فروشگاه داده برسد. این وضعیت منجر به نیاز به تطبیق این دو عملیات، یا از طریق مشاوره به مشتری یا ایجاد یک سفارش برگشتی می‌شود.  
  
انتشار رویداد ممکن است حداقل یک بار باشد، بنابراین مصرف کنندگان رویدادها باید ناتوان باشند. اگر رویداد بیش از یک بار مدیریت شود، آنها نباید به روز رسانی شرح داده شده در یک رویداد را دوباره اعمال کنند. چندین نمونه از یک مصرف کننده می تواند دارایی یک واحد تجاری را حفظ و جمع کند، مانند تعداد کل سفارش های انجام شده. فقط یک نفر باید در افزایش مجموع، زمانی که یک رویداد سفارشی رخ می دهد، موفق شود. در حالی که این نتیجه یک مشخصه کلیدی منبع یابی رویداد نیست، تصمیم اجرای معمول است.  
  
فضای ذخیره رویداد انتخاب شده باید از بار رویداد ایجاد شده توسط برنامه شما پشتیبانی کند.  
مراقب سناریوهایی باشید که در آن پردازش یک رویداد شامل ایجاد یک یا چند رویداد جدید می شود زیرا این امر می تواند باعث ایجاد یک حلقه بی نهایت شود.

###  When to use this pattern

از این الگو در سناریوهای زیر استفاده کنید:  
  
* زمانی که می خواهید قصد، هدف یا دلیل را در داده ها ثبت کنید. به عنوان مثال، تغییرات یک موجودیت مشتری را می توان به عنوان یک سری از انواع رویدادهای خاص، مانند خانه منتقل شده، حساب بسته، یا متوفی ثبت کرد.  
  
* زمانی که به حداقل رساندن یا کاملاً اجتناب از بروز به روز رسانی متناقض داده ها حیاتی است.  
  
* هنگامی که می خواهید رویدادهایی را که رخ می دهند ضبط کنید، آنها را دوباره پخش کنید تا وضعیت یک سیستم بازیابی شود، تغییرات را به عقب برگردانید، یا سابقه و گزارش حسابرسی را نگه دارید. به عنوان مثال، هنگامی که یک کار شامل چندین مرحله است، ممکن است لازم باشد اقداماتی را برای بازگرداندن به‌روزرسانی‌ها انجام دهید و سپس برخی از مراحل را مجدداً پخش کنید تا داده‌ها به حالت ثابت بازگردند.  
  
* وقتی از رویدادها استفاده می کنید. این یک ویژگی طبیعی عملکرد برنامه است و به توسعه یا تلاش اضافی کمی نیاز دارد.  
  
* زمانی که نیاز دارید فرآیند ورودی یا به‌روزرسانی داده‌ها را از وظایف مورد نیاز برای اعمال این اقدامات جدا کنید. این تغییر ممکن است برای بهبود عملکرد رابط کاربری یا توزیع رویدادها به سایر شنوندگانی باشد که هنگام وقوع رویدادها اقدامی انجام می دهند. به عنوان مثال، می توانید یک سیستم حقوق و دستمزد را با یک وب سایت ارسال هزینه ها ادغام کنید. رویدادهایی که توسط فروشگاه رویداد در پاسخ به به روز رسانی داده های ایجاد شده در وب سایت مطرح می شود، هم توسط وب سایت و هم سیستم حقوق و دستمزد مصرف می شود.  
  
* هنگامی که می‌خواهید انعطاف‌پذیری را داشته باشید تا بتوانید قالب مدل‌های تحقق‌یافته و داده‌های موجود را در صورت تغییر نیازمندی‌ها تغییر دهید، یا - وقتی با CQRS استفاده می‌شود - باید یک مدل خوانده شده یا نماهایی را که داده‌ها را نشان می‌دهند تطبیق دهید.  
  
* هنگامی که با CQRS استفاده می شود، سازگاری نهایی قابل قبول است در حالی که یک مدل خوانده شده به روز می شود، یا تأثیر عملکرد موجودات و داده های آبرسانی مجدد از یک جریان رویداد قابل قبول است.


این الگو ممکن است در شرایط زیر مفید نباشد:  
  
* دامنه‌های کوچک یا ساده، سیستم‌هایی که منطق تجاری کمی دارند یا اصلاً منطقی ندارند، یا سیستم‌های غیردامنه‌ای که طبیعتاً با مکانیزم‌های مدیریت داده‌های سنتی CRUD به خوبی کار می‌کنند.  
  
* سیستم‌هایی که در آنها به‌روزرسانی‌های بی‌درنگ و سازگاری برای نماهای داده‌ها مورد نیاز است.  
  
* سیستم‌هایی که در آن مسیرهای حسابرسی، سابقه و قابلیت‌هایی برای بازگرداندن و پخش مجدد اقدامات لازم نیست.  
  
* سیستم‌هایی که در آن‌ها فقط به‌روزرسانی متناقض داده‌های زیربنایی کم است. به عنوان مثال، سیستم هایی که عمدتاً داده ها را به جای به روز رسانی اضافه می کنند.

------------
p2
----------------

## Example

یک سیستم مدیریت کنفرانس نیاز به ردیابی تعداد رزروهای تکمیل شده برای یک کنفرانس دارد. به این ترتیب وقتی یک شرکت کننده بالقوه سعی می کند رزرو کند، می تواند بررسی کند که آیا هنوز صندلی در دسترس است یا خیر. این سیستم می تواند تعداد کل رزروهای یک کنفرانس را حداقل به دو روش ذخیره کند:

* این سیستم می تواند اطلاعات مربوط به تعداد کل رزروها را به عنوان یک نهاد جداگانه در پایگاه داده ای که اطلاعات رزرو را در خود نگه می دارد، ذخیره کند. همانطور که رزرو انجام می شود یا لغو می شود، سیستم می تواند این تعداد را در صورت لزوم افزایش یا کاهش دهد. این رویکرد از نظر تئوری ساده است، اما اگر تعداد زیادی از شرکت‌کنندگان در تلاش برای رزرو صندلی در مدت زمان کوتاهی باشند، می‌تواند باعث مشکلات مقیاس‌پذیری شود. به عنوان مثال، در آخرین روز یا بیشتر قبل از بسته شدن دوره رزرو.  
  
* این سیستم می تواند اطلاعات مربوط به رزرو و لغو را به عنوان رویدادهایی که در فروشگاه رویداد برگزار می شود ذخیره کند. سپس می‌تواند تعداد صندلی‌های موجود را با پخش مجدد این رویدادها محاسبه کند. این رویکرد به دلیل تغییر ناپذیری رویدادها می تواند مقیاس پذیرتر باشد. سیستم فقط باید بتواند داده ها را از فروشگاه رویداد بخواند یا داده ها را به فروشگاه رویداد اضافه کند. اطلاعات رویداد در مورد رزرو و لغو هرگز اصلاح نمی شود.


نمودار زیر نشان می دهد که چگونه می توان زیرسیستم رزرو صندلی سیستم مدیریت کنفرانس را با استفاده از منبع رویداد پیاده سازی کرد.

![[Pasted image 20231201232220.png]]

ترتیب اقدامات برای رزرو دو صندلی به شرح زیر است:

1- رابط کاربری دستور رزرو صندلی برای دو شرکت کننده را صادر می کند. فرمان توسط یک کنترل کننده فرمان جداگانه مدیریت می شود. بخشی از منطق که از رابط کاربری جدا شده و مسئول رسیدگی به درخواست های ارسال شده به عنوان دستورات است.  
  
2- مجموعه ای حاوی اطلاعات مربوط به تمام رزروهای کنفرانس با پرس و جو از رویدادهایی که رزروها و لغوها را توصیف می کنند ساخته می شود. این مجموعه SeatAvailability نامیده می شود و در یک مدل دامنه قرار می گیرد که روش هایی را برای پرس و جو و اصلاح داده ها در مجموعه نشان می دهد.

> برخی از بهینه‌سازی‌هایی که باید در نظر گرفته شوند، استفاده از عکس‌های فوری (به‌طوری که نیازی به پرس‌وجو و پخش مجدد فهرست کامل رویدادها برای به دست آوردن وضعیت فعلی مجموع نباشید)، و نگهداری یک کپی ذخیره‌شده از مجموع در حافظه است.


3- کنترل کننده فرمان روشی را فراخوانی می کند که توسط مدل دامنه نمایش داده شده است تا رزروها را انجام دهد.  
  
4- مجموع SeatAvailability رویدادی را ثبت می‌کند که شامل تعداد صندلی‌های رزرو شده است. دفعه بعد که مجموع رویدادها را اعمال می کند، از همه رزروها برای محاسبه تعداد صندلی های باقی مانده استفاده می شود.  
  
5- سیستم رویداد جدید را به لیست رویدادهای فروشگاه رویداد اضافه می کند.

اگر کاربر یک صندلی را لغو کند، سیستم فرآیند مشابهی را دنبال می‌کند به جز اینکه کنترل‌کننده فرمان فرمانی را صادر می‌کند که یک رویداد لغو صندلی ایجاد می‌کند و آن را به فروشگاه رویداد اضافه می‌کند.  
  
استفاده از فروشگاه رویداد علاوه بر فراهم کردن زمینه بیشتر برای مقیاس پذیری، تاریخچه کامل یا دنباله حسابرسی از رزروها و لغوهای یک کنفرانس را نیز ارائه می دهد. رویدادهای فروشگاه رویداد رکورد دقیق است. نیازی به تداوم انباشته ها به روش دیگری نیست زیرا سیستم می تواند به راحتی رویدادها را دوباره پخش کند و وضعیت را به هر نقطه از زمان بازگرداند.

> اطلاعات بیشتر در مورد این مثال را می توانید در معرفی رویداد منبع یابی بیابید.

## Next steps


* عدم تطابق امپدانس شی - رابطه ای  
  
* پرایمر سازگاری داده هنگامی که از منبع یابی رویداد با یک فروشگاه خواندنی جداگانه یا نماهای واقعی استفاده می کنید، داده های خوانده شده فوراً سازگار نیستند. در عوض، داده‌ها فقط در نهایت سازگار خواهند بود. این مقاله مسائل مربوط به حفظ ثبات در داده های توزیع شده را خلاصه می کند.  
  
* راهنمای پارتیشن بندی داده ها هنگامی که از منبع رویداد برای بهبود مقیاس پذیری، کاهش مشاجره و بهینه سازی عملکرد استفاده می کنید، اغلب داده ها تقسیم بندی می شوند. این مقاله نحوه تقسیم داده ها به پارتیشن های مجزا و مسائلی که ممکن است ایجاد شود را شرح می دهد.  
  
وبلاگ مارتین فاولر:  
  
* منبع یابی رویداد  
* عکس فوری در وب سایت معماری برنامه های کاربردی شرکت مارتین فاولر

## Related resources

* الگوی تفکیک مسئولیت فرمان و پرس و جو (CQRS). فروشگاه نوشتن که منبع دائمی اطلاعات را برای پیاده سازی CQRS فراهم می کند، اغلب مبتنی بر پیاده سازی الگوی منبع یابی رویداد است. نحوه تفکیک عملیات خواندن داده ها در یک برنامه را از عملیات به روز رسانی داده ها با استفاده از رابط های جداگانه توضیح می دهد.  
  
* الگوی نمای مادی. ذخیره داده مورد استفاده در سیستمی که مبتنی بر منبع یابی رویداد است، معمولاً برای جستجوی کارآمد مناسب نیست. درعوض، یک رویکرد رایج این است که در فواصل زمانی منظم یا زمانی که داده ها تغییر می کنند، نماهای از پیش پرجمعیت داده ها تولید شود.  
  
* الگوی تراکنش جبرانی داده‌های موجود در فروشگاه منبع رویداد به‌روزرسانی نمی‌شود. در عوض، ورودی‌های جدیدی اضافه می‌شوند که وضعیت موجودیت‌ها را به مقادیر جدید انتقال می‌دهند. برای معکوس کردن یک تغییر، از ورودی های جبرانی استفاده می شود زیرا امکان معکوس کردن تغییر قبلی وجود ندارد. نحوه واگرد کاری که توسط عملیات قبلی انجام شده است را شرح می دهد.
