#‏ Competing Consumers pattern

چندین مصرف کننده همزمان(concurrent consumers) را فعال کنید تا پیام‌های دریافت شده در یک کانال پیام رسانی(messaging channel) را پردازش کنند. با چندین مصرف کننده همزمان، یک سیستم می‌تواند چندین پیام را به طور همزمان پردازش کند تا توان عملیاتی را بهینه کند، مقیاس پذیری(scalability) و در دسترس بودن(availability) را بهبود بخشد و حجم کار(workload) را متعادل کند.

## طرح صورت مسئله

انتظار می‌رود برنامه‌ای که در فضای ابری اجرا می‌شود، تعداد زیادی از درخواست‌ها را مدیریت کند. به جای پردازش هر درخواست به صورت همزمان، یک تکنیک رایج این است که application آنها را از طریق یک سیستم پیام رسانی به سرویس دیگری (یک سرویس مصرف کننده) که آنها را به طور ناهمزمان بررسی و پردازش می‌کند را ارسال‌ کند. این استراتژی کمک می‌کند تا اطمینان حاصل شود که business logic در برنامه مسدود نمی‌شود، در حالی که درخواست‌ها در حال پردازش هستند.  
  
تعداد درخواستها به دلایل زیادی در طول زمان می‌تواند به طور قابل توجهی متفاوت باشد. افزایش ناگهانی فعالیت کاربر یا درخواست‌‌های انبوهی که از چندین <mark style="background: #FFF3A3A6;">tenant</mark> می‌آیند می‌تواند باعث ایجاد حجم کاری غیرقابل پیش‌بینی شود. در ساعات اوج مصرف، یک سیستم ممکن است نیاز به پردازش صدها درخواست در ثانیه داشته باشد، در حالی که در زمان‌‌های دیگر این تعداد ممکن است بسیار کم باشد. علاوه بر این، ماهیت کار انجام شده برای رسیدگی به این درخواستها ممکن است بسیار متغیر باشد. با استفاده از یک نمونه از سرویس مصرف کننده، می‌توانید باعث شوید که آن نمونه اشباع از درخواست‌ها شود. همینطور یک سیستم پیام رسانی ممکن است به دلیل هجوم پیام‌هایی که از برنامه می‌آید، بیش از حد بارگذاری (overloaded) شود. برای مدیریت این حجم کاری نوسانی و متغیر، سیستم می‌تواند چندین نمونه از سرویس مصرف کننده را اجرا کند. با این حال، این مصرف کنندگان(consumers) باید هماهنگ شوند تا اطمینان حاصل شود که هر پیام تنها به یک مصرف کننده تحویل داده می‌شود. همینطور حجم کار(workload) همچنین باید در بین مصرف کنندگان متعادل باشد تا از تبدیل شدن یک نمونه از برنامه به گلوگاه جلوگیری شود.

## راه حل

از یک صف پیام (message queue) برای پیاده سازی کانال ارتباطی بین برنامه و نمونه‌‌های از سرویس‌ مصرف کننده (consumer service) استفاده کنید. برنامه درخواست‌ها را در قالب پیام به صف ارسال می‌کند و نمونه‌‌های سرویس مصرف کننده پیام‌هایی را از صف دریافت می‌کنند و آنها را پردازش می‌کنند. این رویکرد، مجموعه مشابه‌ای از نمونه‌‌های سرویس مصرف‌کننده را قادر می‌سازد تا پیام‌‌های هر نمونه از برنامه را مدیریت کنند. شکل استفاده از صف پیام (message queue) برای توزیع تسکها در نمونه‌‌های یک سرویس را نشان می‌دهد.

![competing-consumers-diagram](../assets/messaging/competing-consumers-diagram.png)



این راه حل دارای مزایای زیر است:

*‏ این یک سیستم load-leveled ارائه می‌کند که می‌تواند تغییرات گسترده ‌ای در حجم درخواست‌های ارسال شده توسط نمونه‌های application را مدیریت کند. صف به عنوان یک بافر بین نمونه‌‌های application و نمونه‌های سرویس مصرف کننده عمل می‌کند. این بافر می‌تواند به حداقل رساندن تأثیر بر در دسترس بودن و پاسخگویی، هم برای نمونه application و هم برای سرویس کمک کند. برای اطلاعات بیشتر، الگوی [Queue-based Load Leveling pattern](./Queue-Based%20Load%20Leveling%20pattern.md) را ببینید. مدیریت پیامی که نیاز به پردازش طولانی مدت دارد، مانع از رسیدگی همزمان پیام‌های دیگر توسط سایر نمونه‌های سرویس مصرف کننده نمی‌شود.  
  
*‏ این مورد قابلیت اطمینان را بهبود می‌بخشد. اگر یک تولیدکننده (producer) به جای استفاده از این الگو، مستقیماً با مصرف کننده (producer) ارتباط برقرار کند، اما بر مصرف کننده نظارت نداشته باشد، احتمال زیادی وجود دارد که در صورت شکست مصرف کننده، پیامها گم شوند یا پردازش نشوند. در این الگو، پیام‌ها به یک نمونه سرویس خاصی ارسال نمی‌شوند. یک نمونه سرویس ناموفق تولید کننده(producer) را مسدود یا block نمی‌کند و پیامها می‌توانند توسط هر نمونه‌ای از سرویس در حال کار پردازش شوند.  
  
*‏ این مورد نیازی به هماهنگی پیچیده بین مصرف کنندگان یا بین نمونه‌های تولید کننده و مصرف کننده ندارد. صف پیام تضمین می‌کند که هر پیام حداقل یک بار تحویل داده می‌شود.  
  
*‏ این مورد مقیاس پذیر است. هنگامی که مقیاس‌دهی خودکار( [auto-scaling](https://learn.microsoft.com/en-us/azure/architecture/best-practices/auto-scaling)) را اعمال می‌کنید، سیستم می‌تواند به صورت پویا تعداد نمونه‌‌های سرویس مصرف کننده را با نوسانات حجم پیامها افزایش یا کاهش دهد.  
  
*‏ اگر صف پیام عملیات خواندنِ تراکنشی (transactional read) را ارائه دهد، می‌تواند انعطاف پذیری (resiliency) را بهبود بخشد. اگر یک نمونه سرویس مصرف کننده پیام را به عنوان بخشی از یک عملیات تراکنشی (transactional operation) بخواند و پردازش کند و نمونه سرویس مصرف کننده با شکست مواجه شود، پس این الگو می‌تواند اطمینان حاصل کند که پیام به صف بازگردانده می‌شود تا توسط نمونه دیگری از سرویس مصرف کننده دریافت و مدیریت شود.  به منظور کاهش خطر شکست مداوم یک پیام، توصیه می‌کنیم از صف‌های مرده ([dead-letter queues](https://learn.microsoft.com/en-us/azure/service-bus-messaging/service-bus-dead-letter-queues)) استفاده کنید.

## مسائل و ملاحظات:

هنگام تصمیم گیری در مورد نحوه اجرای این الگو به نکات زیر توجه کنید:

*‏ **ترتیب پیام‌ها (Message ordering).** ترتیبی که نمونه‌‌های سرویس مصرف‌کننده پیام‌ها را دریافت می‌کنند تضمینی نیست و لزوماً نشان‌دهنده ترتیب ایجاد پیام‌ها نیست. سیستم را طوری طراحی کنید که از عدم توانایی پردازش پیام اطمینان حاصل کنید زیرا این امر به حذف هرگونه وابستگی به ترتیب مدیریت پیامها کمک می‌کند. برای اطلاعات بیشتر، الگو‌های [Idempotency Patterns](https://blog.jonathanoliver.com/idempotency-patterns/) را در وبلاگ  Jonathon Oliver ببینید.  
  
> مایکروسافت Azure Service Bus Queues می‌تواند با استفاده از message sessions، مرتب‌سازی تضمین شده پیام‌ها را  به ترتیب ا first-in-first-out اجرا کند. برای اطلاعات بیشتر، الگو‌های  [Messaging Patterns Using Sessions](https://learn.microsoft.com/en-us/archive/msdn-magazine/2012/december/azure-insider-microsoft-azure-service-bus-messaging-patterns-using-sessions) را ببینید.  
  
*‏ **طراحی سرویس برای تاب آوری (Designing services for resiliency).** اگر سیستم برای شناسایی و بازنشانی نمونه‌‌هایی از failed service طراحی شده باشد، پیشنهاد می‌شود پردازش انجام شده توسط نمونه‌‌های سرویس به‌عنوان عملیات idempotent اجرا شود که  idempotent به این معنی است که یک عمل را می‌توان چندین بار بدون تغییر در نتیجه اولیه تکرار کرد تا اثرات یک پیام واحد که بیش از یک بار بازیابی و پردازش می‌شود به حداقل برسد.  
  
*‏ **تشخیص پیام‌های سمی - Detecting poison messages **. یک پیام مخرب یا task ‌ای که نیاز به دسترسی به منابعی دارد که در دسترس نیستند، می‌تواند باعث از کار افتادن یک نمونه سرویس شود. سیستم باید از بازگرداندن چنین پیام‌‌هایی به صف جلوگیری کند و در عوض جزئیات این پیام‌ها را در جای دیگری ضبط و ذخیره کند تا در صورت لزوم بتوان آن‌ها را تجزیه و تحلیل کرد. 
  
*‏ **رسیدگی به نتیجه‌ها - Handling results**. نمونه سرویسی که یک پیام را مدیریت می‌کند به طور کامل از منطق برنامه‌ای که پیام را تولید می‌کند جدا شده است و ممکن است نتوانند مستقیماً با آن ارتباط برقرار کنند. اگر نمونه سرویس نتایجی تولید کند که باید به منطق برنامه بازگردانده شود، این اطلاعات باید در مکانی ذخیره شود که برای هر دو قابل دسترسی باشد. برای جلوگیری از بازیابی اطلاعات ناقص توسط منطق برنامه، سیستم باید نشان دهد که پردازش کامل شده است.

> اگر از Azure استفاده می‌کنید، یک worker process می‌تواند نتایج را با استفاده از یک صف پاسخ اختصاصی پیام به منطق برنامه بازگرداند. منطق برنامه باید بتواند این نتایج را با پیام اصلی مرتبط کند. این سناریو با جزئیات بیشتر در [Asynchronous Messaging Primer](https://learn.microsoft.com/en-us/previous-versions/msp-n-p/dn589781(v=pandp.10)) توضیح داده شده است.  
  
*‏ **مقیاس بندی سیستم پیام رسانی - Scaling the messaging system**. در یک راه حل به صورت  large-scale، یک  message queue منفرد می‌تواند توسط تعداد زیادی از  پیام‌ها شلوغ (overwhelmed) شود و به یک گلوگاه در سیستم تبدیل شود. در این شرایط، سیستم پیام رسانی را برای ارسال پیام از تولیدکنندگان خاص به یک صف خاص، پارتیشن بندی کنید، یا از توزیع‌کننده بار(load balancing) برای توزیع پیامها در چندین صف پیام استفاده کنید.  
  
*‏ **اطمینان از قابلیت اطمینان سیستم پیام رسانی - Ensuring reliability of the messaging system**. یک سیستم پیام رسانی قابل اعتماد لازم است تا تضمین کند که پس از اینکه برنامه یک پیام را در نوبت قرار داد، دیگر آن پیام از بین نخواهد رفت. این سیستم برای اطمینان از اینکه همه پیا‌م‌ها حداقل یک بار تحویل داده (delivered) می‌شوند ضروری است.

## چه زمانی از این الگو استفاده کنیم؟


از این الگو زمانی استفاده کنید که:  
  
*‏ حجم کار(workload) برای یک برنامه به task‌هایی تقسیم می‌شود که می‌توانند به صورت ناهمزمان(asynchronous) اجرا شوند.  
*‏ وظایف یا taskها مستقل هستند و می‌توانند به صورت موازی اجرا شوند.  
*‏ حجم کار (workload) بسیار متغیر است و به یک راه حل مقیاس پذیر (scalable) نیاز دارد.  
*‏ راه حل باید در دسترس بودن (availability) بالایی داشته باشد و اگر پردازش یک کار با شکست مواجه شد، باید انعطاف پذیر(resilient) باشد.


این الگو ممکن است زمانی مفید نباشد که:  
  
*‏ تفکیک حجم کاری(workload) برنامه به وظایف مجزا کار آسانی نیست، همینطور وابستگی بالایی بین کارها وجود دارد.  
*‏ وظایف یا Taskها باید به صورت همزمان(synchronous) انجام شوند و application logic قبل از ادامه باید منتظر تکمیل شدن task مورد نظر باشد.  
*‏ وظایف باید در یک توالی خاص انجام شود.  


> برخی از سیستم‌‌های پیام‌رسان session‌هایی را پشتیبانی می‌کنند که تولیدکننده (producer) را قادر می‌سازد تا پیام‌ها را با هم گروه‌بندی کند و اطمینان حاصل کند که همه آنها توسط یک مصرف‌کننده (consumer)  بررسی می‌شوند. این مکانیسم می‌تواند با پیام‌‌های اولویت‌دار (در صورت پشتیبانی) برای پیاده‌سازی شکلی از سفارشی سازی پیام که پیام‌ها را به ترتیب از یک تولیدکننده به یک مصرف‌کننده تحویل می‌دهد، استفاده شود.

## مثال

مایکروسافت Azure  امکان استفاده از Service Bus Queue  و Azure Function را فراهم می‌کند. توابع Azure از طریق triggerها و اتصالات با Azure Service Bus یکپارچه می‌شوند. ادغام با Service Bus به شما امکان می‌دهد تا توابعی بسازید که پیام‌های صف ارسال شده توسط منتشر کنندگان (publishers) را مصرف(consume) می‌کنند. در واقع این برنامه‌ها انتشار پیامها را به یک صف ارسال می‌کند و مصرف کنندگان، که به عنوان Azure Function پیاده سازی شده اند، می‌توانند پیامها را از این صف بازیابی کرده و آنها را مدیریت یا بررسی و استفاده کنند.  
  
برای انعطاف‌پذیری(resiliency)، یک  Service Bus queue enables به مصرف‌کننده امکان می‌دهد از حالت "PeekLock" زمانی که پیامی را از صف بازیابی می‌کند استفاده کند. این حالت در واقع پیام را حذف نمی‌کند، بلکه به سادگی آن را از سایر مصرف کنندگان پنهان می‌کند. زمان اجرا Azure Functions پیامی را در حالت "PeekLock" دریافت می‌کند، اگر این تابع با موفقیت تمام شود، گزینه Complete را روی پیام فراخوانی می‌کند یا ممکن است گزینه Abandon را در صورت از کار افتادن این تابع فراخوانی کند. پس پیام دوباره قابل مشاهده است و به مصرف‌کننده دیگری اجازه می‌دهد آن را بازیابی کند. اگر این تابع برای مدت زمانی طولانی‌تر از timeout مربوط به"PeekLock" اجرا شود، تا زمانی که تابع در حال اجرا باشد، این قفل به‌طور خودکار تمدید می‌شود. 

این Azure Function می‌توانند بر اساس عمق صف scale out/in شوند و  به عنوان مصرف کنندگان رقیب صف (competing consumers of the queue) عمل کنند. اگر چندین نمونه از توابع ایجاد شوند، همه آنها با کشیدن(pull) و پردازش مستقل پیامها به رقابت می‌پردازند.  
  
برای اطلاعات دقیق در مورد استفاده از Azure Service Bus queue به [Service Bus queues, topics, and subscriptions](https://learn.microsoft.com/en-us/azure/service-bus-messaging/service-bus-queues-topics-subscriptions) مراجعه کنید.  
  
برای اطلاعات در مورد صف  triggered Azure Functions  ، به  [Azure Service Bus trigger for Azure Functions](https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-service-bus-trigger) مراجعه کنید.  
  
کد زیر نشان می‌دهد که چگونه می‌توانید با استفاده از یک نمونه `ServiceBusClient` یک پیام جدید ایجاد کنید و آن را به `ServiceBusClient` ارسال کنید.

```csharp
private string serviceBusConnectionString = ...;
...

  public async Task SendMessagesAsync(CancellationToken  ct)
  {
   try
   {
    var msgNumber = 0;

    var serviceBusClient = new ServiceBusClient(serviceBusConnectionString);

    // create the sender
    ServiceBusSender sender = serviceBusClient.CreateSender("myqueue");

    while (!ct.IsCancellationRequested)
    {
     // Create a new message to send to the queue
     string messageBody = $"Message {msgNumber}";
     var message = new ServiceBusMessage(messageBody);

     // Write the body of the message to the console
     this._logger.LogInformation($"Sending message: {messageBody}");

     // Send the message to the queue
     await sender.SendMessageAsync(message);

     this._logger.LogInformation("Message successfully sent.");
     msgNumber++;
    }
   }
   catch (Exception exception)
   {
    this._logger.LogException(exception.Message);
   }
  }
```

مثال موجود کد زیر، مصرف کننده ‌ای را نشان می‌دهد که به عنوان یک C# Azure Function نوشته شده است که metadata پیام را می‌خواند و یک پیام Service Bus Queue message را ثبت می‌کند. توجه داشته باشید که چگونه ویژگی `ServiceBusTrigger` برای اتصال آن به Service Bus Queue message استفاده می‌شود.

```csharp
[FunctionName("ProcessQueueMessage")]
public static void Run(
    [ServiceBusTrigger("myqueue", Connection = "ServiceBusConnectionString")]
    string myQueueItem,
    Int32 deliveryCount,
    DateTime enqueuedTimeUtc,
    string messageId,
    ILogger log)
{
    log.LogInformation($"C# ServiceBus queue trigger function consumed message: {myQueueItem}");
    log.LogInformation($"EnqueuedTimeUtc={enqueuedTimeUtc}");
    log.LogInformation($"DeliveryCount={deliveryCount}");
    log.LogInformation($"MessageId={messageId}");
}
```

## قدم بعدی

*‏ [Asynchronous Messaging Primer](https://learn.microsoft.com/en-us/previous-versions/msp-n-p/dn589781(v=pandp.10)). صف‌های پیام یک مکانیسم ارتباطی ناهمزمان هستند. اگر یک سرویس مصرف کننده نیاز به ارسال پاسخ به یک برنامه را داشته باشد، ممکن است لازم باشد که نوعی پیام پاسخ را پیاده سازی کند. Asynchronous Messaging Primer اطلاعاتی در مورد نحوه اجرای پیام request/reply با استفاده از message queues ارائه می‌دهد.  
  
*‏  [Autoscaling Guidance](https://learn.microsoft.com/en-us/previous-versions/msp-n-p/dn589774(v=pandp.10)). ممکن است بتوان نمونه‌‌هایی از سرویس مصرف‌کننده را شروع کرد و سپس متوقف کرد، زیرا طول  صف پیام‌ها  برای هر برنامه‌ ‌ای متفاوت است. مقیاس خودکار(Autoscaling) می‌تواند به حفظ توان در زمان اوج پردازش (peak processing) کمک کند.

## منابع مرتبط

الگوها و راهنمایی‌‌های زیر ممکن است هنگام اجرای این الگو مرتبط باشند:  
  
*‏ [Compute Resource Consolidation pattern](./Competing%20Consumers%20pattern.md) ممکن است بتوان چندین نمونه از سرویس مصرف کننده را در یک فرآیند واحد ادغام کرد تا هزینه‌ها و سربار بررسی و پردازش کاهش یابد.  [Compute Resource Consolidation pattern](./Compute%20Resource%20Consolidation%20pattern.md)  مزایا و معایب پیروی از این رویکرد را توصیف می‌کند.  
  
*‏ [Queue-based Load Leveling pattern](./Queue-Based%20Load%20Leveling%20pattern.md). معرفی یک صف پیام می‌تواند انعطاف‌پذیری را به سیستم اضافه کند و نمونه‌‌های سرویس را قادر می‌سازد تا حجم بسیار متفاوتی از درخواست‌ها را از نمونه‌‌های برنامه مدیریت کنند. صف پیام به عنوان یک بافر عمل می‌کند که بار مصرفی را تراز می‌کند. الگوی تراز بار مبتنی بر صف (Queue-based) این سناریو را با جزئیات بیشتری توصیف می‌کند.