یک فروشگاه داده را به مجموعه ای از پارتیشن های افقی یا خرده تقسیم کنید. این می تواند مقیاس پذیری را هنگام ذخیره سازی و دسترسی به حجم زیادی از داده ها بهبود بخشد.
## Context and problem

یک فروشگاه داده که توسط یک سرور واحد میزبانی می شود ممکن است مشمول محدودیت های زیر باشد:  
  
* فضای ذخیره سازی. انتظار می رود که یک فروشگاه داده برای یک برنامه ابری در مقیاس بزرگ حاوی حجم عظیمی از داده ها باشد که می تواند در طول زمان به میزان قابل توجهی افزایش یابد. یک سرور معمولاً فقط مقدار محدودی از دیسک را فراهم می‌کند، اما می‌توانید دیسک‌های موجود را با دیسک‌های بزرگ‌تر جایگزین کنید یا با افزایش حجم داده، دیسک‌های بیشتری را به دستگاه اضافه کنید. با این حال، سیستم در نهایت به حدی می رسد که امکان افزایش آسان ظرفیت ذخیره سازی در یک سرور خاص وجود ندارد.  
  
* منابع محاسباتی یک برنامه ابری برای پشتیبانی از تعداد زیادی از کاربران همزمان مورد نیاز است که هر یک از آنها پرس و جوهایی را اجرا می کنند که اطلاعات را از فروشگاه داده بازیابی می کنند. ممکن است یک سرور منفرد میزبان ذخیره داده‌ها نتواند قدرت محاسباتی لازم را برای پشتیبانی از این بار فراهم کند، که منجر به طولانی‌تر شدن زمان پاسخ برای کاربران و خرابی‌های مکرر به‌عنوان برنامه‌های کاربردی برای ذخیره و بازیابی زمان داده‌ها می‌شود. ممکن است امکان افزودن حافظه یا ارتقاء پردازنده ها وجود داشته باشد، اما زمانی که امکان افزایش منابع محاسباتی بیشتر نباشد، سیستم به یک محدودیت می رسد.  
  
* پهنای باند شبکه در نهایت، عملکرد یک فروشگاه داده که روی یک سرور واحد اجرا می‌شود، توسط نرخی که سرور می‌تواند درخواست‌ها و ارسال پاسخ‌ها را دریافت کند، کنترل می‌شود. ممکن است حجم ترافیک شبکه از ظرفیت شبکه ای که برای اتصال به سرور استفاده می شود بیشتر باشد و در نتیجه درخواست ها ناموفق باشد.  
  
* جغرافیا. ممکن است به دلایل قانونی، انطباق یا عملکرد، یا کاهش تأخیر دسترسی به داده، داده های تولید شده توسط کاربران خاص در همان منطقه با آن کاربران ذخیره شود. اگر کاربران در کشورها یا مناطق مختلف پراکنده باشند، ممکن است امکان ذخیره کل داده های برنامه در یک فروشگاه داده وجود نداشته باشد.  
  
مقیاس عمودی با افزودن ظرفیت دیسک، قدرت پردازش، حافظه و اتصالات شبکه بیشتر می‌تواند اثرات برخی از این محدودیت‌ها را به تعویق بیندازد، اما احتمالاً تنها یک راه‌حل موقتی است. یک برنامه تجاری ابری که قادر به پشتیبانی از تعداد زیادی کاربر و حجم بالای داده است، باید تقریباً به طور نامحدود مقیاس پذیر باشد، بنابراین مقیاس عمودی لزوماً بهترین راه حل نیست.

## Solution

ذخیره داده را به پارتیشن های افقی یا خرده تقسیم کنید. هر خرده طرحواره یکسانی دارد، اما زیرمجموعه مجزایی از داده ها را در خود دارد. یک خرده به خودی خود یک ذخیره‌سازی داده است (می‌تواند حاوی داده‌های بسیاری از موجودیت‌های مختلف باشد)، که روی سروری اجرا می‌شود که به عنوان یک گره ذخیره‌سازی عمل می‌کند.  
  
این الگو دارای مزایای زیر است:

* می‌توانید با افزودن خرده‌های بیشتر در حال اجرا بر روی گره‌های ذخیره‌سازی اضافی، سیستم را کوچک کنید.  
  
* یک سیستم می تواند برای هر گره ذخیره سازی به جای کامپیوترهای تخصصی و گران قیمت، از سخت افزار آماده استفاده کند.  
  
* شما می توانید با ایجاد تعادل در حجم کار در بین خرده ها، اختلاف را کاهش دهید و عملکرد را بهبود بخشید.  
  
* در ابر، خرده‌ها را می‌توان از نظر فیزیکی نزدیک به کاربرانی که به داده‌ها دسترسی دارند، قرار داد.  
  
هنگام تقسیم یک ذخیره‌سازی داده‌ها به خرده‌ها، تصمیم بگیرید که کدام داده در هر خرده قرار گیرد. یک قطعه معمولاً شامل مواردی است که در محدوده مشخصی قرار می‌گیرند که توسط یک یا چند ویژگی داده تعیین می‌شود. این ویژگی ها کلید خرده (که گاهی اوقات به عنوان کلید پارتیشن نامیده می شود) را تشکیل می دهند. کلید شارد باید ثابت باشد. این نباید بر اساس داده هایی باشد که ممکن است تغییر کند.  
  
Sharding داده ها را به صورت فیزیکی سازماندهی می کند. هنگامی که یک برنامه داده ها را ذخیره و بازیابی می کند، منطق اشتراک گذاری برنامه را به قطعه مناسب هدایت می کند. این منطق اشتراک گذاری می تواند به عنوان بخشی از کد دسترسی به داده ها در برنامه پیاده سازی شود، یا اگر سیستم ذخیره سازی داده ها به طور شفاف از اشتراک گذاری پشتیبانی می کند، می تواند آن را پیاده سازی کند.  
  
انتزاع موقعیت فیزیکی داده ها در منطق اشتراک گذاری، سطح بالایی از کنترل بر روی اینکه کدام خرده ها حاوی چه داده ای هستند را فراهم می کند. همچنین اگر داده‌های موجود در خرده‌ها باید بعداً توزیع شوند (مثلاً اگر خرده‌ها نامتعادل شوند) داده‌ها را قادر می‌سازد تا بین خرده‌ها بدون تغییر منطق تجاری یک برنامه کاربردی مهاجرت کنند. مبادله، سربار دسترسی به داده اضافی است که برای تعیین مکان هر مورد داده در زمان بازیابی آن لازم است.  
  
برای اطمینان از عملکرد و مقیاس پذیری بهینه، مهم است که داده ها را به گونه ای تقسیم کنید که برای انواع پرس و جوهایی که برنامه انجام می دهد، مناسب باشد. در بسیاری از موارد، بعید است که طرح اشتراک گذاری دقیقاً با الزامات هر پرس و جو مطابقت داشته باشد. به عنوان مثال، در یک سیستم چند مستاجر، ممکن است یک برنامه کاربردی نیاز به بازیابی داده های مستاجر با استفاده از شناسه مستاجر داشته باشد، اما ممکن است نیاز به جستجوی این داده ها بر اساس برخی ویژگی های دیگر مانند نام یا مکان مستاجر داشته باشد. برای مدیریت این شرایط، یک استراتژی اشتراک گذاری را با یک کلید خرد که متداول ترین پرس و جوها را پشتیبانی می کند، اجرا کنید.  
  
اگر پرس و جوها به طور منظم داده ها را با استفاده از ترکیبی از مقادیر مشخصه بازیابی می کنند، احتمالاً می توانید با پیوند دادن ویژگی ها به یکدیگر، یک کلید خرده ترکیبی تعریف کنید. روش دیگر، از الگویی مانند Index Table برای ارائه جستجوی سریع به داده ها بر اساس ویژگی هایی که توسط کلید خرده پوشیده نشده اند استفاده کنید.

--------------

p1
--------------

## Sharding strategies

معمولاً هنگام انتخاب کلید شارد و تصمیم‌گیری درباره نحوه توزیع داده‌ها در بین خرده‌ها از سه استراتژی استفاده می‌شود. توجه داشته باشید که لازم نیست یک مکاتبه یک به یک بین خرده ها و سرورهایی که آنها را میزبانی می کنند وجود داشته باشد - یک سرور واحد می تواند چندین خرده را میزبانی کند. استراتژی ها عبارتند از:  
  
استراتژی جستجو در این استراتژی منطق اشتراک گذاری نقشه ای را پیاده سازی می کند که درخواست داده را با استفاده از کلید خرده به قطعه ای که حاوی آن داده است هدایت می کند. در یک برنامه چند مستاجر، تمام داده‌های یک مستاجر ممکن است با هم در یک قطعه با استفاده از شناسه مستاجر به عنوان کلید خرده ذخیره شود. ممکن است چندین مستاجر یک خرده را به اشتراک بگذارند، اما داده‌های یک مستاجر در چند خرده پخش نمی‌شود. شکل به اشتراک گذاری داده های مستاجر بر اساس شناسه های مستاجر را نشان می دهد.

![[Pasted image 20231205121504.png]]

نگاشت بین کلید خرده و حافظه فیزیکی می تواند بر اساس خرده های فیزیکی باشد که در آن هر کلید خرده به یک پارتیشن فیزیکی نگاشت می شود. روش دیگر، یک تکنیک انعطاف‌پذیرتر برای متعادل‌سازی مجدد شاردها، پارتیشن‌بندی مجازی است، که در آن کلیدهای خرده به همان تعداد خرده‌های مجازی نگاشت می‌شوند، که به نوبه خود به پارتیشن‌های فیزیکی کمتری نگاشت می‌شوند. در این رویکرد، یک برنامه کاربردی داده ها را با استفاده از یک کلید خرد که به یک خرده مجازی اشاره دارد، مکان یابی می کند و سیستم به طور شفاف، خرده های مجازی را به پارتیشن های فیزیکی نگاشت می کند. نقشه برداری بین یک پارتیشن مجازی و یک پارتیشن فیزیکی می تواند بدون نیاز به تغییر کد برنامه برای استفاده از مجموعه متفاوتی از کلیدهای خرد تغییر کند.  
  
استراتژی برد. این استراتژی اقلام مرتبط را با هم در یک خرده گروه بندی می کند و آنها را بر اساس کلید خرده مرتب می کند - کلیدهای خرده متوالی هستند. برای برنامه‌هایی که مرتباً مجموعه‌هایی از آیتم‌ها را با استفاده از پرس‌وجوهای محدوده بازیابی می‌کنند (پرس‌وجوهایی که مجموعه‌ای از آیتم‌های داده را برای یک کلید خرده‌ای که در محدوده معینی قرار می‌گیرد، برمی‌گردانند) مفید است. به عنوان مثال، اگر یک برنامه به طور مرتب نیاز به یافتن همه سفارش‌های ثبت‌شده در یک ماه خاص داشته باشد، اگر همه سفارش‌های یک ماه به ترتیب تاریخ و زمان در یک قطعه ذخیره شوند، می‌توان این داده‌ها را سریع‌تر بازیابی کرد. اگر هر سفارش در خرده‌ای متفاوت ذخیره می‌شد، باید با انجام تعداد زیادی پرس‌وجوی نقطه‌ای (پرس‌وجوهایی که یک مورد داده واحد را برمی‌گرداند) به‌صورت جداگانه واکشی شوند. شکل بعدی ذخیره مجموعه های متوالی (محدوده) داده ها را به صورت خرد نشان می دهد.

![[Pasted image 20231205121518.png]]

در این مثال، کلید خرده یک کلید ترکیبی است که حاوی ماه سفارش به عنوان مهم‌ترین عنصر و به دنبال آن روز سفارش و زمان است. زمانی که سفارش‌های جدید ایجاد می‌شوند و به یک قطعه اضافه می‌شوند، داده‌های سفارش‌ها به طور طبیعی مرتب می‌شوند. برخی از فروشگاه های داده از کلیدهای خرده دو قسمتی حاوی یک عنصر کلید پارتیشن که قطعه را شناسایی می کند و یک کلید ردیفی که به طور منحصر به فرد یک مورد را در قطعه شناسایی می کند، پشتیبانی می کنند. داده ها معمولاً به ترتیب کلیدهای ردیفی در قطعه نگهداری می شوند. مواردی که در معرض پرس و جوهای محدوده هستند و باید با هم گروه بندی شوند، می توانند از کلید خرده ای استفاده کنند که مقدار یکسانی برای کلید پارتیشن دارد اما یک مقدار منحصر به فرد برای کلید ردیف.  
  
استراتژی هش هدف از این استراتژی کاهش شانس هات اسپات ها (تکه هایی که مقدار نامتناسبی از بار دریافت می کنند) است. این داده ها را در بین خرده ها به گونه ای توزیع می کند که بین اندازه هر خرده و میانگین باری که هر خرده با آن مواجه می شود تعادل ایجاد می کند. منطق شاردینگ، شارد را برای ذخیره یک آیتم بر اساس هش یک یا چند ویژگی از داده ها محاسبه می کند. تابع هش انتخاب شده باید داده ها را به طور یکنواخت در بین خرده ها توزیع کند، احتمالاً با وارد کردن برخی از عناصر تصادفی در محاسبات. شکل بعدی به اشتراک گذاری داده های مستاجر را بر اساس هش شناسه های مستاجر نشان می دهد.

![[Pasted image 20231205121531.png]]

برای درک مزیت استراتژی هش نسبت به سایر استراتژی‌های اشتراک‌گذاری، در نظر بگیرید که چگونه یک برنامه کاربردی چند مستاجر که مستاجران جدید را به‌طور متوالی ثبت‌نام می‌کند، ممکن است مستاجران را به خرده‌هایی در فروشگاه داده اختصاص دهد. هنگام استفاده از استراتژی Range، داده‌های مستاجران 1 تا n همگی در قطعه A، داده‌های مستاجران n+1 تا m همه در خرده B ذخیره می‌شوند و غیره. اگر مستاجرینی که اخیراً ثبت نام کرده اند نیز فعال ترین باشند، بیشترین فعالیت داده در تعداد کمی از خرده ها رخ می دهد که می تواند باعث ایجاد کانون ها شود. در مقابل، استراتژی هش مستاجران را بر اساس هش شناسه مستاجرشان به خرده‌ها اختصاص می‌دهد. این بدان معنی است که مستاجران متوالی به احتمال زیاد به خرده های مختلف اختصاص داده می شوند که بار را در بین آنها توزیع می کند. شکل قبلی این موضوع را برای مستاجران 55 و 56 نشان می دهد.

-------------
p2
-------------


سه استراتژی اشتراک گذاری دارای مزایا و ملاحظات زیر است:

* جستجو. این امر کنترل بیشتری بر نحوه پیکربندی و استفاده از خرده ها ارائه می دهد. استفاده از خرده‌های مجازی تأثیر را هنگام متعادل‌سازی مجدد داده‌ها کاهش می‌دهد، زیرا می‌توان پارتیشن‌های فیزیکی جدیدی اضافه کرد تا حجم کار را یکنواخت کند. نگاشت بین یک خرده مجازی و پارتیشن‌های فیزیکی که آن را پیاده‌سازی می‌کنند، می‌تواند بدون تأثیرگذاری بر کد برنامه‌ای که از یک کلید خرد برای ذخیره و بازیابی داده‌ها استفاده می‌کند، تغییر دهد. جست‌وجوی مکان‌های خرد می‌تواند هزینه‌های اضافی را تحمیل کند.  
  
* دامنه. پیاده سازی این کار آسان است و به خوبی با پرس و جوهای محدوده کار می کند زیرا آنها اغلب می توانند چندین مورد داده را از یک قطعه واحد در یک عملیات واحد واکشی کنند. این استراتژی مدیریت داده ها را آسان تر می کند. به عنوان مثال، اگر کاربران در همان منطقه در یک خرده باشند، به روز رسانی ها را می توان در هر منطقه زمانی بر اساس بار محلی و الگوی تقاضا برنامه ریزی کرد. با این حال، این استراتژی تعادل مطلوب بین خرده ها را فراهم نمی کند. تعادل مجدد خرده ها دشوار است و اگر بیشتر فعالیت ها برای کلیدهای خرده مجاور باشد، ممکن است مشکل بار ناهموار را حل نکند.  
  
* هش. این استراتژی شانس بیشتری برای توزیع یکنواخت داده و بار ارائه می دهد. مسیریابی درخواست را می توان مستقیماً با استفاده از تابع هش انجام داد. نیازی به نگهداری نقشه نیست توجه داشته باشید که محاسبه هش ممکن است سربار اضافی را تحمیل کند. همچنین، تعادل مجدد خرده ها دشوار است.


اکثر سیستم های اشتراک گذاری رایج یکی از رویکردهای شرح داده شده در بالا را اجرا می کنند، اما باید الزامات تجاری برنامه های کاربردی خود و الگوهای استفاده از داده آنها را نیز در نظر بگیرید. به عنوان مثال، در یک برنامه چند مستاجر:  
  
* شما می توانید داده ها را بر اساس حجم کاری خرد کنید. شما می توانید داده ها را برای مستاجران بسیار فرار در خرده های جداگانه جدا کنید. در نتیجه سرعت دسترسی به داده‌ها برای سایر مستاجرین ممکن است بهبود یابد.  
  
* می توانید داده ها را بر اساس موقعیت مکانی مستاجران خرد کنید. می‌توانید داده‌های مستأجران در یک منطقه جغرافیایی خاص را برای پشتیبان‌گیری و نگهداری در ساعات شلوغی در آن منطقه به‌صورت آفلاین دریافت کنید، در حالی که داده‌های مستاجران در مناطق دیگر آنلاین و در ساعات کاری آن‌ها در دسترس است.  
  
* به مستاجران با ارزش می‌توان قطعات خصوصی، با کارایی بالا و کم بار اختصاص داد، در حالی که از مستاجران کم‌ارزش می‌توان انتظار داشت که خرده‌های پرمشغله‌تر و متراکم‌تری را به اشتراک بگذارند.  
  
* داده های مستاجرینی که به درجه بالایی از جداسازی داده ها و حفظ حریم خصوصی نیاز دارند را می توان در یک سرور کاملا مجزا ذخیره کرد.

## Scaling and data movement operations

هر یک از استراتژی های به اشتراک گذاری مستلزم قابلیت ها و سطوح پیچیدگی متفاوتی برای مدیریت مقیاس در، کوچک کردن، جابجایی داده ها و حفظ وضعیت است.  
  
استراتژی Lookup اجازه می دهد تا عملیات مقیاس گذاری و جابجایی داده ها در سطح کاربر، به صورت آنلاین یا آفلاین انجام شود. این تکنیک عبارت است از تعلیق برخی یا تمام فعالیت‌های کاربر (شاید در دوره‌های غیر اوج مصرف)، انتقال داده‌ها به پارتیشن مجازی یا قطعه فیزیکی جدید، تغییر نگاشت‌ها، باطل کردن یا تازه کردن حافظه‌های پنهانی که این داده‌ها را در خود نگه می‌دارد، و سپس اجازه فعالیت کاربر را می‌دهد. ادامه دادن. اغلب این نوع عملیات را می توان به صورت متمرکز مدیریت کرد. استراتژی Lookup مستلزم آن است که حالت بسیار ذخیره‌سازی شده باشد و پسند باشد.  
  
استراتژی Range محدودیت‌هایی را بر مقیاس‌گذاری و عملیات جابجایی داده اعمال می‌کند، که معمولاً باید زمانی انجام شود که بخشی یا تمام ذخیره‌سازی داده آفلاین است، زیرا داده‌ها باید تقسیم شده و در بین خرده‌ها ادغام شوند. اگر بیشتر فعالیت‌ها مربوط به کلیدهای تکه‌ای مجاور یا شناسه‌های داده‌ای است که در محدوده یکسان هستند، انتقال داده‌ها به تعادل مجدد خرده‌ها ممکن است مشکل بار ناهموار را حل نکند. استراتژی Range همچنین ممکن است برای نگاشت محدوده به پارتیشن‌های فیزیکی نیاز به حفظ وضعیت داشته باشد.  

-------------
p3
-------------

استراتژی هش، مقیاس‌گذاری و عملیات جابجایی داده‌ها را پیچیده‌تر می‌کند، زیرا کلیدهای پارتیشن هش‌های کلیدهای خرد یا شناسه داده‌ها هستند. مکان جدید هر قطعه باید از تابع هش تعیین شود، یا تابع اصلاح شود تا نگاشت صحیح را ارائه دهد. با این حال، استراتژی Hash نیازی به حفظ حالت ندارد.

## Issues and considerations

هنگام تصمیم گیری در مورد نحوه اجرای این الگو به نکات زیر توجه کنید:  
  
* ي Sharding مکمل سایر اشکال پارتیشن بندی مانند پارتیشن بندی عمودی و پارتیشن بندی عملکردی است. به عنوان مثال، یک خرده تکی می‌تواند شامل موجودیت‌هایی باشد که به صورت عمودی پارتیشن بندی شده‌اند، و یک پارتیشن تابعی می‌تواند به صورت چند خرده پیاده‌سازی شود. برای اطلاعات بیشتر در مورد پارتیشن بندی، به راهنمای پارتیشن بندی داده ها مراجعه کنید.  
  
* خرده ها را متعادل نگه دارید تا همه آنها حجم مشابهی از I/O را کنترل کنند. از آنجایی که داده ها درج و حذف می شوند، لازم است که به صورت دوره ای مجدداً تعادل خرده ها را برای تضمین توزیع یکنواخت و کاهش شانس هات اسپات ها تنظیم کنید. تعادل مجدد می تواند یک عملیات گران قیمت باشد. برای کاهش نیاز به تعادل مجدد، با اطمینان از اینکه هر خرده دارای فضای خالی کافی برای رسیدگی به حجم مورد انتظار تغییرات است، برای رشد برنامه ریزی کنید. شما همچنین باید استراتژی‌ها و اسکریپت‌هایی را ایجاد کنید که در صورت لزوم، می‌توانید از آنها برای متعادل کردن مجدد سریع قطعه‌ها استفاده کنید.  
  
* از داده های پایدار برای کلید خرد استفاده کنید. اگر کلید خرده تغییر کند، آیتم داده مربوطه ممکن است باید بین خرده‌ها جابه‌جا شود و میزان کار انجام شده توسط عملیات به‌روزرسانی افزایش یابد. به همین دلیل، از قرار دادن کلید خرد بر روی اطلاعات بالقوه فرار خودداری کنید. در عوض، به دنبال ویژگی هایی باشید که ثابت هستند یا به طور طبیعی یک کلید را تشکیل می دهند.  
  
* اطمینان حاصل کنید که کلیدهای خرد شده منحصر به فرد هستند. به عنوان مثال، از استفاده از فیلدهای افزایش خودکار به عنوان کلید خرد خودداری کنید. در برخی سیستم‌ها، فیلدهای افزایش‌یافته خودکار را نمی‌توان در بین خرده‌ها هماهنگ کرد، که احتمالاً منجر به این می‌شود که آیتم‌هایی در خرده‌های مختلف کلید خرده یکسانی داشته باشند.

> مقادیر افزایش یافته خودکار در سایر فیلدها که کلیدهای خرده نیستند نیز می تواند باعث ایجاد مشکل شود. به عنوان مثال، اگر از فیلدهای افزایش یافته خودکار برای تولید شناسه های منحصر به فرد استفاده می کنید، ممکن است به دو مورد مختلف که در خرده های مختلف قرار دارند، یک شناسه اختصاص داده شود.

* ممکن است طراحی یک کلید خرده ای که با الزامات هر درخواست ممکن در برابر داده ها مطابقت داشته باشد، امکان پذیر نباشد. داده‌ها را برای پشتیبانی از اغلب پرس‌و‌جوهای انجام‌شده تکه تکه کنید، و در صورت لزوم جداول شاخص ثانویه را برای پشتیبانی از جستارهایی که داده‌ها را با استفاده از معیارهایی بر اساس ویژگی‌هایی که بخشی از کلید خرد نیست، بازیابی می‌کنند، ایجاد کنید. برای اطلاعات بیشتر، الگوی جدول شاخص را ببینید.  
  
* پرس و جوهایی که فقط به یک قطعه دسترسی دارند کارآمدتر از آنهایی هستند که داده ها را از چند خرده بازیابی می کنند، بنابراین از پیاده سازی یک سیستم اشتراک گذاری که منجر به اجرای تعداد زیادی پرس و جو توسط برنامه هایی می شود که داده های نگهداری شده در خرده های مختلف را به هم می پیوندند، خودداری کنید. به یاد داشته باشید که یک خرده می‌تواند حاوی داده‌های چند نوع موجودیت باشد. غیرعادی کردن داده‌های خود را در نظر بگیرید تا موجودیت‌های مرتبطی را که معمولاً در کنار هم جستجو می‌شوند (مانند جزئیات مشتریان و سفارش‌هایی که آنها انجام داده‌اند) در یک قطعه نگه دارید تا تعداد خواندن‌های جداگانه‌ای که یک برنامه انجام می‌دهد کاهش یابد.

> اگر موجودی در یک خرده به یک موجودیت ذخیره شده در خرده دیگر ارجاع دهد، کلید خرده موجودیت دوم را به عنوان بخشی از طرح موجودیت اول وارد کنید. این می تواند به بهبود عملکرد پرس و جوهایی که به داده های مرتبط در سراسر خرده ارجاع می دهند کمک کند.

* اگر یک برنامه باید پرس و جوهایی را انجام دهد که داده ها را از چند خرده بازیابی می کند، ممکن است بتوان این داده ها را با استفاده از وظایف موازی واکشی کرد. مثال‌ها عبارتند از پرس‌وجوهای fan-out، که در آن داده‌های چند خرده به صورت موازی بازیابی می‌شوند و سپس در یک نتیجه جمع می‌شوند. با این حال، این رویکرد به ناچار پیچیدگی هایی را به منطق دسترسی به داده های یک راه حل اضافه می کند.  
  
* برای بسیاری از کاربردها، ایجاد تعداد بیشتر خرده‌های کوچک می‌تواند کارآمدتر از داشتن تعداد کمی خرده‌های بزرگ باشد، زیرا می‌توانند فرصت‌های بیشتری را برای متعادل کردن بار ارائه دهند. این همچنین می تواند مفید باشد اگر شما نیاز به مهاجرت خرده ها از یک مکان فیزیکی به مکان دیگر را پیش بینی کنید. حرکت دادن یک تکه کوچک سریعتر از حرکت دادن یک قطعه بزرگ است.  
  
* اطمینان حاصل کنید که منابع موجود برای هر گره ذخیره‌سازی خرده‌ای برای رسیدگی به نیازهای مقیاس‌پذیری از نظر اندازه و توان داده کافی است. برای اطلاعات بیشتر، بخش 'طراحی پارتیشن ها برای مقیاس پذیری' را در راهنمای پارتیشن بندی داده ها ببینید.  
  
* تکرار داده های مرجع برای همه خرده ها را در نظر بگیرید. اگر عملیاتی که داده‌ها را از یک خرده بازیابی می‌کند، به داده‌های ثابت یا کند حرکت نیز به عنوان بخشی از همان جستار اشاره می‌کند، این داده‌ها را به قطعه اضافه کنید. سپس برنامه می‌تواند تمام داده‌های مربوط به پرس و جو را به راحتی واکشی کند، بدون اینکه نیازی به سفر رفت و برگشت اضافی به یک فروشگاه داده جداگانه داشته باشد.

> اگر داده های مرجع نگهداری شده در چند خرده تغییر کند، سیستم باید این تغییرات را در همه خرده ها همگام کند. سیستم می تواند درجه ای از ناهماهنگی را در زمانی که این همگام سازی رخ می دهد، تجربه کند. اگر این کار را انجام می دهید، باید برنامه های خود را طوری طراحی کنید که بتوانید آن را مدیریت کنید.

------------
p4
------------

* حفظ یکپارچگی ارجاعی و سازگاری بین خرده‌ها می‌تواند دشوار باشد، بنابراین باید عملیات‌هایی را که روی داده‌ها در چند خرده تأثیر می‌گذارند، به حداقل برسانید. اگر برنامه‌ای باید داده‌ها را در بین خرده‌ها تغییر دهد، ارزیابی کنید که آیا سازگاری کامل داده واقعاً مورد نیاز است یا خیر. درعوض، یک رویکرد رایج در فضای ابری، اجرای یکپارچگی نهایی است. داده‌های هر پارتیشن به‌طور جداگانه به‌روزرسانی می‌شوند و منطق برنامه باید مسئولیت اطمینان از تکمیل موفقیت‌آمیز به‌روزرسانی‌ها و همچنین رسیدگی به ناهماهنگی‌هایی را که می‌تواند از جستجوی داده‌ها در زمانی که یک عملیات در نهایت سازگار در حال اجرا است، به عهده بگیرد. برای اطلاعات بیشتر در مورد اجرای سازگاری نهایی، به Primer سازگاری داده مراجعه کنید.  
  
* پیکربندی و مدیریت تعداد زیادی از خرده ها می تواند یک چالش باشد. وظایفی مانند نظارت، تهیه نسخه پشتیبان، بررسی سازگاری، و ثبت یا ممیزی باید بر روی چندین قطعه و سرور انجام شود که احتمالاً در مکان‌های مختلف نگهداری می‌شوند. این وظایف احتمالاً با استفاده از اسکریپت ها یا سایر راه حل های اتوماسیون اجرا می شوند، اما ممکن است الزامات اداری اضافی را به طور کامل حذف نکند.  
  
* خرده‌ها را می‌توان به گونه‌ای مکان‌یابی کرد که داده‌های موجود در آنها به نمونه‌های برنامه‌ای که از آن استفاده می‌کند نزدیک باشد. این رویکرد می‌تواند عملکرد را به طور قابل توجهی بهبود بخشد، اما برای کارهایی که باید به چند قطعه در مکان‌های مختلف دسترسی داشته باشند، نیاز به بررسی بیشتری دارد.

## When to use this pattern

از این الگو زمانی استفاده کنید که یک فروشگاه داده به احتمال زیاد نیاز به مقیاس پذیری فراتر از منابع موجود برای یک گره ذخیره سازی دارد، یا برای بهبود عملکرد با کاهش اختلاف در یک فروشگاه داده.

```
توجه داشته باشید  
  
تمرکز اصلی اشتراک گذاری بهبود عملکرد و مقیاس پذیری یک سیستم است، اما به عنوان یک محصول جانبی می تواند به دلیل نحوه تقسیم داده ها به پارتیشن های جداگانه، دسترسی را نیز بهبود بخشد. خرابی در یک پارتیشن لزوماً مانع از دسترسی یک برنامه کاربردی به داده‌های نگهداری شده در پارتیشن‌های دیگر نمی‌شود و یک اپراتور می‌تواند تعمیر و نگهداری یا بازیابی یک یا چند پارتیشن را بدون اینکه کل داده‌های یک برنامه غیرقابل دسترسی باشد، انجام دهد. برای اطلاعات بیشتر، به راهنمای پارتیشن بندی داده ها مراجعه کنید.
```

## Example

مثال زیر در سی شارپ از مجموعه ای از پایگاه داده های SQL Server استفاده می کند که به عنوان خرده عمل می کنند. هر پایگاه داده زیرمجموعه ای از داده های مورد استفاده یک برنامه را در خود جای می دهد. این برنامه داده‌هایی را که در بین خرده‌ها توزیع شده است، با استفاده از منطق اشتراک‌گذاری خودش بازیابی می‌کند (این نمونه‌ای از یک پرس‌وجوی فن‌آوری است). جزئیات داده‌هایی که در هر خرده قرار دارند با روشی به نام GetShards بازگردانده می‌شوند. این روش یک لیست قابل شمارش از اشیاء ShardInformation را برمی گرداند، که در آن نوع ShardInformation شامل یک شناسه برای هر قطعه و رشته اتصال SQL Server است که برنامه باید از آن برای اتصال به قطعه استفاده کند (رشته های اتصال در مثال کد نشان داده نشده اند).

```csharp
private IEnumerable<ShardInformation> GetShards()
{
  // This retrieves the connection information from a shard store
  // (commonly a root database).
  return new[]
  {
    new ShardInformation
    {
      Id = 1,
      ConnectionString = ...
    },
    new ShardInformation
    {
      Id = 2,
      ConnectionString = ...
    }
  };
}
```

## Example

مثال زیر در سی شارپ از مجموعه ای از پایگاه داده های SQL Server استفاده می کند که به عنوان خرده عمل می کنند. هر پایگاه داده زیرمجموعه ای از داده های مورد استفاده یک برنامه را در خود جای می دهد. این برنامه داده‌هایی را که در بین خرده‌ها توزیع شده است، با استفاده از منطق اشتراک‌گذاری خودش بازیابی می‌کند (این نمونه‌ای از یک پرس‌وجوی فن‌آوری است). جزئیات داده‌هایی که در هر خرده قرار دارند با روشی به نام GetShards بازگردانده می‌شوند. این روش یک لیست قابل شمارش از اشیاء ShardInformation را برمی گرداند، که در آن نوع ShardInformation شامل یک شناسه برای هر قطعه و رشته اتصال SQL Server است که برنامه باید از آن برای اتصال به قطعه استفاده کند (رشته های اتصال در مثال کد نشان داده نشده اند).

```csharp
private IEnumerable<ShardInformation> GetShards()
{
  // This retrieves the connection information from a shard store
  // (commonly a root database).
  return new[]
  {
    new ShardInformation
    {
      Id = 1,
      ConnectionString = ...
    },
    new ShardInformation
    {
      Id = 2,
      ConnectionString = ...
    }
  };
}
```

کد زیر نشان می‌دهد که چگونه برنامه از فهرست اشیاء ShardInformation برای انجام پرس و جوی استفاده می‌کند که داده‌ها را از هر خرده به صورت موازی واکشی می‌کند. جزئیات پرس و جو نشان داده نمی شود، اما در این مثال داده های بازیابی شده حاوی رشته ای است که می تواند اطلاعاتی مانند نام مشتری را در خود نگه دارد، اگر خرده ها حاوی جزئیات مشتریان باشند. نتایج در یک مجموعه ConcurrentBag برای پردازش توسط برنامه تجمیع می‌شوند.

```csharp
// Retrieve the shards as a ShardInformation[] instance.
var shards = GetShards();

var results = new ConcurrentBag<string>();

// Execute the query against each shard in the shard list.
// This list would typically be retrieved from configuration
// or from a root/primary shard store.
Parallel.ForEach(shards, shard =>
{
  // NOTE: Transient fault handling isn't included,
  // but should be incorporated when used in a real world application.
  using (var con = new SqlConnection(shard.ConnectionString))
  {
    con.Open();
    var cmd = new SqlCommand("SELECT ... FROM ...", con);

    Trace.TraceInformation("Executing command against shard: {0}", shard.Id);

    var reader = cmd.ExecuteReader();
    // Read the results in to a thread-safe data structure.
    while (reader.Read())
    {
      results.Add(reader.GetString(0));
    }
  }
});

Trace.TraceInformation("Fanout query complete - Record Count: {0}",
                        results.Count);
```

## Next steps

راهنمایی زیر ممکن است هنگام اجرای این الگو نیز مرتبط باشد:  
  
* پرایمر سازگاری داده ممکن است لازم باشد برای داده های توزیع شده در خرده های مختلف یکنواختی حفظ شود. مسائل مربوط به حفظ ثبات در داده های توزیع شده را خلاصه می کند و مزایا و معاوضه های مدل های سازگاری مختلف را شرح می دهد.  
* راهنمای پارتیشن بندی داده ها اشتراک گذاری یک فروشگاه داده می تواند طیف وسیعی از مسائل اضافی را ایجاد کند. این مسائل را در رابطه با پارتیشن بندی انبارهای داده در فضای ابری برای بهبود مقیاس پذیری، کاهش اختلاف و بهینه سازی عملکرد توضیح می دهد.

## Related resources

الگوهای زیر نیز ممکن است هنگام اجرای این الگو مرتبط باشند:  
  
* الگوی جدول شاخص. گاهی اوقات پشتیبانی کامل از پرس و جوها فقط از طریق طراحی کلید خرده امکان پذیر نیست. برنامه را قادر می‌سازد تا با تعیین کلیدی غیر از کلید خرد، داده‌ها را از یک فروشگاه بزرگ داده به سرعت بازیابی کند.  
* الگوی نمای مادی. برای حفظ عملکرد برخی از عملیات پرس و جو، ایجاد نماهای تحقق یافته که داده ها را جمع آوری و خلاصه می کند مفید است، به خصوص اگر این داده های خلاصه بر اساس اطلاعاتی باشد که در بین خرده ها توزیع شده است. نحوه تولید و پر کردن این نماها را شرح می دهد.