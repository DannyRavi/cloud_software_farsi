به جای ذخیره  وضعیت فعلی داده ها در یک حوزه خاص، از یک ذخیره کننده در حالت فقط افزودنی (append-only) برای ثبت مجموعه کامل اقدامات انجام شده روی داده‌ها استفاده کنید. ذخیره کننده به عنوان سیستم ثبت داده‌ها عمل می کند و می تواند برای تحقق  objectها یا شی های دامنه استفاده شود. این ویژگی می‌تواند تسک‌ها را در حوزه‌های پیچیده بدون نیاز به همگام‌سازی در مدل داده و حوزه های تجاری آن، ساده‌سازی کند و در ادامه که کارایی (performance)، مقیاس‌پذیری(scalability) و پاسخ‌دهی(responsiveness) را بهبود بخشد. همچنین این ویژگی می‌تواند یکپارچگی برای داده‌های مربوط به تراکنش‌های مختلف را فراهم کند.


## **طرح صورت مسئله:**

بیشتر برنامه ها با انواع داده‌های مختلفی کار می کنند و رویکرد معمولی این است که برنامه بتواند وضعیت فعلی داده ها را با به روز رسانی آن ها در زمانی که کاربران با آن کار می کنند حفظ کند. به عنوان مثال ، در مدل سنتی create, read, update,  delete یا به اختصار (CRUD) یک فرآیند مربوط به داده ها می‌تواند اینطور باشد که ابتدا داده‌ها را از ذخیره‌گاه بخوانیم سپس تغییراتی در آن‌ها ایجاد کنیم و وضعیت فعلی داده‌ها را با مقادیر جدید به‌روزرسانی کنیم - که اغلب اینکار با استفاده از تراکنش‌هایی که داده‌ها را قفل می‌کنند، انجام می‌شود.


رویکرد CRUD محدودیت هایی زیر را دارد:

* سیستم‌های CRUD عملیات به‌روزرسانی را مستقیماً در برابر یک data store انجام می‌دهند. این عملیات می تواند کارایی و کیفیت پاسخگویی را کاهش دهد و به دلیل سربار پردازشی که نیاز دارد، مقیاس پذیری(scalability) را محدود کند.  
  
* در یک حوزه همکاری مشترک  با بسیاری از کاربرانی که همزمان فعالیت می کنند، تداخل بروزرسانی داده‌ها بیشتر محتمل است زیرا عملیات بروزرسانی فقط روی یک مورد از داده‌ها انجام می‌شود.  
  
* مگر اینکه مکانیزم محافظتی دیگری وجود داشته باشد که جزئیات هر عملیات را در یک لاگ جداگانه ثبت کند زیرا تاریخچه آن‌ها از بین می‌رود.


## راه حل

الگوی Event Sourcing رویکردی را برای مدیریت عملیات روی داده ها تعریف می کند که توسط یک توالی از رویدادها انجام می شود که هر یک از آنها فقط در یک ذخیره‌گاه فقط افزودنی (append-only) ثبت می شوند. کد برنامه مجموعه‌ای از رویدادها را ارسال می‌کند که به طور جدی هر عملی را که روی داده‌ها رخ داده است، به ذخیره‌گاه رویداد یا event store می‌فرستد (برای یادآوری event store  این مورد به فصل مقدمه مراجعه کنید) ، جایی که آنها ذخیره می‌شوند. هر رویداد نشان دهنده مجموعه ای از تغییرات در داده ها است (مانند `AddedItemToOrder`).


رویدادها در یک ذخیره‌گاه رویداد  که به عنوان سیستم ثبت (منبع معتبر داده‌ها) درباره وضعیت فعلی داده ها عمل می کند. ذخیره‌گاه رویداد معمولاً این رویدادها را منتشر می کند تا مصرف کنندگان آن رویداد بتوانند از آن وقوع آن مطلع شوند و در صورت نیاز بتوانند به آنها پاسخ دهی کنند. برای مثال، مصرف‌کنندگان  می‌توانند وظایفی را آغاز کنند که عملیات‌های رویدادها را در سیستم‌های دیگر اعمال می‌کند و هر اقدام مرتبط دیگری را که برای تکمیل عملیات لازم است انجام دهند. توجه داشته باشید که کد برنامه ای که رویدادها را تولید می کند از سیستم هایی که از رویدادها مطلع می‌شوند و آن ها را پیام‌ها را دریافت یا subscribe می کنند، جدا شده است.

>	نکته: یک نمای مادی ([materialized view](https://learn.microsoft.com/en-us/azure/architecture/patterns/materialized-view)) یک جدول شامل داده‌ها است که نتیجه یک پرس و جو را در خود ذخیره می‌کند. این روش باعث می‌شود که دسترسی به داده‌ها سریع‌تر و کارآمدتر شود، اما به قیمت اشغال فضای بیشتر و احتمال عدم به‌روز بودن برخی از داده‌ها.

استفاده ساده از رویدادهای منتشر شده توسط ذخیره‌گاه رویداد  برای حفظ نماهای مادی یا (materialized view) در موجودیت‌ها، برای زمان‌هایی است که فعالیت‌های خاصی در برنامه می‌تواند مقادیر و وضعیت موجودیت‌ها را  برای ادغام با سیستم های خارجی را دچار تغییر کند. برای مثال، یک سیستم می‌تواند یک materialized view را از تمام سفارش‌های مشتری که برای پر کردن بخش‌هایی از UI استفاده می‌شود، نگهداری کند. این برنامه سفارشات جدید را اضافه می کند یا آیتم‌های سفارشی را اضافه یا حذف می کند و اطلاعات مربوط حمل و نقل (shipping) را اضافه می کند. رویدادهایی که این تغییرات را توصیف می‌کنند، می‌توانند برای به‌روزرسانی [materialized view](https://learn.microsoft.com/en-us/azure/architecture/patterns/materialized-view) مدیریت و استفاده شوند.

در هر جایی این امکان برای برنامه‌ها وجود دارد که تاریخچه رویدادها را بخوانند. سپس می توانید از آن برای تحقق وضعیت فعلی یک موجودیت با پخش و مصرف تمام رویدادهای مربوط به آن موجودیت استفاده کنید. این فرآیند می تواند در صورت تقاضا برای تحقق یک شی دامنه در هنگام بررسی و پردازش به یک درخواست رخ دهد. همینطور این فرآیند از طریق یک کار زمان‌بندی شده(scheduled) اتفاق می‌افتد، به طوری که وضعیت موجودیت می‌تواند به‌عنوان یک materialized view ذخیره شود تا از لایه presentation پشتیبانی کند.

شکل زیر یک نمای کلی از این الگو را نشان می‌دهد، از جمله برخی از گزینه‌های مورد استفاده برای جریان رویداد یا event stream  (یک جریان رویداد یک دنباله مرتب از رویدادها است)  مواردی مانند:  ایجاد materialized view، ادغام رویدادها با برنامه‌ها و سیستم‌های خارجی و پخش مجدد رویدادها برای ایجاد پیش‌بینی وضعیت فعلی موجودیت‌های خاص است.


![[Pasted image 20231201231623.png]]

الگوی  Event Sourcing مزایای زیر را ارائه می دهد:

* رویدادها تغییر ناپذیر هستند و می‌توانند با استفاده از یک عملیات فقط افزودنی ذخیره شوند. رابط کاربری، گردش کار یا فرآیندی که یک رویداد را آغاز کرده است می‌تواند ادامه یابد و کارهایی که رویدادها را مدیریت می‌کنند می‌توانند در پس‌زمینه اجرا شوند. این فرآیند، همراه با این واقعیت که در طول پردازش تراکنش‌ها هیچ مغایرتی وجود ندارد، می‌تواند کارایی و مقیاس‌پذیری برنامه‌ها را به‌ویژه برای سطح presentation یا رابط کاربری بسیار بهبود بخشد.

>	نکته: یک ذخیره ساز یا ذخیره‌گاه یا data store یک مخزن دیجیتالی است که اطلاعات را در سیستم‌های کامپیوتری ذخیره و حفظ می‌کند. یک data store می‌تواند یک ذخیره‌سازی متصل به شبکه، یک ذخیره‌سازی ابری توزیع‌شده، یک درایو سخت فیزیکی یا یک ذخیره‌سازی مجازی باشد. این گزینه می‌تواند هم اطلاعات ساختاریافته مانند جداول اطلاعات و هم اطلاعات غیرساختاریافته مانند ایمیل‌ها، تصاویر و ویدیوها را ذخیره کند. [سازمان‌ها از data store برای نگهداری، به اشتراک گذاری و مدیریت اطلاعات در سطح واحدهای کسب و کار استفاده می‌کنند](https://en.wikipedia.org/wiki/Data_store)

* رویدادها اشیاء ساده ای هستند که برخی از اقدامات انجام شده را به همراه هر داده مرتبطی که برای توصیف عمل نمایش داده شده توسط رویداد مورد نیاز است، توصیف می کنند. رویدادها مستقیماً یک ذخیره‌ساز داده  (data store) را به روزرسانی نمی کنند. آنها به سادگی برای جابجایی در زمان مناسب ثبت می شوند. استفاده از رویدادها می تواند پیاده سازی و مدیریت را ساده کند.

* رویدادها معمولاً برای متخصص در حوزه data enginner معنی دارند، در حالی که عدم تطابق رابطه شی - رابطه (object-relational) می تواند جداول پایگاه داده پیچیده را به سختی تحلیل کند. جدول‌ها معمولا دارای ساختارهای مصنوعی هستند که وضعیت فعلی سیستم را نشان می دهند، نه رویدادهایی که در سیستم رخ داده اند.

*  Event Sourcing می‌تواند به جلوگیری از ایجاد تداخل به‌روزرسانی‌های همزمان کمک کند، زیرا از نیاز به به‌روزرسانی مستقیم اشیاء در data store جلوگیری می‌کند. با این حال، domain model همچنان باید به گونه‌ای طراحی شود که از خود در برابر درخواست‌هایی که ممکن است منجر به وضعیت ناسازگار شود، محافظت کند.

* استفاده از ذخیره‌سازی الحاقی (append-only storage) پیگیری رویدادهای یک مسیر قابل ردیابی را فراهم می‌کند که می‌توان از آن برای نظارت یا مانیتورینگ بر اقدامات انجام شده روی یک ذخیره‌سازی داده استفاده کرد. می‌توان با پخش مجدد رویدادها در هر زمان دلخواه، وضعیت فعلی را به‌عنوان یک materialized views بازسازی کند که در نهایت می‌تواند به تست و اشکال‌زدایی سیستم کمک کند. علاوه بر این، الزام به استفاده از رویدادهای جبران‌کننده (materialized views) برای لغو تغییرات می‌تواند تاریخچه‌ای از تغییراتی را ارائه دهد. همینطور اگر مدل فقط حالت فعلی را ذخیره می کرد،  امکان بازگشت به رویداد گذشته وجود نداشت. لیست رویدادها همچنین می تواند برای تجزیه و تحلیل عملکرد برنامه و تشخیص روندهای رفتار کاربر استفاده شود یا می توان از آن برای به دست آوردن اطلاعات مفید تجاری دیگر استفاده کرد.

* در واقع ذخیره‌گاه رویداد  امکان وقوع  رویدادها را افزایش می دهد و تسک‌ها در پاسخ به آن رویدادها عملیات خاص خود را انجام می دهند. این جداسازی وظایف از رویدادها، امکان انعطاف پذیری(flexibility) و توسعه پذیری(extensibility) را فراهم می کند. تسک‌ها در مورد نوع رویداد و داده های رویداد مطلع هستند اما در مورد عملیاتی که رویداد را آغاز کرده است، اطلاعاتی ندارند. علاوه بر این، چندین تسک می‌تواند هر رویداد را مدیریت کند. این امکان ادغام آسان با سایر سرویس ها و سیستم هایی را فراهم می کند که فقط به رویدادهای جدید مطرح شده توسط event store گوش می دهند. با این حال، رویدادهای  Event Sourcing معمولا سطح بسیار پایینی دارند و ممکن است لازم باشد به جای آن رویدادهای یکپارچه سازی خاصی ایجاد شود.

>	 Event Sourcing معمولا با الگوی CQRS با انجام تسک‌های مدیریت داده در پاسخ به رویدادها و با materializing viewها از طریق رویدادهای ذخیره شده ترکیب می شود.



### مسائل و ملاحظات

هنگام تصمیم گیری در مورد نحوه اجرای این الگو به نکات زیر توجه کنید:  
  
سیستم فقط زمانی به طور پایداری نهایی یا eventually consistent ( برای توضیح بیشتر این مورد به فصل مقدمه رجوع کنید) می‌شود که با بازپخش رویدادها، نماهای مادی شده یا پیش‌بینی‌هایی از داده‌ها را ایجاد کند. بین اینکه یک برنامه رویدادهایی را به عنوان نتیجه رسیدگی به یک درخواست به ذخیره ساز رویداد اضافه کند، رویدادها منتشر شوند و مصرف‌کنندگان رویدادها آن‌ها را پردازش کنند، تأخیری وجود دارد. در این دوره، رویدادهای جدیدی که تغییرات بیشتری را در موجودیت‌ها توصیف می‌کنند، ممکن است به ذخیره‌گاه رویداد رسیده باشند. سیستم باید طوری طراحی شود که در این سناریوها با پایداری نهایی سازگار باشد.



```
توجه داشته باشید  
  
برای اطلاعات در مورد سازگاری شرطی (eventual consistency) به [Data Consistency Primer](https://learn.microsoft.com/en-us/previous-versions/msp-n-p/dn589800(v=pandp.10)) یا فصل مقدمه مراجعه کنید.

```


یک ذخیره‌گاه رویداد در واقع یک منبع دائمی از اطلاعات است و بنابراین داده های رویداد هرگز نباید به روزرسانی شوند. تنها راه برای به‌روزرسانی یک موجودیت برای لغو تغییرات یا افزودن یک رویداد جبران‌کننده جدید به ذخیره‌گاه است. اگر قالب یا فرمت رویدادهایی با ماندگاری زیاد، نیاز به تغییر داشته باشد، شاید در طول مرحله مهاجرت(migration)، ترکیب رویدادهای موجود در ذخیره‌گاه با نسخه جدید دشوار باشد. ممکن است لازم باشد همه رویدادهایی که تغییرات ایجاد می‌کنند تکرار شوند تا با فرمت جدید مطابقت داشته باشند یا باید رویدادهای جدیدی اضافه کنید که از فرمت جدید استفاده می‌کنند. برای حفظ هر دو فرمت رویداد قدیمی و جدید، از یک version stamp در هر نسخه از طرح رویداد (event schema) استفاده کنید.

برنامه های چند رشته ای (Multi-threaded) و چند نمونه (multiple instances) از برنامه‌ها ممکن است رویدادها را در ذخیره‌گاه داده یا event store ذخیره کنند. سازگاری رویدادها در event store بسیار مهم است، مانند ترتیب رویدادهایی که بر یک موجودیت خاص تأثیر می‌گذارند (ترتیبی که تغییرات روی یک موجودیت رخ می‌دهد بر وضعیت فعلی آن تأثیر می‌گذارد). افزودن timestamp به هر رویداد می تواند به جلوگیری از این مشکلات کمک کند. یکی دیگر از روش های رایج، حاشیه نویسی(annotate) هر رویداد ناشی از یک درخواست با یک شناسه افزایشی (incremental identifier) است. اگر دو اقدام برای افزودن رویدادها برای یک موجودیت به طور همزمان تلاش کنند، ذخیره‌گاه رویداد می‌تواند رویدادی را که با شناسه موجودیت یا entity خاص از قبل وجود داشته و با
شناسه رویداد مطابقت دارد را رد کند.  
  
هیچ رویکرد استاندارد یا مکانیزم های موجود مانند کوئری‌های SQL برای خواندن رویدادها برای به دست آوردن اطلاعات آن‌ها وجود ندارد. تنها داده ای که می توان استخراج کرد، جریانی از رویدادها با استفاده از یک شناسه رویداد ( event identifier ) به عنوان یک معیار است. شناسه رویداد معمولاً به موجودیت‌های جداگانه نگاشت می شود. وضعیت فعلی یک موجودیت را می توان تنها با پخش مجدد همه رویدادهایی که به آن مربوط می شود در برابر وضعیت اصلی آن موجودیت تعیین کرد.

طول هر جریان رویداد (event stream) بر مدیریت و به‌روزرسانی سیستم تأثیر می‌گذارد. اگر جریان‌ها (streamها) بزرگ هستند، در فواصل زمانی خاص مانند تعداد مشخصی از رویدادها، snapshot‌های فوری ایجاد کنید. وضعیت فعلی موجودیت را می توان از snapshot و با پخش مجدد هر رویدادی که پس از آن نقطه از زمان رخ داده است به دست آورد. برای اطلاعات بیشتر در مورد ایجاد snapshot از داده ها، به  [Primary-Subordinate Snapshot Replication](https://learn.microsoft.com/en-us/previous-versions/msp-n-p/ff650012(v=pandp.10)) مراجعه کنید.  
  
حتی اگر منبع رویداد یا  event source ( برای مطالعه بیشتر در مورد event source به بخش مقدمه روجوع کنید) شانس به‌روزرسانی‌های متناقض داده‌ها را به حداقل می‌رساند، برنامه همچنان باید بتواند با ناهماهنگی‌هایی که از پایداری نهایی (eventual consistency) و فقدان تراکنش‌ها ناشی می‌شود، مقابله کند. به عنوان مثال، رویدادی که نشان‌دهنده کاهش موجودی انبار است ممکن است در حین ثبت سفارش برای آن کالا به ذخیره‌گاه داده برسد. این وضعیت منجر به نیاز به تطبیق این دو عملیات، یا از طریق مشاوره به مشتری یا ایجاد یک برگشت خوردن سفارش  می‌شود.
  
انتشار رویداد (Event publication) ممکن است حداقل یک بار رخ داده باشد، بنابراین مصرف کنندگان رویدادها باید [idempotent](https://en.wikipedia.org/wiki/Idempotence) باشند (@@@ یک عملیات در نرم‌افزار زمانی idempotent است که انجام چندین بار آن تأثیر یکسانی را داشته باشد. به عبارت دیگر، نتیجهٔ یک عملیات idempotent مستقل از تعداد دفعاتی است که آن عملیات اجرا می‌شود). 
 اگر رویداد بیش از یک بار اجرا شود، در نتیجه آنها نباید به روز رسانی شرح داده شده در یک رویداد را دوباره اعمال کنند. چندین نمونه از یک مصرف کننده می تواند موجودیت خاصی را حفظ و تجمیع کند، مانند تعداد کل سفارش های انجام شده. فقط یک بار باید در افزایش تجمعی موفق شود و آن هم زمانی است که یک رویداد سفارشی رخ می دهد. در حالی که این نتیجه یک مشخصه کلیدی منبع رویداد یا event sourcing نیست، اما تصمیم معمول پیاده‌سازی است..  


ذخیره‌ساز رویداد یا event storage انتخاب شده باید از بار رویداد ایجاد شده توسط برنامه شما پشتیبانی کند.

> برای اطلاعات بیشتر به در مورد event storage به فصل مقدمه رجوع کنید

مراقب سناریوهایی باشید که در آن پردازش یک رویداد شامل ایجاد یک یا چند رویداد جدید می شود زیرا این امر می تواند باعث ایجاد یک حلقه بی نهایت شود.

## **چه زمانی از این الگو استفاده کنیم؟**

از این الگو در حالت زیر استفاده کنید:  
  
* زمانی که می‌خواهید هدف یا دلیلی را در داده ها ثبت کنید. به عنوان مثال، تغییرات یک customer entity را می توان به عنوان یک سری از انواع رویدادهای خاص، مثلا برای داده‌های فردی که در پایگاه داده ثبت شده است مواردی مثل؛ تغییر محل سکونت، حساب بسته، یا متوفی را ثبت کرد.  
  
* زمانی که برای به حداقل رساندن یا  اجتناب کردن از به روز رسانی داده‌ها که ممکن است منجر به تداخل داده‌ای شود، ضروری است.  
  
* هنگامی که می خواهید رویدادهایی را که رخ می‌دهند ضبط کنید سپس آنها را دوباره پخش کنید تا وضعیت یک سیستم بازیابی شود یا تغییرات را به عقب برگردانید (roll back)  یا لاگ و گزارش خاصی را نگه دارید. به عنوان مثال، هنگامی که یک کار شامل چندین مرحله است، ممکن است لازم باشد اقداماتی را برای بازگرداندن به‌روزرسانی‌ها انجام دهید و سپس برخی از مراحل را مجدداً پخش کنید تا داده‌ها به حالت ثابت بازگردند.  
  
*  استفاده از رویداد‌ها برابر با یک ویژگی طبیعی و عملکردی هر برنامه‌ای است و به توسعه یا تلاش اضافی کمتری نیاز دارد.  
  
* زمانی که نیاز دارید فرآیند ورودی یا به‌روزرسانی داده‌ها را از تسک‌های مورد نیاز برای استفاده از این عملیات جدا سازی کنید. این تغییر ممکن است برای بهبود عملکرد رابط کاربری یا توزیع رویدادها به سایر شنوندگانی(listeners) باشد که هنگام وقوع رویدادها، فعالیت خاصی را انجام می دهند. به عنوان مثال، می توانید یک سیستم حقوق و دستمزد را با یک وب سایت اظهارنامه مالی ادغام کنید. رویدادهایی که توسط ذخیره‌ساز رویداد (event store) در پاسخ به به روز رسانی داده های ایجاد شده در وب سایت مطرح می شود که  توسط وب سایت و  سیستم حقوق و دستمزد استفاده می شود.  
  
* هنگامی که می‌خواهید ویژگی انعطاف‌پذیری(flexibility) در برنامه را داشته باشید تا بتوانید فرمت materialized  مدل‌ها و داده‌های entity  را در صورت تغییر نیازمندی‌ها تغییر دهید، یا - وقتی با CQRS استفاده می‌شود - باید یک read model یا viewهایی را که داده‌ها را نشان می‌دهند تطبیق دهید.  
  
* هنگامی که با الگوی CQRS استفاده می شود، استفاده از سازگاری شرطی(eventual consistency) قابل قبول است به خصوص زمانی که read model به روزرسانی می‌شود. 


این الگو ممکن است در شرایط زیر مفید نباشد:  
  
* برنامه‌های کوچک یا ساده، سیستم‌هایی که business logic کمی دارند یا اصلاً logic ندارند یا سیستم‌های که با مکانیزم‌های مدیریت داده‌های سنتی CRUD به خوبی کار می‌کنند.  
  
* سیستم‌هایی که در آنها به‌روزرسانی‌های بی‌درنگ و سازگاری زیاد برای داده‌ها مورد نیاز است.  
  
* سیستم‌هایی که در آن ردیابی اجرای برنامه، تاریخچه عملکرد برنامه و قابلیت‌هایی برای roll back و اجرای مجدد فعالیت‌های برنامه، ضروری نیست.  
  
* سیستم‌هایی که در آن‌ها احتمال تداخل و تضاد هنگام  به‌روزرسانی داده‌ها کم است. به عنوان مثال، سیستم هایی که عمدتاً داده‌ها را به جای به روز رسانی وضعیت آن داده‌ها، به صورت تکراری آن ها داده‌ها را اضافه می کنند.

## مثال

یک سیستم مدیریت کنفرانس نیاز به ردیابی تعداد رزروهای تکمیل شده برای یک کنفرانس دارد. به این ترتیب وقتی یک شرکت کننده  سعی می کند موردی را رزرو کند، می تواند بررسی کند که آیا هنوز صندلی خالی در دسترس است؟ این سیستم می تواند تعداد کل رزروهای یک کنفرانس را حداقل به دو روش ذخیره کند:

* این سیستم می تواند اطلاعات مربوط به تعداد کل رزروها را به عنوان یک موجودیت جداگانه در پایگاه داده ای که اطلاعات رزرو را در خود نگه می دارد، ذخیره کند. همانطور که رزرو انجام می شود یا لغو می شود، سیستم می تواند این تعداد را در صورت لزوم افزایش یا کاهش دهد. این رویکرد از نظر تئوری ساده است، اما اگر تعداد زیادی از شرکت‌کنندگان در تلاش برای رزرو صندلی در مدت زمان کوتاهی باشند، می‌تواند باعث مشکلات مقیاس‌پذیری شود. به عنوان مثال، در لحظات مربوط به آخرین روز یا  قبل از بسته شدن دوره رزرو دچار خطا شود.  
  
* این سیستم می تواند اطلاعات مربوط به رزرو و لغو را به عنوان رویدادهایی که در event store برگزار می شود ذخیره کند. سپس می‌تواند تعداد صندلی‌های موجود را با پخش مجدد این رویدادها محاسبه کند. این رویکرد به دلیل تغییر ناپذیری رویدادها می تواند مقیاس پذیرتر باشد. سیستم فقط باید بتواند داده ها را از event store بخواند یا داده ها را به event store اضافه کند. اطلاعات رویداد در مورد رزرو و لغو آن هرگز اصلاح نمی‌شود.

نمودار زیر نشان می دهد که چگونه می توان زیرسیستم رزرو صندلی سیستم مدیریت کنفرانس را با استفاده از  Event Sourcing پیاده سازی کرد.

![[Pasted image 20231201232220.png]]

ترتیب اقدامات برای رزرو دو صندلی به شرح زیر است:

1- رابط کاربری دستور رزرو صندلی برای دو شرکت کننده را صادر می کند. فرمان توسط یک کنترل کننده فرمان جداگانه مدیریت می شود. همینطور بخشی از منطق برنامه که از رابط کاربری جدا شده و مسئول رسیدگی به درخواست های ارسال شده به عنوان دستورات است.  
  
2- مجموعه‌ای حاوی اطلاعات مربوط به تمام رزروهای کنفرانس با پرس و جو از رویدادهایی که رزروها و لغوها را توصیف می کنند ساخته می شود. این مجموعه  `SeatAvailability` نامیده می شود و در یک  domain model قرار می گیرد که روش هایی را برای پرس و جو و اصلاح داده ها در مجموعه نشان می دهد.

> برخی از بهینه‌سازی‌هایی که باید در نظر گرفته شوند، استفاده از snapshotها (به‌طوری که نیازی به پرس‌وجو یا کوئری و پخش مجدد فهرست کامل رویدادها برای به دست آوردن وضعیت فعلی مجموع نباشید)، و نگهداری یک کپی ذخیره‌شده از جمع، بیانگر حالت های مختلف در حافظه است.


3- کنترل کننده فرمان روشی را فراخوانی می کند که توسط  domain model نمایش داده شده است تا رزروها را انجام دهد.  
  
4- مجموع  `SeatAvailability` رویدادی را ثبت می‌کند که شامل تعداد صندلی‌های رزرو شده است. دفعه بعد که مجموع رویدادها را اعمال می کند، از همه رزروها برای محاسبه تعداد صندلی های باقی مانده استفاده می شود.  
  
5- سیستم رویداد جدید را به لیست رویدادهای event store اضافه می‌کند.

اگر کاربر یک صندلی را لغو کند، سیستم فرآیند مشابهی را دنبال می‌کند به جز اینکه کنترل‌کننده فرمان دستوری را صادر می‌کند که یک رویداد لغو صندلی ایجاد می‌کند و آن را به event store اضافه می‌کند.  
  
استفاده از event store علاوه بر فراهم کردن زمینه بیشتر برای مقیاس پذیری، تاریخچه کامل یا دنباله قابل ردیابی از رزروها و لغوهای یک کنفرانس را نیز ارائه می دهد. event store مربوط رویدادها گزینه دقیقی است. نیازی به تداوم انباشته ها به روش دیگری نیست زیرا سیستم می تواند به راحتی رویدادها را دوباره پخش کند و وضعیت را به هر نقطه از زمان بازگرداند.

> اطلاعات بیشتر در مورد این مثال را می توانید در معرفی Event Sourcing در مقدمه این فصل بیابید.

## قدم بعدی


* عدم تطابق رابطه شی - رابطه ای یا [Object-relational impedance mismatch](https://en.wikipedia.org/wiki/Object-relational_impedance_mismatch) 
  
* [Data Consistency Primer](https://learn.microsoft.com/en-us/previous-versions/msp-n-p/dn589800(v=pandp.10)). هنگامی که از [Event Sourcing](https://learn.microsoft.com/en-us/previous-versions/msp-n-p/jj591559(v=pandp.10)) با یک read store جداگانه یا materialized views استفاده می کنید، داده های خوانده شده معمولا به صورت لحظه‌ای پایدار نیستند. در عوض، داده‌ها فقط در حال شرطی پایدار (eventually consistent) خواهند بود. این مقاله مسائل مربوط به حفظ ثبات در داده های توزیع شده را خلاصه می کند.  
  
* [Data Partitioning Guidance](https://learn.microsoft.com/en-us/previous-versions/msp-n-p/dn589795(v=pandp.10)). هنگامی که از [Event Sourcing](https://learn.microsoft.com/en-us/previous-versions/msp-n-p/jj591559(v=pandp.10)) برای بهبود مقیاس پذیری، کاهش تداخل‌ها و بهینه سازی کارایی برنامه استفاده می کنید، معمولا داده ها تقسیم بندی می شوند. این مقاله نحوه تقسیم داده ها به پارتیشن های مجزا و مسائلی که ممکن است ایجاد شود را شرح می دهد.  
  
وبلاگ مارتین فاولر:  
  
* - [Event Sourcing](https://martinfowler.com/eaaDev/EventSourcing.html)
* - [Snapshot on Martin Fowler's Enterprise Application Architecture website](https://martinfowler.com/eaaDev/Snapshot.html)

## منابع مرتبط

* الگوی [Command and Query Responsibility Segregation (CQRS) pattern](https://learn.microsoft.com/en-us/azure/architecture/patterns/cqrs). در واقع write store است که منبع دائمی اطلاعات را برای پیاده سازی CQRS فراهم می‌کند. که اغلب مبتنی بر پیاده سازی الگوی منبع یابی رویداد است. نحوه تفکیک عملیات خواندن داده ها در یک برنامه را از عملیات به روز رسانی داده‌ها با استفاده از رابط های جداگانه توضیح می‌دهد.  
  
* [Materialized View pattern](https://learn.microsoft.com/en-us/azure/architecture/patterns/materialized-view). ذخیره داده مورد استفاده در سیستمی که مبتنی بر - [Event Sourcing](https://martinfowler.com/eaaDev/EventSourcing.html) است، معمولاً برای کوئری های کارآمد و دقیق مناسب نیست. درعوض، یک رویکرد رایج این است که در فواصل زمانی منظم یا زمانی که داده‌ها تغییر می‌کنند، viewهای از پیش ساخته شده داده‌ها را تولید شود.  
  
* الگوی تراکنش جبرانی ([Compensating Transaction pattern](https://learn.microsoft.com/en-us/azure/architecture/patterns/compensating-transaction)). داده‌های موجود در event sourcing store به‌روزرسانی نمی‌شود. در عوض، ورودی‌های جدیدی اضافه می‌شوند که وضعیت موجودیت‌ها را به مقادیر جدید انتقال می‌دهند. برای معکوس کردن یک تغییر، از ورودی های جبرانی استفاده می شود زیرا امکان معکوس کردن تغییر قبلی وجود ندارد. در واقع این مورد نحوه واگرد کاری که توسط عملیات قبلی انجام شده است را شرح می دهد.
