به جای ذخیره  وضعیت فعلی داده ها در یک حوزه، از یک store در حالت فقط افزودنی (append-only) برای ثبت مجموعه کامل اقدامات انجام شده روی داده‌ها استفاده کنید. store به عنوان سیستم ثبت داده‌ها عمل می کند و می تواند برای تحقق domain objectها استفاده شود. این ویژگی می‌تواند تسک‌ها را در حوزه‌های پیچیده، با اجتناب از نیاز به همگام‌سازی مدل داده و حوزه business، ساده‌سازی کند، در حالی که performance، مقیاس‌پذیری(scalability) و پاسخ‌دهی(responsiveness) را بهبود می‌بخشد. همچنین این ویژگی می‌تواند یکپارچگی برای داده‌های مربوط به تراکنش‌های مختلف را فراهم کند.

## Context and problem

بیشتر برنامه ها با انواع داده‌های مختلفی کار می کنند و رویکرد معمولی این است که برنامه بتواند وضعیت فعلی داده ها را با به روز رسانی آن ها در زمانی که کاربران با آن کار می کنند حفظ کند.. به عنوان مثال ، در مدل سنتی create, read, update,  delete (CRUD) یک فرآیند مربوط به داده ها می‌تواند اینطور باشد که؛ ابتدا خواندن داده های ذخیره شده انجام شود سپس ایجاد برخی از اصلاحات و تغییرات در آن انجام شود<mark style="background: #FF5582A6;"> و در ادامه  وضعیت فعلی داده ها با مقادیر جدید بروزرسانی شود، که اغلب با استفاده از تراکنش که داده ها را قفل می کنند این مورد انجام می‌شود.  
  </mark>
رویکرد CRUD محدودیت هایی زیر را دارد:

* سیستم‌های CRUD عملیات به‌روزرسانی را مستقیماً در برابر یک data store انجام می‌دهند. این عملیات می تواند عملکرد(performance) و پاسخگویی(responsiveness) را کاهش دهد و به دلیل سربار پردازشی که نیاز دارد، مقیاس پذیری(scalability) را محدود کند.  
  
* در یک حوزه مشترک با بسیاری از کاربران همزمان، تداخل بروزرسانی داده‌ها بیشتر محتمل است زیرا عملیات بروزرسانی فقط روی یک مورد از داده‌ها انجام می‌شود.  
  
* توجه به این موضوع که مکانیزم محافظتی دیگری وجود داشته باشد که جزئیات هر عملیات را در یک لاگ جداگانه ثبت کند.


## Solution

الگوی Event Sourcing رویکردی را برای مدیریت عملیات روی داده ها تعریف می کند که توسط یک توالی از رویدادها هدایت می شود که هر یک از آنها فقط در یک store ضمیمه ثبت می شوند. کد برنامه مجموعه‌ای از رویدادها را ارسال می‌کند که به طور ضروری هر عملی را که روی داده‌ها رخ داده است، به فروشگاه رویداد می‌فرستد، جایی که آنها ادامه دارند. هر رویداد نشان دهنده مجموعه ای از تغییرات در داده ها است (مانند AddedItemToOrder).

رویدادها در یک event store که به عنوان سیستم ثبت (منبع معتبر داده) در مورد وضعیت فعلی داده ها عمل می کند، باقی می مانند. event store معمولاً این رویدادها را منتشر می کند تا مصرف کنندگان بتوانند از آن مطلع شوند و در صورت نیاز بتوانند به آنها رسیدگی کنند. برای مثال، مصرف‌کنندگان می‌توانند وظایفی را آغاز کنند که عملیات‌های رویدادها را در سیستم‌های دیگر اعمال می‌کند، یا هر اقدام مرتبط دیگری را که برای تکمیل عملیات لازم است انجام دهند. توجه داشته باشید که کد برنامه ای که رویدادها را تولید می کند از سیستم هایی که در رویدادها مشترک هستند جدا شده است.

<mark style="background: #FF5582A6;">استفاده معمولی از رویدادهای منتشر شده توسط event store برای حفظ materialized viewها از موجودیت ها در حالتی است که فعالیت‌های خاصی در برنامه مقادیر آنها  برای ادغام با سیستم های خارجی را تغییر می‌دهد. ب</mark>رای مثال، یک سیستم می‌تواند یک materialized view از تمام سفارش‌های مشتری که برای پر کردن بخش‌هایی از UI استفاده می‌شود، حفظ کند. این برنامه سفارشات جدید را اضافه می کند، موارد سفارش را اضافه یا حذف می کند و اطلاعات حمل و نقل را اضافه می کند. رویدادهایی که این تغییرات را توصیف می‌کنند، می‌توانند برای به‌روزرسانی [materialized view](https://learn.microsoft.com/en-us/azure/architecture/patterns/materialized-view) مدیریت و استفاده شوند.

در هر نقطه، این امکان برای برنامه‌ها وجود دارد که تاریخچه رویدادها را بخوانند. سپس می توانید از آن برای تحقق وضعیت فعلی یک موجودیت با پخش و مصرف تمام رویدادهای مربوط به آن موجودیت استفاده کنید. این فرآیند می تواند در صورت تقاضا برای تحقق یک شی دامنه در هنگام رسیدگی به یک درخواست رخ دهد. ههمینطور این فرآیند از طریق یک کار زمان‌بندی شده اتفاق می‌افتد، به طوری که وضعیت موجودیت می‌تواند به‌عنوان یک materialized view ذخیره شود تا از لایه presentation پشتیبانی کند.

شکل زیر یک نمای کلی از الگو را نشان می‌دهد، از جمله برخی از گزینه‌های استفاده از جریان رویداد (event stream) مانند ایجاد materialized view، ادغام رویدادها با برنامه‌ها و سیستم‌های خارجی و پخش مجدد رویدادها برای ایجاد پیش‌بینی وضعیت فعلی موجودیت‌های خاص.


![[Pasted image 20231201231623.png]]

الگوی  Event Sourcing مزایای زیر را ارائه می دهد:


* رویدادها تغییر ناپذیر هستند و می‌توانند با استفاده از یک عملیات فقط افزودنی ذخیره شوند. رابط کاربری، گردش کار یا فرآیندی که یک رویداد را آغاز کرده است می‌تواند ادامه یابد و کارهایی که رویدادها را مدیریت می‌کنند می‌توانند در پس‌زمینه اجرا شوند. این فرآیند، همراه با این واقعیت که در طول پردازش تراکنش‌ها هیچ مناقشه‌ای وجود ندارد، می‌تواند کارایی و مقیاس‌پذیری برنامه‌ها را به‌ویژه برای سطح presentation یا رابط کاربری بسیار بهبود بخشد.

* رویدادها اشیاء ساده ای هستند که برخی از اقدامات انجام شده را به همراه هر داده مرتبطی که برای توصیف عمل نمایش داده شده توسط رویداد مورد نیاز است، توصیف می کنند. رویدادها مستقیماً یک data store را به روزرسانی نمی کنند. آنها به سادگی برای جابجایی در زمان مناسب ثبت می شوند. استفاده از رویدادها می تواند پیاده سازی و مدیریت را ساده کند.

* رویدادها معمولاً برای متخصص دامنه معنی دارند، در حالی که عدم تطابق رابطه شی - رابطه (object-relational) می تواند جداول پایگاه داده پیچیده را به سختی تحلیل کند. جداول ساختارهای مصنوعی هستند که وضعیت فعلی سیستم را نشان می دهند، نه رویدادهایی که رخ داده اند.

*  Event Sourcing می‌تواند به جلوگیری از ایجاد تداخل به‌روزرسانی‌های همزمان کمک کند، زیرا از نیاز به به‌روزرسانی مستقیم اشیاء در data store جلوگیری می‌کند. با این حال، domain model همچنان باید به گونه‌ای طراحی شود که از خود در برابر درخواست‌هایی که ممکن است منجر به وضعیت ناسازگار شود، محافظت کند.

* استفاده از ذخیره‌سازی الحاقی (append-only storage) پیگیری رویدادهای یک مسیر قابل ردیابی را فراهم می‌کند که می‌توان از آن برای نظارت یا مانیتورینگ بر اقدامات انجام شده روی یک ذخیره‌سازی داده استفاده کرد. می‌توان با پخش مجدد رویدادها در هر زمان دلخواه، وضعیت فعلی را به‌عنوان یک materialized views بازسازی کند که در نهایت می‌تواند به تست و اشکال‌زدایی سیستم کمک کند. علاوه بر این، الزام به استفاده از رویدادهای جبران‌کننده (materialized views) برای لغو تغییرات می‌تواند تاریخچه‌ای از تغییراتی را ارائه دهد. همینطور اگر مدل حالت فعلی را ذخیره می کرد، این قابلیت وجود نداشت. لیست رویدادها همچنین می تواند برای تجزیه و تحلیل عملکرد برنامه و تشخیص روندهای رفتار کاربر استفاده شود یا می توان از آن برای به دست آوردن اطلاعات مفید تجاری دیگر استفاده کرد.

* در واقع event store امکان وقوع  رویدادها را افزایش می دهد و تسک‌ها در پاسخ به آن رویدادها عملیات خاص خود را انجام می دهند. این جداسازی وظایف از رویدادها، انعطاف پذیری(flexibility) و گسترش(extensibility) را فراهم می کند. تسک در مورد نوع رویداد و داده های رویداد اطلاع دارند، اما در مورد عملیاتی که رویداد را آغاز کرده است، اطلاعاتی ندارند. علاوه بر این، چندین تسک می تواند هر رویداد را مدیریت کند. این امکان ادغام آسان با سایر سرویس ها و سیستم هایی را فراهم می کند که فقط به رویدادهای جدید مطرح شده توسط event store گوش می دهند. با این حال، رویدادهای  Event Sourcing معمولا سطح بسیار پایینی دارند و ممکن است لازم باشد به جای آن رویدادهای یکپارچه سازی خاصی ایجاد شود.

> Event Sourcing معمولا با الگوی CQRS با انجام تسک‌ها مدیریت داده در پاسخ به رویدادها و با materializing viewها از رویدادهای ذخیره شده ترکیب می شود.



## Issues and considerations

هنگام تصمیم گیری در مورد نحوه اجرای این الگو به نکات زیر توجه کنید:  
  
این سیستم در نهایت تنها در هنگام ایجاد materialized view یا تولید پیش بینی داده ها با پخش مجدد رویدادها، سازگار خواهد بود. بین افزودن رویدادها به event store در نتیجه رسیدگی به درخواست، رویدادهای منتشر شده و مصرف کنندگان رویدادها که آنها را مدیریت می کنند، مقداری تأخیر وجود دارد. در طول این دوره، رویدادهای جدیدی که تغییرات بیشتر در نهادها را توصیف می‌کنند ممکن است به event store رسیده باشند. این سیستم باید به گونه ای طراحی شود که سازگاری شرطی (eventual consistency) در این سناریوها را در نظر بگیرد.

```
توجه داشته باشید  
  
برای اطلاعات در مورد سازگاری شرطی (eventual consistency) به [Data Consistency Primer](https://learn.microsoft.com/en-us/previous-versions/msp-n-p/dn589800(v=pandp.10)) مراجعه کنید.
```


یک event store منبع دائمی اطلاعات است و بنابراین داده های رویداد هرگز نباید به روزرسانی شوند. تنها راه برای به‌روزرسانی یک موجودیت برای لغو تغییرات یا افزودن یک رویداد جبران‌کننده جدید به event store است. اگر فرمت (به‌جای داده‌ها) رویدادهای با ماندگاری زیاد، نیاز به تغییر داشته باشد، شاید در طول مرحله migration، ترکیب رویدادهای موجود در store با نسخه جدید دشوار باشد. ممکن است لازم باشد همه رویدادهایی که تغییرات ایجاد می‌کنند تکرار شوند تا با فرمت جدید مطابقت داشته باشند یا باید رویدادهای جدیدی اضافه کنید که از فرمت جدید استفاده می‌کنند. برای حفظ هر دو فرمت رویداد قدیمی و جدید، از یک version stamp در هر نسخه از schema رویداد استفاده کنید.

برنامه های چند رشته ای و چند نمونه (multiple instances) از برنامه ها ممکن است رویدادها را در event store ذخیره کنند. سازگاری رویدادها در event store بسیار مهم است، مانند ترتیب رویدادهایی که بر یک موجودیت خاص تأثیر می‌گذارند (ترتیبی که تغییرات روی یک موجودیت رخ می‌دهد بر وضعیت فعلی آن تأثیر می‌گذارد). افزودن timestamp به هر رویداد می تواند به جلوگیری از مشکلات کمک کند. یکی دیگر از روش های رایج، حاشیه نویسی هر رویداد ناشی از یک درخواست با یک شناسه افزایشی (incremental identifier) است. اگر دو اقدام برای افزودن رویدادها برای یک موجودیت به طور همزمان تلاش کنند، event store می‌تواند رویدادی را که با شناسه entity موجود و شناسه رویداد مطابقت دارد رد کند.  
  
هیچ رویکرد استاندارد یا مکانیزم های موجود مانند SQL queries برای خواندن رویدادها برای به دست آوردن اطلاعات آن‌ها وجود ندارد. تنها داده ای که می توان استخراج کرد، جریانی از رویدادها با استفاده از یک شناسه رویداد ( event identifier ) به عنوان یک معیار است. شناسه رویداد معمولاً به موجودیت‌های جداگانه نگاشت می شود. وضعیت فعلی یک موجودیت را می توان تنها با پخش مجدد همه رویدادهایی که به آن مربوط می شود در برابر وضعیت اصلی آن موجودیت تعیین کرد.

طول هر جریان رویداد(event stream) بر مدیریت و به‌روزرسانی سیستم تأثیر می‌گذارد. اگر جریان‌ها (streamها) بزرگ هستند، در فواصل زمانی خاص مانند تعداد مشخصی از رویدادها، snapshot‌های فوری ایجاد کنید. وضعیت فعلی موجودیت را می توان از snapshot و با پخش مجدد هر رویدادی که پس از آن نقطه از زمان رخ داده است به دست آورد. برای اطلاعات بیشتر در مورد ایجاد snapshot از داده ها، به  [Primary-Subordinate Snapshot Replication](https://learn.microsoft.com/en-us/previous-versions/msp-n-p/ff650012(v=pandp.10)) مراجعه کنید.  
  
حتی اگر event source شانس به‌روزرسانی‌های متناقض داده‌ها را به حداقل می‌رساند، برنامه همچنان باید بتواند با ناهماهنگی‌هایی که از ثبات شرطی(eventual consistency) و فقدان تراکنش‌ها ناشی می‌شود، مقابله کند. به عنوان مثال، رویدادی که نشان‌دهنده کاهش موجودی انبار است ممکن است در حین ثبت سفارش برای آن کالا به data store برسد. این وضعیت منجر به نیاز به تطبیق این دو عملیات، یا از طریق مشاوره به مشتری یا ایجاد یک برگشت خوردن سفارش  می‌شود.
  
انتشار رویداد (Event publication) ممکن است حداقل یک بار رخ داده باشد، بنابراین مصرف کنندگان رویدادها باید (https://en.wikipedia.org/wiki/Idempotence)[idempotent] باشند. اگر رویداد بیش از یک بار اجرا شود، در نتیجه آنها نباید به روز رسانی شرح داده شده در یک رویداد را دوباره اعمال کنند. <mark style="background: #FF5582A6;">چندین نمونه از یک مصرف کننده می تواند موجودیت خاصی را حفظ و جمع کند</mark>، مانند تعداد کل سفارش های انجام شده. فقط یک بار باید در افزایش تجمعی موفق شود و آن هم زمانی است که یک رویداد سفارشی رخ می دهد. در حالی که این نتیجه یک مشخصه کلیدی event sourcing نیست.  
  
event storage انتخاب شده باید از بار رویداد ایجاد شده توسط برنامه شما پشتیبانی کند.  
مراقب سناریوهایی باشید که در آن پردازش یک رویداد شامل ایجاد یک یا چند رویداد جدید می شود زیرا این امر می تواند باعث ایجاد یک حلقه بی نهایت شود.

###  When to use this pattern

از این الگو در سناریوهای زیر استفاده کنید:  
  
* زمانی که می خواهید منظور، هدف یا دلیلی را در داده ها ثبت کنید. به عنوان مثال، تغییرات یک customer entity را می توان به عنوان یک سری از انواع رویدادهای خاص، مانند خانه منتقل شده، حساب بسته، یا متوفی ثبت کرد.  
  
* زمانی که به حداقل رساندن یا کاملاً دوری کردن  از بروز به روز رسانی متناقض داده ها ضروری است.  
  
* هنگامی که می خواهید رویدادهایی را که رخ می دهند ضبط کنید سپس آنها را دوباره پخش کنید تا وضعیت یک سیستم بازیابی شود یا تغییرات را به عقب برگردانید (roll back)  یا لاگ و گزارش خاصی را نگه دارید. به عنوان مثال، هنگامی که یک کار شامل چندین مرحله است، ممکن است لازم باشد اقداماتی را برای بازگرداندن به‌روزرسانی‌ها انجام دهید و سپس برخی از مراحل را مجدداً پخش کنید تا داده‌ها به حالت ثابت بازگردند.  
  
*  استفاده از رویداد‌ها برابر با یک ویژگی طبیعی و عملکردی هر برنامه‌ای است و به توسعه یا تلاش اضافی کمتری نیاز دارد.  
  
* <mark style="background: #FF5582A6;">زمانی که نیاز دارید فرآیند ورودی یا به‌روزرسانی داده‌ها را از تسک‌های مورد نیاز برای استفاده از  این عملیات جدا کنید. این تغییر ممکن است برای بهبود عملکرد رابط کاربری یا توزیع رویدادها به سایر شنوندگانی(listeners) باشد که هنگام وقوع رویدادها اقدامی را انجام می دهند. </mark>به عنوان مثال، می توانید یک سیستم حقوق و دستمزد را با یک وب سایت ارسال هزینه ها ادغام کنید. رویدادهایی که توسط فروشگاه رویداد در پاسخ به به روز رسانی داده های ایجاد شده در وب سایت مطرح می شود، هم توسط وب سایت و هم سیستم حقوق و دستمزد استفاده می شود.  
  
* هنگامی که می‌خواهید ویژگی انعطاف‌پذیری(flexibility) در برنامه را داشته باشید تا بتوانید فرمت materialized modelها و entity data را در صورت تغییر نیازمندی‌ها تغییر دهید، یا - وقتی با CQRS استفاده می‌شود - باید یک مدل خوانده شده یا نماهایی را که داده‌ها را نشان می‌دهند تطبیق دهید.  
  
* هنگامی که با CQRS استفاده می شود، سازگاری شرطی قابل قبول (entity data) است به خصوص زمانی که read model به روزرسانی می‌شود. 


این الگو ممکن است در شرایط زیر مفید نباشد:  
  
* برنامه‌های کوچک یا ساده، سیستم‌هایی که business logic کمی دارند یا اصلاً logic ندارند یا سیستم‌های  که  با مکانیزم‌های مدیریت داده‌های سنتی CRUD به خوبی کار می‌کنند.  
  
* سیستم‌هایی که در آنها به‌روزرسانی‌های بی‌درنگ و سازگاری برای  داده‌ها مورد نیاز است.  
  
* سیستم‌هایی که در آن ردیابی اجرای برنامه، تاریخچه عملکرد برنامه  و قابلیت‌هایی برای roll back و اجرای مجدد فعالیت‌های برنامه، ضروری نیست.  
  
* سیستم‌هایی که در آن‌ها احتمال تداخل و تضاد هنگام  به‌روزرسانی  داده‌ها کم است. به عنوان مثال، سیستم هایی که عمدتاً داده ها را به جای به روز رسانی وضعیت آن داده‌های، مجدد داده ها را اضافه می کنند.

## Example

یک سیستم مدیریت کنفرانس نیاز به ردیابی تعداد رزروهای تکمیل شده برای یک کنفرانس دارد. به این ترتیب وقتی یک شرکت کننده بالقوه سعی می کند رزرو کند، می تواند بررسی کند که آیا هنوز صندلی در دسترس است یا خیر. این سیستم می تواند تعداد کل رزروهای یک کنفرانس را حداقل به دو روش ذخیره کند:

* این سیستم می تواند اطلاعات مربوط به تعداد کل رزروها را به عنوان یک موجودیت جداگانه در پایگاه داده ای که اطلاعات رزرو را در خود نگه می دارد، ذخیره کند. همانطور که رزرو انجام می شود یا لغو می شود، سیستم می تواند این تعداد را در صورت لزوم افزایش یا کاهش دهد. این رویکرد از نظر تئوری ساده است، اما اگر تعداد زیادی از شرکت‌کنندگان در تلاش برای رزرو صندلی در مدت زمان کوتاهی باشند، می‌تواند باعث مشکلات مقیاس‌پذیری شود. به عنوان مثال، در لحظات مربوط به آخرین روز یا  قبل از بسته شدن دوره رزرو.  
  
* این سیستم می تواند اطلاعات مربوط به رزرو و لغو را به عنوان رویدادهایی که در event store برگزار می شود ذخیره کند. سپس می‌تواند تعداد صندلی‌های موجود را با پخش مجدد این رویدادها محاسبه کند. این رویکرد به دلیل تغییر ناپذیری رویدادها می تواند مقیاس پذیرتر باشد. سیستم فقط باید بتواند داده ها را از event store بخواند یا داده ها را به event store اضافه کند. اطلاعات رویداد در مورد رزرو و لغو هرگز اصلاح نمی شود.


نمودار زیر نشان می دهد که چگونه می توان زیرسیستم رزرو صندلی سیستم مدیریت کنفرانس را با استفاده از  Event Sourcing پیاده سازی کرد.

![[Pasted image 20231201232220.png]]

ترتیب اقدامات برای رزرو دو صندلی به شرح زیر است:

1- رابط کاربری دستور رزرو صندلی برای دو شرکت کننده را صادر می کند. فرمان توسط یک کنترل کننده فرمان جداگانه مدیریت می شود. همینطور بخشی از منطق برنامه که از رابط کاربری جدا شده و مسئول رسیدگی به درخواست های ارسال شده به عنوان دستورات است.  
  
2- مجموعه ای حاوی اطلاعات مربوط به تمام رزروهای کنفرانس با پرس و جو از رویدادهایی که رزروها و لغوها را توصیف می کنند ساخته می شود. این مجموعه  `SeatAvailability` نامیده می شود و در یک  domain model قرار می گیرد که روش هایی را برای پرس و جو و اصلاح داده ها در مجموعه نشان می دهد.

> برخی از بهینه‌سازی‌هایی که باید در نظر گرفته شوند، استفاده از snapshotها (به‌طوری که نیازی به پرس‌وجو و پخش مجدد فهرست کامل رویدادها برای به دست آوردن وضعیت فعلی مجموع نباشید)، و نگهداری یک کپی ذخیره‌شده از جمع، بیانگر حالت های مختلف در حافظه است.


3- کنترل کننده فرمان روشی را فراخوانی می کند که توسط  domain model نمایش داده شده است تا رزروها را انجام دهد.  
  
4- مجموع  `SeatAvailability` رویدادی را ثبت می‌کند که شامل تعداد صندلی‌های رزرو شده است. دفعه بعد که مجموع رویدادها را اعمال می کند، از همه رزروها برای محاسبه تعداد صندلی های باقی مانده استفاده می شود.  
  
5- سیستم رویداد جدید را به لیست رویدادهای event store اضافه می کند.

اگر کاربر یک صندلی را لغو کند، سیستم فرآیند مشابهی را دنبال می‌کند به جز اینکه کنترل‌کننده فرمان دستوری را صادر می‌کند که یک رویداد لغو صندلی ایجاد می‌کند و آن را به event store اضافه می‌کند.  
  
استفاده از event store علاوه بر فراهم کردن زمینه بیشتر برای مقیاس پذیری، تاریخچه کامل یا دنباله قابل ردیابی از رزروها و لغوهای یک کنفرانس را نیز ارائه می دهد. event store مربوط رویدادها گزینه دقیقی است. نیازی به تداوم انباشته ها به روش دیگری نیست زیرا سیستم می تواند به راحتی رویدادها را دوباره پخش کند و وضعیت را به هر نقطه از زمان بازگرداند.

> اطلاعات بیشتر در مورد این مثال را می توانید در معرفی [Event Sourcing](https://learn.microsoft.com/en-us/previous-versions/msp-n-p/jj591559(v=pandp.10)) بیابید.

## Next steps


* عدم تطابق رابطه شی - رابطه ای (- [Object-relational impedance mismatch](https://en.wikipedia.org/wiki/Object-relational_impedance_mismatch))  
  
* [Data Consistency Primer](https://learn.microsoft.com/en-us/previous-versions/msp-n-p/dn589800(v=pandp.10)). هنگامی که از [Event Sourcing](https://learn.microsoft.com/en-us/previous-versions/msp-n-p/jj591559(v=pandp.10)) با یک store خواندنی جداگانه یا materialized views استفاده می کنید، داده های خوانده شده معمولا به صورت لحظه‌ای پایدار نیستند. در عوض، داده‌ها فقط در حال شرطی پایدار (eventually consistent) خواهند بود. این مقاله مسائل مربوط به حفظ ثبات در داده های توزیع شده را خلاصه می کند.  
  
* ر[Data Partitioning Guidance](https://learn.microsoft.com/en-us/previous-versions/msp-n-p/dn589795(v=pandp.10)). هنگامی که از [Event Sourcing](https://learn.microsoft.com/en-us/previous-versions/msp-n-p/jj591559(v=pandp.10)) برای بهبود مقیاس پذیری، کاهش درگیری و بهینه سازی کارایی برنامه استفاده می کنید، اغلب داده ها تقسیم بندی می شوند. این مقاله نحوه تقسیم داده ها به پارتیشن های مجزا و مسائلی که ممکن است ایجاد شود را شرح می دهد.  
  
وبلاگ مارتین فاولر:  
  
* - [Event Sourcing](https://martinfowler.com/eaaDev/EventSourcing.html)
* - [Snapshot on Martin Fowler's Enterprise Application Architecture website](https://martinfowler.com/eaaDev/Snapshot.html)

## Related resources

* الگوی [Command and Query Responsibility Segregation (CQRS) pattern](https://learn.microsoft.com/en-us/azure/architecture/patterns/cqrs). در واقع write store است که منبع دائمی اطلاعات را برای پیاده سازی CQRS فراهم می کند. که اغلب مبتنی بر پیاده سازی الگوی منبع یابی رویداد است. نحوه تفکیک عملیات خواندن داده ها در یک برنامه را از عملیات به روز رسانی داده ها با استفاده از رابط های جداگانه توضیح می دهد.  
  
* [Materialized View pattern](https://learn.microsoft.com/en-us/azure/architecture/patterns/materialized-view). ذخیره داده مورد استفاده در سیستمی که مبتنی بر - [Event Sourcing](https://martinfowler.com/eaaDev/EventSourcing.html) است، معمولاً برای جستجوی کارآمد مناسب نیست. درعوض، یک رویکرد رایج این است که در فواصل زمانی منظم یا زمانی که داده ها تغییر می کنند، نماهای از پیش پرجمعیت داده ها تولید شود.  
  
* الگوی تراکنش جبرانی ([Compensating Transaction pattern](https://learn.microsoft.com/en-us/azure/architecture/patterns/compensating-transaction)). داده‌های موجود در event sourcing store به‌روزرسانی نمی‌شود. در عوض، ورودی‌های جدیدی اضافه می‌شوند که وضعیت موجودیت‌ها را به مقادیر جدید انتقال می‌دهند. برای معکوس کردن یک تغییر، از ورودی های جبرانی استفاده می شود زیرا امکان معکوس کردن تغییر قبلی وجود ندارد. در واقع این مورد نحوه واگرد کاری که توسط عملیات قبلی انجام شده است را شرح می دهد.
