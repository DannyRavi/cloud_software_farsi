مصرف منابع مورد استفاده توسط یک نمونه از یک application، یک tenant شخصی یا یک سرویس  را کنترل کنید. این می تواند به سیستم اجازه دهد تا به وظایف خود به درستی ادامه دهد و نیازمندی های سطح سرویس را برآورده کند، حتی زمانی که افزایش بار، فشار شدیدی را بر مصرف منابع وارد می کند.

## Context and problem

بار روی یک برنامه ابری معمولاً در طول زمان بر اساس تعداد کاربران فعال یا نوع فعالیت هایی که انجام می دهند متفاوت است. به عنوان مثال، احتمالاً کاربران بیشتری در طول ساعات کاری فعال هستند، یا ممکن است سیستم در پایان هر ماه نیاز به انجام تجزیه و تحلیل های محاسباتی پرهزینه‌ای داشته باشد. همچنین ممکن است انفجارهای ناگهانی و غیرمنتظره در فعالیت ها وجود داشته باشد. اگر نیازهای پردازشی سیستم از ظرفیت منابع موجود بیشتر شود، از کارایی سیستم کاسته می‌شود و حتی ممکن است سیستم از کار بیفتد. اگر سیستم باید نیازمندی های سطح سرویس مورد نظر را برآورده کند، چنین شکستی می تواند غیرقابل قبول باشد.

بسته به اهداف تجاری برنامه، استراتژی‌های زیادی برای مدیریت بارهای مختلف در فضای ابری وجود دارد. یک استراتژی استفاده از مقیاس خودکار ([autoscaling](https://learn.microsoft.com/en-us/azure/architecture/best-practices/auto-scaling)) برای تطبیق منابع ارائه شده با نیازهای کاربر در هر زمان معین است. این مورد پتانسیل زیادی را دارد که به طور مداوم تقاضای کاربر را برآورده کند، در حالی که هزینه های جاری را بهینه می کند. با این حال، در حالی که autoscaling می‌تواند باعث تامین منابع اضافی شود، این تامین منابع فوری نیست. اگر تقاضا به سرعت رشد کند، ممکن است یک پنجره زمانی وجود داشته باشد که در آن کسری منابع وجود داشته باشد.
## Solution

این سیستم می‌تواند چندین استراتژی throttling را اجرا کند، از جمله:

* رد درخواست‌های یک کاربر که قبلاً بیش از n بار در ثانیه در یک بازه زمانی معین به APIهای سیستم دسترسی داشته است. این امر مستلزم آن است که سیستم میزان استفاده از منابع را برای هر  tenant  یا کاربری که یک برنامه را اجرا می کند اندازه گیری کند. برای اطلاعات بیشتر، راهنمای سنجش سرویس ([Service Metering Guidance](https://learn.microsoft.com/en-us/previous-versions/msp-n-p/dn589796(v=pandp.10))) را ببینید.

* غیرفعال کردن یا کاهش کارایی سرویس های غیرضروری و کمتر لازم  به طوری که سرویس ضروری بتوانند بدون مانع با منابع کافی اجرا شوند. به عنوان مثال، اگر برنامه در حال پخش خروجی ویدیو باشد، می تواند به وضوح پایین تری تغییر کند.

* استفاده از سطح‌بندی بار (load leveling) برای هموارسازی حجم فعالیت (این رویکرد با جزئیات بیشتری توسط الگوی [Queue-based Load Leveling pattern](https://learn.microsoft.com/en-us/azure/architecture/patterns/queue-based-load-leveling)  پوشش داده شده است). در یک محیط  دارای چندین tenant، این رویکرد کارایی هر tenant را کاهش می دهد. اگر سیستم باید ترکیبی از tenantهایی با SLA های مختلف را پشتیبانی کند، کار برای tenantهای با ارزش ممکن است بلافاصله انجام شود. درخواست‌های tenantها دیگر را می‌توان متوقف کرد، و زمانی که عقب ماندگی تسک مورد کاهش یافت، رسیدگی شد. الگوی صف اولویت می تواند برای کمک به پیاده سازی این رویکرد استفاده شود، همانطور که می تواند endpointهای مختلف را برای سطوح/اولویت های سرویس مختلف نشان دهد.

* به تعویق انداختن عملیاتی که از طرف applicationها یا tenant با اولویت پایین تر انجام می شود. این عملیات را می توان به حالت تعلیق درآورد یا محدود کرد، به استثنای یک استثنا برای اطلاع tenant که سیستم مشغول است و این عملیات باید بعداً دوباره امتحان شود.

* هنگام ادغام با برخی از سرویس‌های شخص ثالث که ممکن است در دسترس نباشند یا با خطا مواجه شوند، باید مراقب باشید. تعداد درخواست‌های همزمان در حال پردازش را کاهش دهید تا لاگ‌ها بی جهت با موارد خطا پر نشوند. همچنین از هزینه‌های مرتبط با پردازش مجدد درخواست‌هایی که به دلیل آن سرویس های 3rd-party مواجه می‌شوند، اجتناب می‌کنید. سپس، هنگامی که درخواست‌ها با موفقیت پردازش شدند، به پردازش درخواست‌های معمولی بازگردید. یکی از کتابخانه هایی که این قابلیت را پیاده سازی می کند  [NServiceBus](https://docs.particular.net/nservicebus/recoverability/#automatic-rate-limiting) است.

شکل زیر نمودار ناحیه ای برای استفاده از منابع (ترکیبی از حافظه، CPU، پهنای باند و عوامل دیگر) را در برابر زمان برای برنامه هایی که از هز سه ویژگی استفاده می کنند نشان می دهد. یک ویژگی ناحیه ای از کارایی است، مانند مؤلفه ای که مجموعه خاصی از وظایف را انجام می دهد، قطعه کدی که محاسبات پیچیده ای را انجام می دهد، یا عنصری که سرویسی مانند کش در حافظه را ارائه می دهد. این ویژگی ها دارای برچسب های A، B و C هستند.

![[Pasted image 20231128230244.png]]


> این ناحیه بلافاصله زیر خط یک ویژگی مربوط به منابعی را نشان می دهد که برنامه ها هنگام فراخوانی این ویژگی ها از آنها استفاده می کنند. به عنوان مثال، ناحیه زیر خط برای ویژگی A، منابع استفاده شده توسط برنامه‌هایی را نشان می‌دهد که از ویژگی A استفاده می‌کنند و ناحیه بین خطوط برای ویژگی A و ویژگی B، منابع استفاده شده توسط برنامه‌ را با استفاده از ویژگی B را نشان می‌دهد. تجمیع مناطق برای هر ویژگی، استفاده کلی از منابع سیستم را نشان می دهد.


شکل قبلی اثرات عملیات به تعویق انداختن(deferring operations) را نشان می دهد. درست قبل از زمان T1، کل منابع تخصیص داده شده به همه برنامه ها با استفاده از این ویژگی ها به یک آستانه (محدودیت استفاده از منابع) می رسد. در این مرحله، application ها در خطر محدودیت منابع موجود هستند. در این سیستم، ویژگی B نسبت به ویژگی A یا ویژگی C از اهمیت کمتری برخوردار است، بنابراین به طور موقت غیرفعال می شود و منابعی که استفاده می کرد آزاد می شوند. بین زمان‌های T1 و T2، برنامه‌هایی که از ویژگی A و ویژگی C استفاده می‌کنند به طور عادی به کار خود ادامه می‌دهند. در نهایت، استفاده از منابع این دو ویژگی به حدی کاهش می یابد که در زمان T2، ظرفیت کافی برای فعال کردن مجدد ویژگی B وجود دارد.

رویکردهای مقیاس خودکار(autoscaling) و throttling همینطور می توانند برای کمک به واکنش گرا (responsive) بودن  برنامه ها با SLA ها ترکیب شوند. اگر چه انتظار می‌رود تقاضاب مصرف منابع همچنان بالا بماند، throttling یک راه‌حل موقت ارائه می‌کند تا در نتیجه سیستم scales out شود، . در این مرحله، کارایی کامل سیستم قابل بازیابی است.

شکل بعدی یک نمودار ناحیه ای از استفاده کلی از منابع توسط همه application ها در حال اجرا در یک سیستم در برابر زمان را نشان می دهد و نشان می دهد که چگونه throttling را می توان با autoscaling ترکیب کرد.

![[Pasted image 20231128230606.png]]

در زمان T1، آستانه تعیین شده‌ی رسیدن به حد استفاده از منابع رسیده است. در این مرحله، سیستم می تواند شروع به کوچک شدن مقیاس (scale out) کند. با این حال، اگر منابع جدید به سرعت در دسترس قرار نگیرند، ممکن است منابع موجود تمام شده و سیستم از کار بیفتد. برای جلوگیری از این اتفاق، سیستم به طور موقت، همانطور که قبلاً توضیح داده شد، خفه (throttled) می شود. هنگامی که autoscaling کامل شد و منابع اضافی در دسترس قرار گرفت، می توان خفه کن (throttling) را رها کرد.

## Issues and considerations

هنگام تصمیم گیری در مورد نحوه اجرای این الگو باید نکات زیر را در نظر بگیرید:

* خفه کردن (Throttling) یک برنامه و استراتژی مورد نظر وابسته به یک تصمیم گیری در زمینه معماری سیستم است که کل طراحی یک سیستم را تحت تاثیر قرار می دهد. Throttling باید در مراحل اولیه طراحی برنامه در نظر گرفته شود زیرا اضافه کردن آن پس از پیاده سازی یک سیستم آسان نیست.

* خفه کردن (Throttling)  باید به سرعت انجام شود. سیستم باید توانایی تشخیص افزایش فعالیت را داشته باشد و متناسب با آن واکنش نشان دهد. همچنین سیستم باید بتواند پس از کاهش بار به سرعت به حالت اولیه خود بازگردد. این مستلزم آن است که داده های کارایی مناسب به طور مداوم جمع آوری و نظارت شود.

* اگر سرویسی باید درخواست کاربر را به طور موقت رد کند، باید یک کد خطای خاص مانند 429 ("Too many requests") و 503 ("Server Too Busy") را برگرداند تا برنامه client بتواند دلیل رد کردن از سرویس را بفهمد. به خصوص اینکه یک request به دلیل throttling رد شده است.

* HTTP 429‏‏‏‏ نشان می دهد که کلاینت درخواست های زیادی را در یک پنجره زمانی ارسال کرده و از حد از پیش تعیین شده فراتر رفته است.

* ‏HTTP 503 نشان می دهد که سرویس برای پردازش درخواست‌ها و request ها آماده نیست. دلیل رایج این است که سرویس تحت تاثیر بارهای سنگین (load spikes) موقتی را بیش از حد انتظار تجربه می کند.

برنامه کلاینت می تواند قبل از retry درخواست، مدتی صبر کند. یک هدر Retry-After HTTP باید در پیام گنجانده شود تا از کلاینت در انتخاب استراتژی retry پشتیبانی کند.

* در حالی که یک سیستم autoscale می شود، می توان از Throttling به عنوان یک واحد موقت استفاده کرد. در برخی موارد بهتر است به جای استفاده از مقیاس کردن(scale) از یک throttle ساده استفاده کنیم مثلا زمانی که یک فعالیت شدید و غیر منتظره که مدت طولانی ای ماندگار نیست رو برنامه رخ داده است، در این حالت استفاده از روش scaling میتواند هزینه زیاد تری را نسیت به روش Throttling در پیش داشته باشد.

* اگر در زمانی که سیستم به صورت خودکار مقیاس می‌شود، از throttling به عنوان یک واحد موقت استفاده شود و اگر تقاضای منابع خیلی سریع افزایش یابد، سیستم ممکن است نتواند به کار خود ادامه دهد - حتی زمانی که در حالت throttling کار می‌کند. اگر این مورد قابل قبول و اجرا نیست، ظرفیت و منابع بیشتری را <mark style="background: #FFB86CA6;">رزرو</mark> کرده و autoscaling تهاجمی تر را پیکربندی کنید.

* ساده سازی هزینه های منابع مصرفی برای عملیات های مختلف، همانطور که آنها معمولاً هزینه های اجرایی برابری ندارند. برای مثال، محدودیت‌های throttling ممکن است برای عملیات خواندن کمتر و برای عملیات نوشتن بیشتر باشد. در نظر نگرفتن هزینه یک عملیات می تواند منجر به هدر رفت ظرفیت منابع موجود و در معرض قرار دادن  یک بردار حمله (attack vector) بالقوه شود.

* تغییر در لحظه پیکربندی و تنظیمات مربوط به رفتار و عملکرد استراتژی throttling به خصوص در حالت اجرا یا runtime بسیار مطلوب است. اگر سیستمی با بار غیرعادی روبرو شود که پیکربندی اعمال شده قادر به تحمل آن نیست بهتر است برای تثبیت سیستم و همگام شدن با ترافیک فعلی، محدودیت‌های throttling باید افزایش یا کاهش یابد. deploymentهای پرخطر و کند در این مرحله مناسب نیستند پس با استفاده از الگوی [External Configuration Store pattern](https://learn.microsoft.com/en-us/azure/architecture/patterns/external-configuration-store) پیکربندی throttling به صورت خارجی است و می توان آن را تغییر داد و بدون deployment خاصی آن اعمال کرد.
## When to use this pattern

از این الگو استفاده کنید:

* برای اطمینان از اینکه یک سیستم به ملاحظات سطح سرویس ادامه می دهد.

* برای جلوگیری از انحصار مصرف منابع توسط یک tenant یا یک برنامه.

* برای مدیریت حجم زیاد درخواست ها و فعالیت ها در زمان های کوتاه و لحظه ای.

* برای کمک به بهینه سازی هزینه یک سیستم با محدود کردن حداکثر سطوح منابع مورد نیاز برای حفظ کارایی آن.


## Example


شکل زیر نشان می دهد که چگونه throttling را می توان در یک سیستم داری چندین tenant پیاده سازی کرد. کاربران هر یک از  tenant ها به یک برنامه <mark style="background: #FFB86CA6;">میزبانی ابری(cloud-hosted) </mark>دسترسی پیدا می‌کنند که در آنجا فرم نظرسنجی‌ها را تکمیل و ارسال می‌کنند. این برنامه حاوی ابزار دقیقی است که بر میزان ارسال درخواست‌های این کاربران به برنامه نظارت می‌کند.

به منظور جلوگیری از تأثیرگذاری کاربران در یک tenant بر پاسخگویی و در دسترس بودن برنامه برای همه کاربران دیگر، محدودیتی برای تعداد درخواست‌هایی در هر ثانیه اعمال می‌شود که کاربران از هر یک tenant می‌توانند ارسال کنند. برنامه درخواست هایی را که از این حد فراتر می روند مسدود می کند.


![[Pasted image 20231128230936.png]]


## Next steps

راهنمایی زیر ممکن است هنگام اجرای این الگو نیز مرتبط باشد:

مورد [Instrumentation and Telemetry Guidance](https://learn.microsoft.com/en-us/previous-versions/msp-n-p/dn589775(v=pandp.10)) . با توجه به اینکه  throttling وابستگی به جمع آوری اطلاعات در مورد میزان استفاده از یک سرویس دارد پس این مورد نحوه تولید و ضبط اطلاعات مانیتورینگ سفارشی شده را شرح می دهد.
راهنمای سنجش سرویس([Service Metering Guidance](https://learn.microsoft.com/en-us/previous-versions/msp-n-p/dn589796(v=pandp.10))). نحوه اندازه‌گیری میزان استفاده از سرویس را به منظور درک نحوه استفاده از آنها شرح می‌دهد. این اطلاعات می تواند در تعیین نحوه throttle شدن یک سرویس مفید باشد.
راهنمای [Autoscaling Guidance](https://learn.microsoft.com/en-us/previous-versions/msp-n-p/dn589774(v=pandp.10)). همانطور که قبلا گفته شده است Throttling می‌تواند به‌عنوان یک معیار موقت در حین مقیاس‌پذیری خودکار(autoscale) سیستم یا رفع نیاز به یک سیستم برای autoscale استفاده شود. پس این مورد حاوی اطلاعاتی در مورد استراتژی های autoscale است.



## Related resources

الگوهای زیر نیز ممکن است هنگام اجرای این الگو مرتبط باشند:

الگوی بارگذاری بر اساس صف([Queue-based Load Leveling pattern](https://learn.microsoft.com/en-us/azure/architecture/patterns/queue-based-load-leveling)). تراز کردن بار مبتنی بر صف مکانیزمی است که معمولاً برای اجرای الگوی Throttling استفاده می شود. یک صف می تواند به عنوان یک بافر عمل کند که به یکنواخت کردن نرخ ارسال درخواست های ارسال شده توسط یک برنامه به یک سرویس کمک می کند.
الگوی صف اولویت([Priority Queue pattern](https://learn.microsoft.com/en-us/azure/architecture/patterns/priority-queue)). یک سیستم می‌تواند از صف اولویت‌بندی به عنوان بخشی از استراتژی throttling خود برای حفظ کارایی برای برنامه‌های مهم یا با ارزش بالاتر استفاده کند، در حالی که کارایی برنامه‌های کم اهمیت را کاهش می‌دهد.
الگوی فروشگاه پیکربندی خارجی([External Configuration Store pattern](https://learn.microsoft.com/en-us/azure/architecture/patterns/external-configuration-store).). متمرکز کردن و خارج کردن سیاست‌های throttling قابلیت تغییر پیکربندی را در runtime را بدون نیاز به deploy مجدد فراهم می‌کند. سرویس‌ها می‌توانند به راحتی پیکربندی شوند و پیکربندی جدید را بلافاصله برای پایداری سیستم اعمال کنند.