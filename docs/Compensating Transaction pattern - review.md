
وقتی از یک عملیات ساده که شامل یک سری مراحل متوالی است استفاده می کنید، الگوی Compensating Transaction می تواند مفید باشد. به طور خاص، اگر یک یا چند مرحله با شکست مواجه شد، می‌توانید از الگوی Compensating Transaction برای بازگشت یا توقف کارها یا تسک های انجام شده در هر مرحله استفاده کنید. به طور کلی، با کمک این الگو شما عملیاتی را پیدا می کنید که  از cloud-hosted applications پیروی می کند که فرآیندها و گردش های کاری پیچیده را پیاده سازی می کنند.

## Context and problem

برنامه هایی که در فضای ابری اجرا می شوند اغلب داده ها را تغییر می دهند. این داده ها گاهی اوقات در منابع مختلف داده در مکان های جغرافیایی مختلف پخش می شوند. برای جلوگیری از تداخل و بهبود کارایی در یک محیط توزیع شده، یک برنامه نباید سعی کند پایداری تراکنش های قوی(strong transactional consistency) را ارائه دهد. در عوض، برنامه باید پایداری شرطی(eventual consistency) را اجرا کند. در مدل  پایداری شرطی، یک business operation معمولی شامل یک سری مراحل جداگانه است. در حالی که عملیات این مراحل در حال انجام است، نمای کلی وضعیت سیستم ممکن است ناپایدار باشد. اما وقتی عملیات تمام شد و تمام مراحل اجرا شدند، سیستم باید دوباره پایدار شود.  
  
ء [Data Consistency Primer](https://learn.microsoft.com/en-us/previous-versions/msp-n-p/dn589800(v=pandp.10)) اطلاعاتی در مورد اینکه چرا تراکنش های توزیع شده به خوبی مقیاس نمی شوند، ارائه می دهد. این منبع همچنین اصول مدل پایداری احتمالی(eventual consistency model) را بیان می کند.  
  
یک چالش در مدل پایداری احتمالی(eventual consistency model)  این است که چگونه مرحله ای را که شکست می خورد مدیریت کنیم. پس از شکست، ممکن است لازم باشد تمام کارهایی را که مراحل قبلی در حین اجرای عملیات انجام داده‌اند، لغو کنید. با این حال، همیشه نمی توانید داده ها را به عقب برگردانید، زیرا سایر نمونه های همزمان برنامه ممکن است آن را تغییر داده باشند. حتی در مواردی که نمونه‌های همزمان داده‌ها را تغییر نداده‌اند، لغو یک مرحله ممکن است پیچیده‌تر از بازگرداندن حالت اولیه باشد. ممکن است لازم باشد قوانین مختلفی برای یک business خاص اعمال شود. برای مثال، به مورد «وب‌سایت مسافرتی» که بخش [مثال](https://learn.microsoft.com/en-us/azure/architecture/patterns/compensating-transaction#example) در ادامه این مقاله توضیح می‌دهد، مراجعه کنید.  
  
اگر عملیاتی که پایداری احتمالی(eventual consistency) را اجرا می‌کند که چندین data store غیر یکسان را در بر می‌گیرد، لغو مراحل در عملیات مستلزم بررسی از هر data store به نوبه خود است. برای جلوگیری از ناپایدار ماندن سیستم، باید کاری را که در هر data store انجام داده‌اید، به‌طور قابل اعتمادی لغو و undo  کنید.  
  
داده‌هایی که تحت تأثیر این نوع عملیاتی قرار گرفته با هدف اینکه  پایداری احتمالی را پیاده‌سازی ‌کند، به طور معمول در یک پایگاه داده نگهداری نمی‌شوند. به عنوان مثال، یک محیط معماری سرویس گرا (SOA) را در نظر بگیرید. یک عملیات SOA می تواند یک عمل را در یک سرویس فراخوانی کند و باعث تغییر در وضعیتی شود که توسط آن سرویس نگهداری می شود. برای لغو عملیات، باید این تغییر حالت را نیز لغو کنید. این فرآیند می‌تواند شامل فراخوانی مجدد سرویس و انجام عمل دیگری باشد که اثرات اولین عملیات‌ها  را معکوس می‌کند.

## Solution

راه حل اجرای یک Compensating Transaction است. مراحل یک Compensating Transaction، اثرات مراحل دیگر در عملیات اصلی را خنثی می کند. یک رویکرد شهودی جایگزینی وضعیت فعلی با وضعیتی است که سیستم در شروع عملیات در آن قرار داشت. اما یک تراکنش جبران‌کننده همیشه نمی‌تواند این رویکرد را داشته باشد، زیرا ممکن است تغییراتی را که سایر نمونه‌های همزمان(concurrent instances) یک برنامه ایجاد کرده‌اند، بازنویسی کند. در عوض، یک Compensating Transaction باید یک فرآیند هوشمند باشد که هر کاری را که نمونه‌های همزمان انجام می‌دهند در نظر بگیرد. این فرآیند معمولاً به یک برنامه خاص بستگی دارد و به دلیل ماهیت کاری که عملیات اصلی انجام می دهد هدایت می شود.  
  
یک رویکرد متداول استفاده از یک گردش کار برای اجرای یک عملیات در پایداری احتمالی(eventual consistency) است که نیاز به جبران دارد. همانطور که عملیات اصلی پیش می رود، سیستم اطلاعات مربوط به هر مرحله را ثبت می کند، از جمله نحوه لغو شدن task ای که هر مرحله انجام می دهد. اگر عملیات در هر نقطه ای با شکست مواجه شود، گردش کار(workflow) طی مراحلی که انجام داده است به عقب برمی گردد. در هر مرحله، گردش کار(workflow) کاری را انجام می دهد که آن مرحله را معکوس می کند.

دو نکته مهم عبارتند از:  
  
* یک Compensating Transaction ممکن است مجبور نباشد کار را دقیقاً به ترتیب معکوس عملیات اصلی لغو یا undo کند.  
* ممکن است بتوان برخی از مراحل واگرد و undo را به صورت موازی انجام داد.  

این رویکرد شبیه به استراتژی Sagas است که در وبلاگ  [Clemens Vasters' blog](https://vasters.com/archive/Sagas.html) مورد بحث قرار گرفته است.  
  
یک Compensating Transaction خود نیز یک عملیات  پایدار احتمالی است، بنابراین ممکن است شکست بخورد. سیستم باید بتواند Compensating Transaction را در نقطه شکست از سر گرفته و ادامه دهد. ممکن است لازم باشد مرحله ای را تکرار کنید که ناموفق است، بنابراین باید مراحل یک Compensating Transaction را به عنوان دستورات بی قدرت (idempotent commands) تعریف کنید. برای اطلاعات بیشتر، الگوهای [Idempotency Patterns](https://blog.jonathanoliver.com/idempotency-patterns) را در وبلاگ  Jonathan Oliver ببینید.  
  
در برخی موارد، مداخله به شیوه دستی ممکن است تنها راه بازیابی از مرحله ای باشد که شکست خورده است. در این شرایط، سیستم باید یک هشدار یا alert داده و تا حد امکان اطلاعات بیشتری در مورد دلیل خرابی ارائه دهد

## Issues and considerations

هنگام تصمیم گیری در مورد نحوه اجرای این الگو به نکات زیر توجه کنید:  
  
* تشخیص اینکه چه زمانی یک مرحله از عملیاتی که پایداری احتمالی(eventual consistency) را اجرا می کند، ممکن است آسان نباشد. یک مرحله ممکن است فوراً شکست نخورد. در عوض، ممکن است block شود. ممکن است لازم باشد مکانیزمی را برای time-out اجرا کنید.  
  
* تعمیم دادن منطق جبرانساز(compensation logic) کار آسانی نیست. یک Compensating Transaction یک ویژگی مربوط به برنامه است. در واقع این مورد وابسته به این است  که برنامه دارای اطلاعات کافی بوده که  بتواند اثرات هر مرحله  در یک عملیات ناموفق را لغو و undo کند.  
  
* شما باید مراحل یک Compensating Transaction را به عنوان idempotent commands تعریف کنید. اگر این کار را انجام دهید، در صورت شکست و fail شدن تراکنش جبران‌کننده(ompensating transaction)، می‌توان مراحل عملیاتی را تکرار کرد.  
  
* زیرساختی که مراحل را انجام می دهد باید معیارهای زیر را داشته باشد:  
  
	- در عملیات اصلی و در تراکنش جبرانی(compensating transaction) انعطاف پذیر است.  
	- اطلاعات لازم برای جبران سازی یک مرحله شکست خورده را از دست نمی دهد.  
	- به طور قابل اعتمادی پیشرفت منطق جبران ساز(compensation logic) را نظارت می کند.  

* یک Compensating Transaction لزوماً داده های سیستم را به وضعیت اولیه خودش در شروع عملیات اصلی بر نمی گرداند. در عوض، تراکنش جبران ساز  برای این کار است که عملیات با موفقیت به پایان برسد قبل از اینکه به شکست بخورد.
  
* ترتیب مراحل در Compensating Transaction لزوماً دقیقاً برعکس مراحل عملیات اصلی نیست. به عنوان مثال، یک data store ممکن است نسبت به دیگری نسبت به ناهماهنگی حساس تر باشد. مراحل Compensating Transaction که تغییرات این data store را واگرد یا undo می کند باید ابتدا انجام شود.  
  
* اقدامات خاصی می تواند به افزایش احتمال موفقیت کلی عملیات کمک کند. به طور خاص، می‌توانید قفل کوتاه‌مدت و مبتنی بر تایم اوت (short-term, time-out–based lock)  را روی هر منبعی که برای تکمیل یک عملیات لازم است قرار دهید. شما همچنین می توانید این منابع را از قبل رزرو کنید. سپس، کار را فقط پس از به دست آوردن تمام منابع لازم برای شروع عملیات انجام دهید. تمام اقدامات را قبل از منقضی شدن قفل ها نهایی کنید.  
  
* تلاش مجدد یا Retry  به شیوه ای که   کمک کننده تر از حد معمول است می تواند به به حداقل رساندن شکست هایی که باعث Compensating Transaction می شود کمک کند. اگر مرحله ای از عملیاتی که پایداری احتمالی را اجرا می کند با شکست مواجه شد، سعی کنید شکست را به عنوان یک استثنا گذرا مدیریت کنید و مرحله را تکرار کنید. همینطور بهتر است در شرایطی عملیات را متوقف کنید و یک Compensating Transaction را فقط در صورتی شروع کنید به خصوص زمانی که یک مرحله مکرراً با شکست مواجه شود یا نتوان آن را بازیابی کرد.  
  
* هنگامی که یک Compensating Transaction را پیاده سازی می کنید، با بسیاری از چالش های مشابهی روبرو می شوید که هنگام اجرای پایداری احتمالی(eventual consistency) با آن مواجه می شوید. برای کسب اطلاعات بیشتر، به بخش 'ملاحظات برای اجرای پایداری احتمالی' در  [Data Consistency Primer](https://learn.microsoft.com/en-us/previous-versions/msp-n-p/dn589800(v=pandp.10))مراجعه کنید.

## When to use this pattern


از این الگو فقط برای عملیاتی استفاده کنید که در صورت شکست باید لغو یا undo شوند. در صورت امکان، راه حل هایی طراحی کنید تا از پیچیدگی نیاز به تراکنش های جبرانی جلوگیری شود.

## Example

مشتریان از یک وب سایت مربوط به سفر برای رزرو برنامه های مسافرتی استفاده می کنند. یک برنامه مسافرتی ممکن است شامل یک سری پرواز و هتل باشد. مشتری که از سیاتل به لندن و سپس به پاریس سفر می کند، ممکن است مراحل زیر را هنگام ایجاد یک برنامه سفر انجام دهد:

1- در پرواز F1 از سیاتل به لندن صندلی رزرو کنید.  
2- در پرواز F2 از لندن به پاریس صندلی رزرو کنید.  
3- در پرواز F3 از پاریس به سیاتل صندلی رزرو کنید.  
4- اتاقی را در هتل H1 لندن رزرو کنید.  
5- رزرو اتاق در هتل H2 در پاریس.

این مراحل یک عملیات در پایدار احتمالی(compensating transaction) را تشکیل می دهند، اگرچه هر مرحله یک عمل جداگانه است. علاوه بر انجام این مراحل، سیستم باید عملیات شمارنده را نیز برای لغو هر مرحله ثبت کند. در صورتی که مشتری برنامه مسافرتی را لغو کند به این اطلاعات نیاز است. مراحلی که برای انجام عملیات شمارنده لازم است می توانند به عنوان یک Compensating Transaction اجرا شوند.  
  
ممکن است مراحل تراکنش جبرانساز( Compensating Transaction) دقیقاً برعکس مراحل اولیه نباشد. همچنین، منطق هر مرحله در Compensating Transaction باید قوانین خاص کسب و کار یا business را در نظر بگیرد. به عنوان مثال، لغو رزرو پرواز ممکن است به مشتری حق بازپرداخت کامل را نداشته باشد.  
  
شکل زیر مراحل یک تراکنش طولانی مدت برای رزرو برنامه مسافرتی را نشان می دهد. همچنین می توانید مراحل Compensating Transaction را که تراکنش را خنثی یا واگرد می کند، مشاهده کنید.

![[Pasted image 20231203234351.png]]

```
توجه داشته باشید  
  
بسته به نحوه طراحی منطق جبران کننده برای هر مرحله، ممکن است بتوانید مراحل تراکنس جبران ساز (Compensating Transaction) را به صورت موازی انجام دهید.

```

در بسیاری از راه حل های تجاری، شکست یک مرحله واحد همیشه مستلزم عقب نشینی سیستم با استفاده از Compensating Transaction نیست. به عنوان مثال، سناریوی وب سایت مسافرتی را در نظر بگیرید. فرض کنید مشتری پروازهای F1، F2 و F3 را رزرو می کند اما نمی تواند اتاقی در هتل H1 رزرو کند. ترجیحاً به جای لغو پروازها، اتاقی در هتل دیگری در همان شهر به مشتری پیشنهاد دهید. مشتری همچنان می تواند تصمیم به لغو را بگیرد. در آن صورت،( تراکنش جبران ساز) Compensating Transaction اجرا می شود و رزرو پروازهای F1، F2 و F3 را لغو می کند. اما مشتری باید این تصمیم را بگیرد نه سیستم.

## Next steps

* ء [Data Consistency Primer](https://learn.microsoft.com/en-us/previous-versions/msp-n-p/dn589800(v=pandp.10)). الگوی Compensating Transaction اغلب برای خنثی سازی عملیاتی که مدل پایداری احتمالی را پیاده سازی می کند، استفاده می شود. این primer اطلاعاتی در مورد مزایا و معاوضه های پایداری احتمالی ارائه می دهد.  
* ء [Idempotency Patterns](https://blog.jonathanoliver.com/idempotency-patterns) . در یک Compensating Transaction، بهتر است از دستورات idempotent استفاده کنید. این پست در این وبلاگ، فاکتورهایی را توضیح می دهد که باید هنگام پیاده سازی  idempotency در نظر بگیرید.

## Related resources

* الگوی [Scheduler Agent Supervisor pattern](https://learn.microsoft.com/en-us/azure/architecture/patterns/scheduler-agent-supervisor). این مقاله نحوه پیاده‌سازی سیستم‌های انعطاف‌پذیر را شرح می‌دهد که عملیات تجاری (business operations) را انجام می‌دهند که از سرویس‌ها و منابع توزیع شده استفاده می‌کنند. در این سیستم‌ها، گاهی اوقات لازم است از یک تراکنش جبران‌کننده برای لغو کاری که یک عملیات انجام می‌دهد استفاده کنید.  
* الگوی [Retry pattern](https://learn.microsoft.com/en-us/azure/architecture/patterns/retry). تراکنش های جبرانی می تواند از نظر محاسباتی پیچیده باشد. می‌توانید با استفاده از الگوی Retry برای اجرای یک سیاست مؤثر برای تلاش مجدد روی عملیات ناموفق، استفاده از آنها را به حداقل برسانید.  
* الگوی [Saga distributed transactions pattern](https://learn.microsoft.com/en-us/azure/architecture/reference-architectures/saga/saga). این مقاله نحوه استفاده از الگوی Saga را برای مدیریت پایداری داده ها در میان میکروسرویس ها در سناریوهای تراکنش توزیع شده توضیح می دهد. الگوی Saga بازیابی شکست(failure recovery) را با تراکنش های جبرانی مدیریت می کند.  
* الگوی [Pipes and Filters pattern](https://learn.microsoft.com/en-us/azure/architecture/patterns/pipes-and-filters). این مقاله الگوی لوله‌ها و فیلترها را توضیح می‌دهد که می‌توانید از آن برای تجزیه یک کار پردازشی پیچیده به یک سری از عناصر قابل استفاده مجدد استفاده کنید. می توانید از الگوی Pipes and Filters با الگوی Compensating Transaction به عنوان جایگزینی برای اجرای تراکنش های توزیع شده استفاده کنید.  
* ء [Design for self healing](https://learn.microsoft.com/en-us/azure/architecture/guide/design-principles/self-healing). این راهنما نحوه طراحی برنامه های خود درمانی(self-healing) را توضیح می دهد. می توانید از تراکنش های جبرانی به عنوان بخشی از رویکرد خود درمانی استفاده کنید.