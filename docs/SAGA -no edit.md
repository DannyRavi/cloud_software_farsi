# Saga distributed transactions pattern

الگوی طراحی Saga راهی برای مدیریت سازگاری داده‌ها (data consistency) در میان میکروسرویس‌ها در سناریوهای تراکنش توزیع شده (distributed transaction) است. Saga در واقع دنباله ای از تراکنش ها است که سرویس‌ها را به روزرسانی می کند و پیام یا رخدادی را برای راه اندازی تراکنش بعدی منتشر می کند. اگر مرحله ای با شکست مواجه شود، Saga تراکنش های جبرانی را اجرا می کند که تراکنش های قبلی را  بی اثر می کند.

###  Context and problem

تراکنش یک واحد منفرد از منطق یا کار مورد نظر است که گاهی از چندین عملیات تشکیل شده است. در یک تراکنش، یک رویداد یک تغییر حالت است که برای یک موجودیت اتفاق می‌افتد و یک فرمان تمام اطلاعات مورد نیاز برای انجام یک عملیات یا راه‌اندازی یک رویداد مربوط به حالت بعدی را در بر می‌گیرد.

تراکنش باید _atomic_، سازگار(_consistent_)، ایزوله(_isolated_) و بادوام(_durable_)  یا به اختصار (ACID) باشد. تراکنش‌های درون یک سرویس از نوع ACID هستند، اما سازگاری داده‌های cross-service به یک استراتژی مدیریت تراکنش‌های cross-service نیاز دارد.

در معماری های چند سرویس(multiservices):

* _Atomicity_ مجموعه ای تقسیم ناپذیر و تقلیل ناپذیر از عملیات است که همگی باید اتفاق بیافتند یا هیچکدام رخ ندهد.
* سازگاری(_Consistency_) به این معنی است که تراکنش داده ها را فقط از یک حالت معتبر به حالت معتبر دیگر می آورد.
* ایزوله سازی(_Isolation_) تضمین می‌کند که تراکنش‌های موازی همان حالت داده‌ای را ایجاد می‌کنند که تراکنش‌هایی متوالی اجرا و ایجاد می‌کنند.
* دوام(_Durability_) تضمین می کند که تراکنش های واقعی حتی در صورت خرابی سیستم یا قطع برق ثابت باقی می مانند.

یک مدل پایگاه داده به ازای هر میکروسرویس ( [database-per-microservice](https://learn.microsoft.com/en-us/dotnet/architecture/cloud-native/distributed-data#database-per-microservice-why)) مزایای بسیاری را برای معماری میکروسرویس ها فراهم می کند. کپسوله کردن domain data به هر سرویس اجازه می دهد تا از بهترین نوع ذخیره داده و طراحی  استفاده کند و ذخیره داده خود را در صورت لزوم scale کند و از تاثیرگذاری خرابی سایر سرویس های دیگر محفوظ مانده شود. با این حال، اطمینان از سازگاری داده‌ها در دیتابیس‌های سرویس‌های خاص، چالش‌هایی را ایجاد می‌کند.

تراکنش‌های توزیع‌شده مانند پروتکل[two-phase commit (2PC)](https://en.wikipedia.org/wiki/Two-phase_commit_protocol) به همه عوامل موثر  در یک تراکنش نیاز دارد تا ادامه انجام تراکنش جدید یا برگشت (roll back) به تراکنش قبلی را به شیوه مناسب انجام دهد. با این حال، برخی از پیاده‌سازی‌های خاص مانند استفاده از پایگاه‌های داده NoSQL و message brokerها از این مدل پشتیبانی نمی‌کنند.

یکی دیگر از محدودیت های تراکنش توزیع شده، هماهنگی(synchronicity) و در دسترس بودن (availability) ارتباطات بین فرآیندی [interprocess communication (IPC)](https://en.wikipedia.org/wiki/Inter-process_communication) است. IPC ارائه شده توسط سیستم عامل به فرآیندهای جداگانه این اجازه را می دهد تا داده ها را به اشتراک بگذارند. برای انجام تراکنش‌های توزیع‌شده، همه سرویس‌های مشارکت‌کننده و موثر باید در دسترس باشند که این مورد به طور بالقوه system availability را کاهش می‌دهد. پیاده سازی های این معماری با IPC به همراه  وجود محدودیت در تراکنش‌ها، کاندیدای مناسبی برای الگوی Saga می‌باشد.

## Solution

الگوی Saga مدیریت تراکنش را با استفاده از دنباله ای از تراکنش های محلی(_local transactions_) فراهم می کند. _local transactions_، تلاشی atomic است که توسط یک مشارکت کننده در الگوی Saga انجام می شود. هر تراکنش محلی پایگاه داده را به روزرسانی می کند و پیام یا رویدادی را برای راه اندازی تراکنش محلی بعدی در Saga منتشر می کند. اگر یک تراکنش محلی با شکست مواجه شود، Saga یک سری تراکنش های جبرانی را اجرا می کند که تغییرات ایجاد شده توسط تراکنش های محلی قبلی را خنثی می کند.


![[Pasted image 20231128231927.png]]



در الگوهای Saga :

* تراکنش های قابل جبران (_Compensable transactions_) ، تراکنش هایی هستند که به طور بالقوه می توانند با  تراکنش دیگری با عملکرد معکوس، خنثی شوند.
* تراکنش محوری(_pivot transaction_) یک نوع نقطه go/no-go در یک Saga است. اگر _pivot transaction_ فعال شود، Saga تا لحظه نهایی تکمیل شدن آن تراکنش در حال اجرا می‌باشد. _pivot transaction_ می تواند تراکنشی باشد که نه قابل جبران است و نه قابل اجرای مجدد(retry) یا می تواند آخرین تراکنش قابل جبران یا اولین تراکنش قابل retry در Saga باشد.
* تراکنش‌های قابل تکرار(_Retryable transactions_)، تراکنش‌هایی هستند که از تراکنش محوری پیروی می‌کنند و موفقیت انجام آنها تضمین می‌شود.

دو رویکرد رایج اجرای Saga وجود دارد، _choreography_ و _orchestration_. هر رویکرد مجموعه ای از چالش ها و فناوری های خاص خود را برای هماهنگ کردن workflow دارد.

تا اینجاااااااااااااااااااااااااااااااااااااا
### Choreography

رقص راهی برای هماهنگ کردن Saga هاست که در آن شرکت کنندگان رویدادها را بدون یک نقطه کنترل متمرکز مبادله می کنند. با طراحی رقص، هر تراکنش محلی رویدادهای دامنه ای را منتشر می کند که تراکنش های محلی را در سایر سرویس ها آغاز می کند.


![[Pasted image 20231128232242.png]]

#### Benefits


* برای گردش‌های کاری ساده که به شرکت‌کنندگان کمی نیاز دارند و به منطق هماهنگی نیاز ندارند، خوب است.
* نیازی به اجرای سرویس و نگهداری اضافی ندارد.
* یک نقطه شکست را معرفی نمی کند، زیرا مسئولیت ها بین شرکت کنندگان Saga توزیع می شود.
#### Drawbacks

* هنگام اضافه کردن مراحل جدید، گردش کار ممکن است گیج کننده شود، زیرا ردیابی اینکه کدام شرکت کنندگان Saga به کدام دستورها گوش می دهند دشوار است.
* خطر وابستگی چرخه ای بین شرکت کنندگان Saga وجود دارد زیرا آنها باید دستورات یکدیگر را مصرف کنند.
* تست یکپارچه سازی دشوار است زیرا همه سرویس ها باید برای شبیه سازی یک تراکنش در حال اجرا باشند.

### Orchestration

ارکستراسیون راهی برای هماهنگ کردن Saga ها است که در آن یک کنترل کننده متمرکز به شرکت کنندگان Saga می گوید که چه تراکنش های محلی را باید اجرا کنند. ارکستراتور Saga تمام تراکنش ها را مدیریت می کند و به شرکت کنندگان می گوید که کدام عملیات را بر اساس رویدادها انجام دهند. ارکستراتور درخواست‌های Saga را اجرا می‌کند، حالات هر وظیفه را ذخیره و تفسیر می‌کند، و بازیابی شکست را با تراکنش‌های جبران‌کننده مدیریت می‌کند.

![[Pasted image 20231128232552.png]]

#### Benefits

* برای گردش‌های کاری پیچیده که شامل بسیاری از شرکت‌کنندگان یا شرکت‌کنندگان جدیدی است که به مرور زمان اضافه می‌شوند، خوب است.  
* زمانی مناسب است که بر هر شرکت کننده در فرآیند کنترل وجود داشته باشد و بر جریان فعالیت ها کنترل داشته باشد.  
* وابستگی های چرخه ای را معرفی نمی کند، زیرا ارکستراتور به طور یک جانبه به شرکت کنندگان Saga وابسته است.  
* شرکت کنندگان ساگا نیازی به دانستن دستورات سایر شرکت کنندگان ندارند. تفکیک واضح نگرانی ها منطق کسب و کار را ساده می کند.
#### Drawbacks

* پیچیدگی طراحی اضافی مستلزم اجرای یک منطق هماهنگی است.  
* یک نقطه شکست اضافی وجود دارد، زیرا ارکستراتور گردش کار کامل را مدیریت می کند.

## Issues and considerations

* الگوی Saga ممکن است در ابتدا چالش برانگیز باشد، زیرا نیاز به روش جدیدی از تفکر در مورد نحوه هماهنگ کردن یک تراکنش و حفظ ثبات داده ها برای یک فرآیند تجاری که چندین میکروسرویس را در بر می گیرد، دارد.
* اشکال زدایی الگوی Saga به خصوص سخت است و با افزایش شرکت کنندگان، پیچیدگی آن افزایش می یابد.
* داده ها را نمی توان به عقب بازگرداند، زیرا شرکت کنندگان Saga تغییراتی را در پایگاه داده محلی خود انجام می دهند.
* پیاده‌سازی باید بتواند مجموعه‌ای از خرابی‌های گذرا بالقوه را مدیریت کند و برای کاهش اثرات جانبی و اطمینان از ثبات داده‌ها ناتوانی ایجاد کند. Idempotence به این معنی است که یک عمل را می توان چندین بار بدون تغییر در نتیجه اولیه تکرار کرد. برای اطلاعات بیشتر، به راهنمای اطمینان از عدم توانایی در هنگام پردازش پیام ها و به روز رسانی وضعیت با هم مراجعه کنید.
* برای نظارت و ردیابی گردش کار Saga، بهتر است قابلیت مشاهده را پیاده سازی کنید.
* فقدان جداسازی داده‌های شرکت‌کننده، چالش‌های دوام را تحمیل می‌کند. اجرای Saga باید شامل اقدامات متقابل برای کاهش ناهنجاری ها باشد.

--------

ناهنجاری های زیر می توانند بدون اقدامات مناسب رخ دهند:

* به روز رسانی های از دست رفته، زمانی که یک Saga بدون خواندن تغییرات ایجاد شده توسط Saga دیگر می نویسد.
* خواندن کثیف، زمانی که یک تراکنش یا یک Saga به‌روزرسانی‌های ساخته شده توسط Saga‌ای را می‌خواند که هنوز آن به‌روزرسانی‌ها را تکمیل نکرده است.
* خواندن فازی/غیر تکرار نشدنی، زمانی که مراحل مختلف Saga داده‌های متفاوتی را می‌خوانند، زیرا به‌روزرسانی داده‌ها بین خوانده‌ها رخ می‌دهد.

اقدامات متقابل پیشنهادی برای کاهش یا پیشگیری از ناهنجاری ها عبارتند از:

* قفل معنایی، یک قفل در سطح برنامه که در آن تراکنش قابل جبران Saga از یک سمافور برای نشان دادن به‌روزرسانی در حال انجام استفاده می‌کند.
* به روز رسانی های جابجایی که می توانند به هر ترتیبی اجرا شوند و نتیجه یکسانی را ایجاد کنند.
* دیدگاه بدبینانه: ممکن است یک Saga داده های کثیف را بخواند، در حالی که Saga دیگری در حال اجرای تراکنش قابل جبران برای عقب انداختن عملیات است. دیدگاه بدبینانه Saga را دوباره ترتیب می دهد، بنابراین داده های اساسی در یک تراکنش قابل امتحان مجدد به روز می شوند، که امکان خواندن کثیف را از بین می برد.
* مقدار بازخوانی تأیید می کند که داده ها بدون تغییر هستند و سپس رکورد را به روز می کند. اگر رکورد تغییر کرده باشد، مراحل لغو می شود و Saga ممکن است دوباره راه اندازی شود.
* یک فایل نسخه، عملیات ها را در یک رکورد به محض رسیدن آنها ثبت می کند و سپس آنها را به ترتیب صحیح اجرا می کند.
* براساس ارزش از ریسک تجاری هر درخواست برای انتخاب پویا مکانیزم همزمانی استفاده می کند. درخواست های کم خطر به نفع Saga ها هستند، در حالی که درخواست های با ریسک بالا به نفع تراکنش های توزیع شده هستند.


## When to use this pattern


در صورت نیاز از الگوی Saga استفاده کنید:

* از سازگاری داده ها در یک سیستم توزیع شده بدون کوپلینگ محکم اطمینان حاصل کنید.
* اگر یکی از عملیات های دنباله شکست خورد، به عقب برگردید یا جبران کنید.

الگوی Saga کمتر مناسب برای موارد زیر است:

* تراکنش‌های بهم پیوسته
* تراکنش های جبرانی که در شرکت کنندگان قبلی رخ می دهد.
* وابستگی های چرخه ای

## Example

Saga مبتنی بر ارکستراسیون در سرور بدون سرور یک مرجع پیاده‌سازی Saga با استفاده از رویکرد ارکستراسیون است که سناریوی انتقال پول را با گردش‌های کاری موفق و ناموفق شبیه‌سازی می‌کند.

## Next steps

- [Distributed data](https://learn.microsoft.com/en-us/dotnet/architecture/cloud-native/distributed-data)
- Richardson, Chris. 2018: _Microservices Patterns_. Manning Publications.

## Related resources

الگوهای زیر نیز ممکن است هنگام اجرای این الگو مفید باشند:

* طراحی رقص به جای تکیه بر یک نقطه کنترل مرکزی، هر یک از اجزای سیستم را در فرآیند تصمیم گیری در مورد گردش کار یک معامله تجاری شرکت می دهد.

* تراکنش های جبرانی کار انجام شده توسط یک سری مراحل را خنثی می کند و در نهایت در صورت شکست یک یا چند مرحله یک عملیات ثابت را تعریف می کند. برنامه‌های میزبانی شده در فضای ابری که فرآیندها و گردش‌های کاری پیچیده را پیاده‌سازی می‌کنند، اغلب از این مدل سازگاری نهایی پیروی می‌کنند.

* الگوی Retry به یک برنامه اجازه می‌دهد تا هنگام تلاش برای اتصال به یک سرویس یا منبع شبکه، با تلاش مجدد شفاف عملیات ناموفق، خرابی‌های گذرا را مدیریت کند. سعی مجدد می تواند پایداری برنامه را بهبود بخشد.
* قطع کننده مدار خطاهایی را که در هنگام اتصال به یک سرویس یا منبع از راه دور بازیابی می شود، به زمان متغیری نیاز دارد. مدار شکن می تواند پایداری و انعطاف پذیری یک برنامه کاربردی را بهبود بخشد.

* نظارت بر نقطه پایانی سلامت، بررسی‌های عملکردی را در برنامه‌ای اجرا می‌کند که ابزارهای خارجی می‌توانند از طریق نقاط پایانی در معرض در فواصل زمانی منظم به آن دسترسی داشته باشند. پایش نقطه پایانی سلامت می‌تواند به تأیید درستی عملکرد برنامه‌ها و سرویس‌ها کمک کند.