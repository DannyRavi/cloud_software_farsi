بسیاری از سرویس ها برای کنترل منابع مورد مصرف از یک [throttling pattern](https://learn.microsoft.com/en-us/azure/architecture/patterns/throttling) استفاده می کنند و محدودیت هایی را برای نرخ دسترسی سایر برنامه ها یا سرویس‌ها به آنها تحمیل می کنند. شما می توانید از یک الگوی محدود کننده نرخ (rate limit) استفاده کنید تا به شما در جلوگیری از یا به حداقل رساندن خطاهای throttling مربوط به این محدودیت های پرتاب و برای کمک به شما در پیش بینی دقیق تر عملکرد کمک کند.  
  
الگوی (rate limit در بسیاری از سناریوها مناسب است<mark style="background: #FF5582A6;">، به ویژه برای تسک‌های خودکار تکراری که در مقیاس بزرگی فعالیت می‌کنند مانند پردازش دسته ای(batch processing) مفید است</mark>.

## Context and problem

انجام تعداد زیادی عملیات با استفاده از یک سرویس throttled می‌تواند منجر به افزایش ترافیک و توان عملیاتی شود، زیرا باید درخواست‌های رد شده را ردیابی کنید و سپس دوباره آن عملیات را retry یا تست کنید. با افزایش تعداد عملیات‌ها، یک throttling limit ممکن است به چندین بار ارسال مجدد داد‌ها نیاز داشته باشد که منجر به افزایش کارایی می شود.  
  
به عنوان مثال، retryهای ساده  زیر را در فرآیند خطا برای وارد کردن داده‌ها به Azure Cosmos DB در نظر بگیرید:

1- برنامه شما باید 10000 رکورد را در Azure Cosmos DB وارد کند. دریافت هر رکورد 10 واحد درخواست یا Request Units (RUs هزینه دارد که در مجموع به 100000 RU برای تکمیل کردن این کار نیاز دارد.
2- نمونه Azure Cosmos DB شما دارای 20000 RU ظرفیت تدارک دیده شده است.
3- شما تمام 10000 رکورد را به Azure Cosmos DB ارسال می کنید. 2000 رکورد با موفقیت نوشته شده و 8000 رکورد ثبت شده است.
4- شما 8000 رکورد باقیمانده را به Azure Cosmos DB ارسال می کنید. 2000 رکورد با موفقیت نوشته شده و 6000 رکورد ثبت شده است.
5- شما 6000 رکورد باقیمانده را به Azure Cosmos DB ارسال می کنید. 2000 رکورد با موفقیت نوشته شده و 4000 رکورد ثبت شده است.
6- شما 4000 رکورد باقیمانده را به Azure Cosmos DB ارسال می کنید. 2000 رکورد با موفقیت نوشته شده و 2000 رکورد ثبت شده است.
7- شما 2000 رکورد باقیمانده را به Azure Cosmos DB ارسال می کنید. همه با موفقیت نوشته شده اند.


کار وارد کردن داده‌ها با موفقیت انجام شد، اما تنها پس از ارسال 30000 رکورد به Azure Cosmos DB حتی اگر کل مجموعه فقط از 10000 رکورد تشکیل شده بود.

در مثال بالا عوامل دیگری وجود دارد که باید در نظر گرفته شود:  
  
* تعداد زیادی خطا همچنین می تواند منجر به کار اضافی برای ثبت این خطاها و پردازش داده های هزینه از حاصل logها  شود. این رویکرد ساده لوحانه  20000 خطا را مدیریت کرده است و log این خطاها ممکن است  سربار پردازشی، حافظه یا منبع ذخیره سازی را تحمیل کند.  
* این رویکرد ساده لوحانه، بدون دانستن در مورد throttling limit سرویس دریافت، راهی برای تعیین انتظارات برای مدت زمان پردازش داده‌ها را ندارد. در نتیجه Rate limit می تواند به شما این امکان را دهد که زمان مورد نیاز برای وارد کردن داده ‌ها را محاسبه کنید.

## Solution

Rate limit می تواند ترافیک شما را کاهش دهد و با کاهش تعداد رکوردهای ارسال شده به یک سرویس در یک دوره زمانی معین، به طور بالقوه توان عملیاتی را بهبود بخشد.  
  
یک سرویس ممکن است بر اساس معیارهای مختلف در طول زمان throttle شود، مانند:

* تعداد عملیات‌ها (مثلاً 20 درخواست در ثانیه).  
* مقدار داده‌ها (مثلاً 2 گیگابایت در دقیقه).  
* هزینه‌های مالی نسبی عملیات (به عنوان مثال، 20000 ریال در ثانیه).

صرف نظر از معیاری که برای throttling استفاده می شود، اجرای rate limit شامل کنترل تعداد و/یا اندازه عملیات ارسال شده به سرویس در یک بازه زمانی خاص و بهینه سازی استفاده شما از سرویس در حالی که از ظرفیت throttling آن از حد مورد انتظار فراتر نمی رود، خواهد بود.  
  
<mark style="background: #FF5582A6;">در سناریوهایی که APIهای شما می‌توانند درخواست‌ها(requests) را سریع‌تر از هر سرویس دریافتی تحت فشار انجام دهند، بهتر است سرعت استفاده از این سرویس را مدیریت کنید. با این حال، تنها در نظر گرفتن throttling به عنوان یک مشکل عدم تطابق نرخ داده و صرفاً بافر کردن درخواست‌های واردن کردن داده‌ها  تا زمانی که سرویس throttled بتواند به آن رسیدگی کند، خطرناک است. اگر برنامه شما در این سناریو دچار مشکل  شود، خطر از دست دادن هر یک از این داده های بافر شده را دارید.</mark>

<mark style="background: #FFF3A3A6;">برای جلوگیری از این خطر، رکوردهای خود را به یک سیستم پیام رسانی (messaging) بفرستید که بتواند میزان مصرف کامل داد‌ه‌ها در سرویس شما را کنترل کند.</mark> (سرویس هایی مانند Azure Event Hubs می توانند میلیون ها عملیات را در ثانیه انجام دهند). سپس می‌توانید از یک یا چند پردازشگر  برای خواندن رکوردها از سیستم پیام‌رسانی با نرخ کنترل‌شده‌ای استفاده کنید که در محدوده‌های سرویس throttled است. ارسال رکوردها به messaging system می‌تواند میزان مصرف حافظه داخلی را بهینه کند و به شما امکان می‌دهد که فقط رکوردهایی را که در یک بازه زمانی معین پردازش می‌شوند را بعد از پردازش حذف کنید.  
  
Azure چندین سرویس پیام رسانی بادوام ارائه می دهد که می توانید با این الگو از آنها استفاده کنید، از جمله:

- [Azure Service Bus](https://azure.microsoft.com/services/service-bus/)
- [Azure Queue Storage](https://azure.microsoft.com/services/storage/queues/)
- [Azure Event Hubs](https://azure.microsoft.com/services/event-hubs/)

![[Pasted image 20231201233803.png]]

وقتی رکوردها را ارسال می کنید، ممکن است دوره زمانی که برای انتشار رکوردها استفاده می کنید  نسبت به دوره زمانی که از سرویس throttle می گذرد دقیق تر باشد. سیستم‌ها اغلب throttle را بر اساس بازه‌های زمانی تنظیم می‌کنند که به راحتی می‌توانید آن را درک کرده و با آن کار کنید. با این حال، برای رایانه ای که یک سرویس را اجرا می کند، این بازه های زمانی ممکن است در مقایسه با سرعت پردازش اطلاعات بسیار طولانی باشد. به عنوان مثال، یک سیستم ممکن است در هر ثانیه یا در دقیقه throttle شود، اما معمولاً  این کد در حدود نانوثانیه یا میلی‌ثانیه پردازش می‌شود.  



تا اینجاااااااااااااااااااااااااااااااااا




در حالی که ضروری نیست ولی توصیه می شود برای بهبود توان عملیاتی، مقادیر کمتری از رکوردها را به دفعات بیشتر ارسال کنید. پس به جای اینکه بخواهید یک بار در ثانیه یا یک بار در دقیقه موارد مورد نظر را به صورت دسته‌ای منتشر کنید، می‌توانید برای حفظ میزان مصرف منابع خود (حافظه، CPU، شبکه و غیره) با سرعت یکنواخت‌تر عمل کنید و از به وقوع پیوستن گلوگاه در سیستم جلوگیری کنید. به عنوان مثالی از دلیل حجوم درخواست‌های لحظه‌ای ، اگر یک سرویس اجازه 100 عملیات در ثانیه را بدهد، پیاده سازی یک محدود کننده نرخ (rate limiter) ممکن است درخواست ها را با آزاد کردن 20 عملیات در هر 200 میلی ثانیه یکسان کند، همانطور که در نمودار زیر نشان داده شده است.

![[Pasted image 20231201233817.png]]


علاوه بر این، گاهی اوقات لازم است چندین فرآیند ناهماهنگ یک سرویس را به اشتراک بگذارند. برای پیاده سازی محدودیت نرخ در این سناریو، می توانید به طور منطقی ظرفیت سرویس را تقسیم بندی کنید و سپس از یک سیستم حذف متقابل توزیع شده برای مدیریت قفل های انحصاری روی آن پارتیشن ها استفاده کنید. سپس فرآیندهای ناهماهنگ می توانند هر زمان که به ظرفیت نیاز داشته باشند برای قفل کردن آن پارتیشن ها رقابت کنند. برای هر پارتیشنی که یک فرآیند برای آن قفل نگه می دارد، مقدار مشخصی ظرفیت به آن داده می شود.  
  
به عنوان مثال، اگر سیستم throttled اجازه می دهد 500 درخواست در ثانیه، شما ممکن است 20 پارتیشن به ارزش 25 درخواست در هر ثانیه ایجاد کنید. اگر فرآیندی نیاز به صدور 100 درخواست داشته باشد، ممکن است از سیستم حذف متقابل توزیع شده برای چهار پارتیشن بخواهد. سیستم ممکن است دو پارتیشن به مدت 10 ثانیه بدهد. سپس این فرآیند به 50 درخواست در ثانیه امتیاز می دهد، کار را در دو ثانیه تکمیل می کند و سپس قفل را آزاد می کند.


یکی از راه‌های پیاده‌سازی این الگو، استفاده از Azure Storage است. در این سناریو، شما یک حباب 0 بایتی برای هر پارتیشن منطقی در یک ظرف ایجاد می کنید. سپس برنامه‌های شما می‌توانند مستقیماً برای مدت کوتاهی (مثلاً 15 ثانیه) در برابر آن حباب‌ها اجاره‌نامه‌های انحصاری دریافت کنند. برای هر اجاره ای که یک برنامه اعطا می شود، می تواند از ظرفیت آن پارتیشن استفاده کند. سپس برنامه باید زمان اجاره را ردیابی کند تا پس از انقضای آن، بتواند از ظرفیتی که اعطا شده است استفاده نکند. هنگام پیاده‌سازی این الگو، اغلب می‌خواهید که هر فرآیند زمانی که به ظرفیت نیاز دارد، سعی کند یک پارتیشن تصادفی اجاره کند.  
  
برای کاهش بیشتر تاخیر، ممکن است مقدار کمی از ظرفیت انحصاری را برای هر فرآیند اختصاص دهید. در این صورت یک فرآیند تنها در صورتی به دنبال دریافت اجاره ظرفیت مشترک است که نیاز به تجاوز از ظرفیت رزرو شده خود داشته باشد.

![[Pasted image 20231201233848.png]]

به عنوان جایگزینی برای Azure Storage، می‌توانید این نوع سیستم مدیریت اجاره را با استفاده از فناوری‌هایی مانند Zookeeper، Consul، etcd، Redis/Redsync و غیره پیاده‌سازی کنید.


-----------
p1
-----------

## Issues and considerations

* در حالی که الگوی محدود کننده نرخ می تواند تعداد خطاهای throttling را کاهش دهد، برنامه شما همچنان باید به درستی خطاهای throttling را که ممکن است رخ دهد مدیریت کند.  

* اگر برنامه شما دارای چندین جریان کاری است که به همان سرویس throttled دسترسی دارند، باید همه آنها را در استراتژی محدود کردن نرخ خود ادغام کنید. به عنوان مثال، شما ممکن است از بارگذاری انبوه رکوردها در پایگاه داده پشتیبانی کنید، اما همچنین از درخواست سوابق در همان پایگاه داده پشتیبانی کنید. می‌توانید با اطمینان از اینکه همه جریان‌های کاری از طریق مکانیسم محدودکننده نرخ یکسانی در نظر گرفته شده‌اند، ظرفیت را مدیریت کنید. از طرف دیگر، می توانید ظرفیت های جداگانه ای را برای هر جریان کاری رزرو کنید. 

* سرویس throttled ممکن است در چندین برنامه استفاده شود. در برخی - اما نه همه - موارد، می توان آن استفاده را هماهنگ کرد (همانطور که در بالا نشان داده شده است). اگر شروع به مشاهده تعداد بیشتر از حد انتظار خطاهای throttling کردید، این ممکن است نشانه اختلاف بین برنامه هایی باشد که به یک سرویس دسترسی دارند. اگر چنین است، ممکن است لازم باشد به طور موقت میزان توان اعمال شده توسط مکانیسم محدودکننده نرخ خود را کاهش دهید تا زمانی که استفاده از سایر برنامه ها کاهش یابد.

## When to use this pattern

از این الگو برای موارد زیر استفاده کنید:  
  
* خطاهای دریچه گاز ایجاد شده توسط سرویس محدود دریچه گاز را کاهش دهید.  
* کاهش ترافیک در مقایسه با یک روش ساده سعی مجدد بر روی خطا.  
* مصرف حافظه را با حذف رکوردها تنها زمانی که ظرفیت پردازش آنها وجود دارد، کاهش دهید.

## Example

برنامه مثال زیر به کاربران اجازه می دهد تا رکوردهایی از انواع مختلف را به یک API ارسال کنند. برای هر نوع رکورد یک پردازشگر کار منحصر به فرد وجود دارد که مراحل زیر را انجام می دهد:  
  
1- اعتبار سنجی  
2- غنی سازی  
3- درج رکورد در پایگاه داده  

همه اجزای برنامه (API، پردازشگر شغل A، و پردازشگر شغل B) فرآیندهای جداگانه ای هستند که ممکن است به طور مستقل مقیاس شوند. فرآیندها مستقیماً با یکدیگر ارتباط برقرار نمی کنند.

![[Pasted image 20231201234043.png]]


1- یک کاربر 10000 رکورد از نوع A را به API ارسال می کند.  
2- API آن 10000 رکورد را در صف A قرار می دهد.  
3- یک کاربر 5000 رکورد از نوع B را به API ارسال می کند.  
4- API آن 5000 رکورد را در صف B قرار می دهد.  
5- Job Processor A می بیند که Queue A دارای سوابق است و سعی می کند یک اجاره انحصاری در blob 2 به دست آورد.  
6- Job Processor B می بیند که Queue B دارای سوابق است و سعی می کند یک اجاره انحصاری در blob 2 به دست آورد.  
7- Job Processor A موفق به دریافت اجاره نامه نمی شود.  
8- Job Processor B اجاره نامه blob 2 را به مدت 15 ثانیه دریافت می کند. اکنون می تواند درخواست های محدود به پایگاه داده را با نرخ 100 در ثانیه رتبه بندی کند.  
9- Job Processor B 100 رکورد را از صف B جدا می کند و آنها را می نویسد.  
10- یک ثانیه می گذرد.  
11- Job Processor A می بیند که Queue A رکوردهای بیشتری دارد و سعی می کند اجاره انحصاری را در blob 6 به دست آورد.  
12- Job Processor B می بیند که Queue B رکوردهای بیشتری دارد و سعی می کند اجاره انحصاری را در blob 3 به دست آورد.  
13- Job Processor A اجاره نامه حباب 6 را به مدت 15 ثانیه دریافت می کند. اکنون می تواند درخواست های محدود به پایگاه داده را با نرخ 100 در ثانیه رتبه بندی کند.  
14- Job Processor B اجاره نامه حباب 3 را به مدت 15 ثانیه دریافت می کند. اکنون می تواند درخواست های محدود به پایگاه داده را با نرخ 200 در ثانیه رتبه بندی کند. (همچنین اجاره لکه 2 را نیز در اختیار دارد.)  
15- Job Processor A 100 رکورد را از صف A جدا می کند و آنها را می نویسد.  
16- Job Processor B 200 رکورد را از صف B جدا می کند و آنها را می نویسد.  
17- یک ثانیه می گذرد.  
18- Job Processor A می بیند که Queue A رکوردهای بیشتری دارد و سعی می کند یک اجاره انحصاری در blob 0 به دست آورد.  
19- Job Processor B می بیند که Queue B رکوردهای بیشتری دارد و سعی می کند یک اجاره انحصاری در blob 1 به دست آورد.  
20- Job Processor A اجاره نامه blob 0 را به مدت 15 ثانیه دریافت می کند. اکنون می تواند درخواست های محدود به پایگاه داده را با نرخ 200 در ثانیه رتبه بندی کند. (همچنین اجاره لکه 6 را نیز دارد.)  
21- Job Processor B اجاره نامه حباب 1 را به مدت 15 ثانیه دریافت می کند. اکنون می تواند درخواست های محدود به پایگاه داده را با نرخ 300 در ثانیه رتبه بندی کند. (همچنین اجاره حباب 2 و 3 را نیز دارد.)  
22- Job Processor A 200 رکورد را از صف A جدا می کند و آنها را می نویسد.  
23- Job Processor B 300 رکورد را از صف B جدا می کند و آنها را می نویسد.  
24- و غیره...  

پس از 15 ثانیه، یک یا هر دو کار هنوز تکمیل نخواهد شد. همانطور که قراردادها منقضی می‌شوند، یک پردازنده باید تعداد درخواست‌هایی را که می‌نویسد و می‌نویسد نیز کاهش دهد.  
  
پیاده سازی این الگو که در Go پیاده سازی شده است در GitHub موجود است.

## Related resources

الگوها و راهنمایی‌های زیر نیز ممکن است هنگام اجرای این الگو مرتبط باشند:  
  
* گاز دادن. الگوی محدود کننده نرخ که در اینجا مورد بحث قرار می‌گیرد، معمولاً در پاسخ به سرویسی اجرا می‌شود.  
* دوباره امتحان کنید. هنگامی که درخواست‌ها برای سرویس throttled منجر به خطاهای throttling می‌شوند، معمولاً مناسب است که پس از یک بازه زمانی مناسب دوباره آن‌ها را امتحان کنید.  

سطح بندی بار مبتنی بر صف مشابه است اما از چند جهت کلیدی با الگوی محدود کردن نرخ متفاوت است:

1- محدود کردن نرخ لزوماً نیازی به استفاده از صف برای مدیریت بار ندارد، اما نیاز به استفاده از یک سرویس پیام رسانی بادوام دارد. به عنوان مثال، یک الگوی محدود کننده نرخ می تواند از خدماتی مانند آپاچی کافکا یا Azure Event Hubs استفاده کند.  

2- الگوی محدود کننده نرخ، مفهوم یک سیستم محرومیت متقابل توزیع شده را در پارتیشن ها معرفی می کند، که به شما امکان می دهد ظرفیت چندین فرآیند ناهماهنگی را که با یک سرویس throttled ارتباط برقرار می کنند، مدیریت کنید.

3- یک الگوی تسطیح بار مبتنی بر صف در هر زمان که عدم تطابق عملکرد بین سرویس‌ها یا برای بهبود انعطاف‌پذیری وجود داشته باشد، قابل اجرا است. این باعث می‌شود که الگوی گسترده‌تری نسبت به محدود کردن نرخ، که به طور خاص به دسترسی موثر به یک سرویس دریچه گاز می‌پردازد، باشد.

