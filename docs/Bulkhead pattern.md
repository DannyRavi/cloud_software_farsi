
الگوی Bulkhead  مروبط به نوعی از طراحی application است که در برابر شکست(failure) مقاوم است. در معماری Bulkhead، عناصر یا اجزای  یک application در مخزنی ایزوله می شوند تا اگر یکی از مخزن‌ها کار بیفتد، بقیه آن‌ها به کار خود ادامه دهند. نام این الگو  برگرفته از پارتیشن های برش خورده (bulkheads) بدنه کشتی است. اگر بدنه کشتی آسیب ببیند، فقط قسمت آسیب دیده پر از آب می شود که از غرق شدن کشتی جلوگیری می کند.

## موضوع و مشکل


یک  application مبتنی بر ابر ممکن است شامل چندین سرویس باشد که هر سرویس یک یا چند مصرف کننده دارد. سربار بیش از حد(Excessive load) یا خرابی در یک سرویس بر همه مصرف کنندگان سرویس تأثیر می گذارد.  
  
علاوه بر این، یک مصرف کننده (consumer) ممکن است با مصرف منابع زیاد برای هر درخواستی که سمت سرویس ارسال می‌کند یا درحالتی دیگر درخواست هایی را به طور همزمان به چندین سرویس  ارسال کند باعث سربار بیش از حد روی آن سرویس شود. هنگامی که مصرف کننده درخواستی را به سرویسی ارسال می کند که پیکربندی آن اشتباه است یا سرویس مورد نظر هیچ پاسخی را نمی دهد در این صورت منابع مورد استفاده جهت پردازش درخواست کاربر ممکن است به موقع آزاد نشوند. با ادامه ارسال درخواست‌ها برای سرویس هدف، ممکن است این منابع تمام شود. به عنوان مثال، client's connection pool ممکن است تمام شده باشد. در آن مرحله، درخواست‌‌های مصرف کننده برای سرویس‌های دیگر تحت تأثیر قرار می گیرد. در نهایت مصرف‌کننده(consumer) دیگر نمی‌تواند درخواست‌‌های‌هایی را برای سرویس‌های دیگر ارسال کند.

همین مسئله فرسودگی منابع بر سرویس‌هایی با چندین مصرف‌کننده تأثیر می گذارد. تعداد زیادی درخواست از یک کاربر ممکن است منابع موجود در سرویس را تمام کند. در نتیجه سایر مصرف‌کننده‌ها دیگر قادر به استفاده از سرویس نیستند و این باعث ایجاد  شکست‌های پشت سر هم و متوالی  (cascading failure effect) می شود.

## راه حل

نمونه های سرویس را بر اساس بار مصرف کننده و الزامات در دسترس بودن به گروه های مختلف تقسیم بندی کنید. این طراحی به جداسازی خرابی‌ها کمک می‌کند و به شما امکان می‌دهد تا عملکرد سرویس را برای برخی از مصرف‌کنندگان حتی در هنگام خرابی، حفظ کنید.

یک مصرف کننده همچنین می تواند منابع را پارتیشن بندی کند تا اطمینان حاصل شود که منابع استفاده شده برای فراخوانی یک سرویس بر منابع استفاده شده برای فراخوانی سرویس دیگر تأثیر نمی گذارد. برای مثال، مصرف‌کننده‌ای که چندین سرویس را فراخوانی می‌کند، ممکن است برای هر سرویس یک مخزن اتصال اختصاص داده شود. اگر سرویسی شروع به fail شدن کند، فقط بر روی connection pool اختصاص داده شده برای آن سرویس تأثیر می گذارد و به مصرف کننده اجازه می دهد تا به استفاده از سایر سرویس‌ها ادامه دهد.

مزایای این الگو عبارتند از:


* مصرف کنندگان و سرویس‌ها را از خرابی های متوالی (cascading failures) جدا می کند. مشکلی که بر یک مصرف کننده یا سرویس تأثیر می گذارد می تواند در قسمت خود جدا شود و از شکست کل مسئله جلوگیری کند.  

* به شما امکان می دهد در صورت خرابی سرویس، برخی از عملکردها را حفظ کنید و سایر سرویس‌ها و ویژگی های برنامه به کار خود ادامه خواهند داد.  

* به شما امکان می دهد سرویس‌هایی را که کیفیت متفاوتی دارند را با توجه به ویژگی‌های مورد نیاز  برای applicationهای مورد استفاده خود انتخاب کرده و در نهایت برنامه خود را با توجه به ویژگی های سفارشی و مورد نظر مستقر کنید. همینطور یک مجموعه مصرف کننده با اولویت بالا را می توان برای استفاده از سرویس‌هایی با اولویت بالاتر پیکربندی کرد.

نمودار زیر دیاگرام bulkheads را نشان می دهد که در اطراف connection pool ساخته شده اند و سرویس‌های منحصر به فردی را فراخوانی می کنند. اگر سرویس A از کار بیفتد یا مشکل دیگری ایجاد کند، connection pool ایزوله یا جداسازی می شود، بنابراین فقط workloadهایی با استفاده از thread pool اختصاص داده شده به سرویس A تحت تأثیر قرار می گیرند. بارهایی که از سرویس B و C استفاده می کنند تحت تأثیر قرار نمی گیرند و می توانند بدون وقفه به کار خود ادامه دهند.

![[Pasted image 20230828191703.png]]

نمودار بعدی چندین client را نشان می دهد که با یک سرویس ارتباط می گیرند. به هرکلاینت یک نمونه سرویس جداگانه اختصاص داده می شود. کلاینت 1 که درخواست‌‌های زیادی کرده است و نمونه‌های زیادی  را تحت تاثیر قرار داده است. از آنجایی که هر نمونه از سرویس از بقیه سرویس‌ها جدا شده است، سایر کلاینت‌ها می توانند به برقراری تماس و ارتباطات خود ادامه دهند.

![[Pasted image 20230828191907.png]]

## مسائل و ملاحظات


* پارتیشن هایی را در مورد نیازهای business و technical برنامه تعریف کنید.
* هنگام تقسیم services یا consumers به کمک  bulkheadsها، سطح ایزوله ارائه شده توسط technology و همچنین هزینه های سربار را از نظر هزینه، عملکرد و مدیریت در نظر بگیرید.
* ترکیب bulkheadsها با الگوهای retry, circuit breaker  و throttling را در نظر بگیرید تا مدیریت خطای پیچیده تری(fault handling) را ارائه دهید.
* هنگام تقسیم consumers به bulkheads، استفاده از فرآیندها، thread pools و semaphores را در نظر بگیرید. پروژه هایی مانند [resilience4j](https://github.com/resilience4j/resilience4j) و [Polly](https://github.com/App-vNext/Polly) چارچوبی را برای ایجاد bulkheads مصرفی ارائه می دهند.
* هنگام پارتیشن بندی سرویس ها به bulkheads، استقرار آنها را در ماشین های مجازی، کانتینرها یا فرآیندهای جداگانه در نظر بگیرید. کانتینرها تعادل خوبی از جداسازی منابع را با سربار نسبتاً کم ارائه می دهند.
* سرویس هایی که با استفاده از پیام های ناهمزمان(asynchronous) ارتباط برقرار می کنند را می توان از طریق مجموعه های مختلف صف جدا کرد. هر صف می‌تواند مجموعه‌ای اختصاصی از نمونه‌هایی داشته باشد که پیام‌ها را در صف پردازش می‌کنند، یا یک گروه واحد از نمونه‌ها با استفاده از یک الگوریتم برای حذف و ارسال پردازش.  
* سطح دانه بندی (granularity) مربوط bulkheads ها را تعیین کنید. به عنوان مثال، اگر می‌خواهید tenant را در بین پارتیشن‌ها توزیع کنید، می‌توانید هر tenant را در یک پارتیشن جداگانه قرار دهید یا چندین tenant را در یک پارتیشن قرار دهید.  
* Monitor کردن بر performance هر پارتیشن و SLA.

## When to use this pattern

از این الگو برای موارد زیر استفاده کنید:

* منابعی را که برای مصرف مجموعه‌ای از backend services استفاده می‌شوند، جدا کنید، به‌خصوص اگر application بتواند سطحی از عملکرد را حتی زمانی که یکی از سرویس‌ها پاسخ نمی‌دهد و درست کار نمیکند را ارائه دهد.  
* مصرف کنندگان(consumers) پر اهمیت را از مصرف کنندگان معمولی جدا کنید.  
* از application در برابر خرابی های متوالی (ascading failures) محافظت کنید.

این الگو ممکن است زمانی مناسب نباشد که:

* مصرف کمتر تاثیر گذار  (Less efficient) از منابع ممکن است در پروژه قابل قبول نباشد.  
* اضافه کردن این پیچیدگی مورد نیاز نباشد.

## Example

فایل پیکربندی Kubernetes زیر یک محفظه ایزوله برای اجرای یک سرویس واحد با منابع و محدودیت های CPU و حافظه خود ایجاد می کند.

```yml
apiVersion: v1
kind: Pod
metadata:
  name: drone-management
spec:
  containers:
  - name: drone-management-container
    image: drone-service
    resources:
      requests:
        memory: "64Mi"
        cpu: "250m"
      limits:
        memory: "128Mi"
        cpu: "1"
```


