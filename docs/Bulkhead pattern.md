
الگوی Bulkhead نوعی طراحی برنامه کاربردی است که در برابر شکست(failure) مقاوم است. در معماری Bulkhead، عناصر(elements) یک application در مخزنی ایزوله می شوند تا اگر یکی از کار بیفتد، بقیه به کار خود ادامه دهند. نام آن برگرفته از پارتیشن های برش خورده (bulkheads ها) بدنه کشتی است. اگر بدنه کشتی آسیب ببیند، فقط قسمت آسیب دیده پر از آب می شود که از غرق شدن کشتی جلوگیری می کند.

## Context and problem


یک cloud-based application ممکن است شامل چندین سرویس باشد که هر سرویس یک یا چند مصرف کننده دارد. سربار بیش از حد(Excessive load) یا خرابی در یک سرویس بر همه مصرف کنندگان سرویس تأثیر می گذارد.  
  
علاوه بر این، یک مصرف کننده(consumer) ممکن است با مصرف resource برای هر request، درخواست هایی را به چندین سرویس به طور همزمان ارسال کند. هنگامی که مصرف کننده request را به سرویسی ارسال می کند که پیکربندی آن اشتباه است یا respond نمی دهد، resource مورد استفاده request  کلاینت ممکن است به موقع آزاد نشوند. با ادامه ارسال request ها برای سرویس، ممکن است این منابع تمام شود. به عنوان مثال، client's connection pool ممکن است تمام شده باشد. در آن مرحله، request های مصرف کننده برای سرویس‌های دیگر تحت تأثیر قرار می گیرد. در نهایت مصرف‌کننده(consumer) دیگر نمی‌تواند request‌هایی را برای سرویس‌های دیگر ارسال کند، نه فقط سرویس اصلی که پاسخگو نیست.

همین مسئله فرسودگی resource بر سرویس‌هایی با چندین consumer تأثیر می گذارد. تعداد زیادی درخواست از یک کلاینت ممکن است منابع موجود در سرویس را تمام کند. سایر consumerها دیگر قادر به استفاده از سرویس نیستند و باعث ایجاد یک  شکست‌های پشت سر هم و متوالی  (cascading failure effect) می شود.

## Solution

نمونه های سرویس را بر اساس بار مصرف کننده و الزامات در دسترس بودن به گروه های مختلف تقسیم بندی کنید. این طراحی به جداسازی خرابی‌ها کمک می‌کند و به شما امکان می‌دهد تا عملکرد سرویس را برای برخی از مصرف‌کنندگان، حتی در هنگام خرابی، حفظ کنید.

یک مصرف کننده همچنین می تواند منابع را پارتیشن بندی کند تا اطمینان حاصل شود که منابع استفاده شده برای فراخوانی یک سرویس بر منابع استفاده شده برای فراخوانی سرویس دیگر تأثیر نمی گذارد. برای مثال، مصرف‌کننده‌ای که چندین سرویس را فراخوانی می‌کند، ممکن است برای هر سرویس یک مخزن اتصال اختصاص داده شود. اگر سرویسی شروع به fail شدن کند، فقط بر روی connection pool اختصاص داده شده برای آن سرویس تأثیر می گذارد و به مصرف کننده اجازه می دهد تا به استفاده از سایر سرویس‌ها ادامه دهد.

مزایای این الگو عبارتند از:


	-مصرف کنندگان و سرویس‌ها را از خرابی های متوالی (cascading failures) جدا می کند. مشکلی که بر یک مصرف کننده یا سرویس تأثیر می گذارد می تواند در قسمت خود جدا شود و از شکست کل راه حل جلوگیری کند.  

	-به شما امکان می دهد در صورت خرابی سرویس، برخی از عملکردها را حفظ کنید. سایر سرویس‌ها و ویژگی های برنامه به کار خود ادامه خواهند داد.  

	-به شما امکان می دهد سرویس‌هایی را که کیفیت متفاوتی از سرویسی در حال کار  را برای applications مورد استفاده ارائه می دهند، deploy کنید. یک مجموعه consumer با اولویت بالا را می توان برای استفاده از سرویس‌هایی با اولویت بالا پیکربندی کرد.

نمودار زیر دیاگرام bulkheads را نشان می دهد که در اطراف connection pool ساخته شده اند که سرویس‌های منحصر به فردی را فراخوانی می کنند. اگر سرویس A از کار بیفتد یا مشکل دیگری ایجاد کند، connection pool ایزوله یا جداسازی می شود، بنابراین فقط workloadهایی با استفاده از thread pool اختصاص داده شده به سرویس A تحت تأثیر قرار می گیرند. بارهای کاری که از سرویس B و C استفاده می کنند تحت تأثیر قرار نمی گیرند و می توانند بدون وقفه به کار خود ادامه دهند.

![[Pasted image 20230828191703.png]]

نمودار بعدی چندین client را نشان می دهد که با یک سرویس ارتباط می گیرند. به هر i یک نمونه سرویس جداگانه اختصاص داده می شود. کلاینت 1 که request های زیادی کرده است و instance آن را تحت تاثیر قرار داده است. از آنجایی که هر instance از سرویس از بقیه سرویس‌ها جدا شده است، سایر کلاینت‌ها می توانند به برقراری تماس و ارتباطات ادامه دهند.

![[Pasted image 20230828191907.png]]

## Issues and considerations


* پارتیشن هایی را در مورد نیازهای business و technical برنامه تعریف کنید.
* هنگام تقسیم services یا consumers به کمک  bulkheadsها، سطح ایزوله ارائه شده توسط technology و همچنین هزینه های سربار را از نظر هزینه، عملکرد و مدیریت در نظر بگیرید.
* ترکیب bulkheadsها با الگوهای retry, circuit breaker  و throttling را در نظر بگیرید تا مدیریت خطای پیچیده تری(fault handling) را ارائه دهید.
* هنگام تقسیم consumers به bulkheads، استفاده از فرآیندها، thread pools و semaphores را در نظر بگیرید. پروژه هایی مانند [resilience4j](https://github.com/resilience4j/resilience4j) و [Polly](https://github.com/App-vNext/Polly) چارچوبی را برای ایجاد bulkheads مصرفی ارائه می دهند.
* هنگام پارتیشن بندی سرویس ها به bulkheads، استقرار آنها را در ماشین های مجازی، کانتینرها یا فرآیندهای جداگانه در نظر بگیرید. کانتینرها تعادل خوبی از جداسازی منابع را با سربار نسبتاً کم ارائه می دهند.
* سرویس هایی که با استفاده از پیام های ناهمزمان(asynchronous) ارتباط برقرار می کنند را می توان از طریق مجموعه های مختلف صف جدا کرد. هر صف می‌تواند مجموعه‌ای اختصاصی از نمونه‌هایی داشته باشد که پیام‌ها را در صف پردازش می‌کنند، یا یک گروه واحد از نمونه‌ها با استفاده از یک الگوریتم برای حذف و ارسال پردازش.  
* سطح دانه بندی (granularity) مربوط bulkheads ها را تعیین کنید. به عنوان مثال، اگر می‌خواهید tenant را در بین پارتیشن‌ها توزیع کنید، می‌توانید هر tenant را در یک پارتیشن جداگانه قرار دهید یا چندین tenant را در یک پارتیشن قرار دهید.  
* Monitor کردن بر performance هر پارتیشن و SLA.

## When to use this pattern

از این الگو برای موارد زیر استفاده کنید:

* منابعی را که برای مصرف مجموعه‌ای از backend services استفاده می‌شوند، جدا کنید، به‌خصوص اگر application بتواند سطحی از عملکرد را حتی زمانی که یکی از سرویس‌ها پاسخ نمی‌دهد و درست کار نمیکند را ارائه دهد.  
* مصرف کنندگان(consumers) پر اهمیت را از مصرف کنندگان معمولی جدا کنید.  
* از application در برابر خرابی های متوالی (ascading failures) محافظت کنید.

این الگو ممکن است زمانی مناسب نباشد که:

* مصرف کمتر تاثیر گذار  (Less efficient) از منابع ممکن است در پروژه قابل قبول نباشد.  
* اضافه کردن این پیچیدگی مورد نیاز نباشد.

## Example

فایل پیکربندی Kubernetes زیر یک محفظه ایزوله برای اجرای یک سرویس واحد با منابع و محدودیت های CPU و حافظه خود ایجاد می کند.

```yml
apiVersion: v1
kind: Pod
metadata:
  name: drone-management
spec:
  containers:
  - name: drone-management-container
    image: drone-service
    resources:
      requests:
        memory: "64Mi"
        cpu: "250m"
      limits:
        memory: "128Mi"
        cpu: "1"
```


