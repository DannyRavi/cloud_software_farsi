# ‏Rate Limiting pattern

بسیاری از سرویس‌ها برای کنترل منابعی که مصرف می‌کنند از الگوی «محدودسازی» ([throttling ](./Throttling%20pattern.md) pattern) استفاده می‌کنند. این الگو، محدودیت‌هایی را بر نرخ دسترسی سایر برنامه‌ها یا سرویس‌ها به سرویس مورد نظر اعمال می‌کند.

استفاده از الگوی «محدود کردن نرخ» (rate limiting pattern) می‌تواند به شما در جلوگیری یا به حداقل رساندن خطاهای «محدودسازی» مرتبط با این محدودیت‌ها کمک کند و همچنین پیش‌بینی دقیق‌تر توان عملیاتی (throughput) را برایتان به همراه داشته باشد.

الگوی «محدود کردن نرخ» در بسیاری از سناریوها مناسب است، اما به طور خاص برای وظایف خودکار تکراری در مقیاس بزرگ مانند پردازش دسته‌ای (batch processing) بسیار مفید است.

## **زمینه و مشکل**

انجام تعداد زیادی عملیات با استفاده از یک سرویس محدود شده (throttled service) می‌تواند منجر به افزایش ترافیک و توان عملیاتی شود، زیرا باید درخواست‌‌های رد شده را ردیابی کنید و سپس دوباره آن عملیات را retry یا تست کنید. با افزایش تعداد عملیات‌ها، یک throttling limit ممکن است چندین دفعه ارسال مجدد داد‌ه‌ها را نیاز داشته باشد که منجر به افزایش کارایی می‌شود.  


به عنوان مثال، retry‌های ساده زیر را در مورد فرآیند خطا برای وارد کردن داده‌ها به Azure Cosmos DB در نظر بگیرید:

1- برنامه شما باید 10000 رکورد را در Azure Cosmos DB وارد کند. دریافت هر رکورد 10 واحد درخواست یا واحد‌های درخواستی (Request Units) یا به اختصار RUs هزینه دارد که در مجموع به 100000 RU برای تکمیل کردن این کار نیاز دارد.

2- نمونه Azure Cosmos DB شما دارای 20000 RU ظرفیت تدارک دیده شده است.

3- شما تمام 10000 رکورد را به Azure Cosmos DB ارسال می‌کنید. 2000 رکورد با موفقیت نوشته شده و 8000 رکورد ثبت شده است.

4- شما 8000 رکورد باقیمانده را به Azure Cosmos DB ارسال می‌کنید. 2000 رکورد با موفقیت نوشته شده و 6000 رکورد ثبت شده است.

5- شما 6000 رکورد باقیمانده را به Azure Cosmos DB ارسال می‌کنید. 2000 رکورد با موفقیت نوشته شده و 4000 رکورد ثبت شده است.

6- شما 4000 رکورد باقیمانده را به Azure Cosmos DB ارسال می‌کنید. 2000 رکورد با موفقیت نوشته شده و 2000 رکورد ثبت شده است.

7- شما 2000 رکورد باقیمانده را به Azure Cosmos DB ارسال می‌کنید. همه با موفقیت نوشته شده‌اند.


کار وارد کردن داده‌ها با موفقیت انجام شد، اما تنها پس از ارسال 30000 رکورد به Azure Cosmos DB حتی اگر کل مجموعه فقط از 10000 رکورد تشکیل شده بود.

در مثال بالا عوامل دیگری وجود دارد که باید در نظر گرفته شود:  
  

-‏ تعداد زیاد خطاها همچنین می‌تواند منجر به کار اضافی برای log این خطاها و پردازش داده‌های ثبت شده را حاصل شود. این رویکرد ساده 20,000 خطا را مدیریت کرده است، و log این خطاها ممکن است هزینه پردازش، حافظه یا منابع ذخیره‌سازی را به همراه داشته باشد.

-‏‏ بدون اینکه از محدودیت‌های اعمال‌شده‌ی سرویس انتقال (throttling limits) اطلاعی داشته باشد، رویکرد ساده نمی‌تواند پیش‌بینی کند که فرآیند انتقال داده چقدر طول خواهد کشید. محدود کردن نرخ (Rate limiting) به شما این امکان را می‌دهد که زمان مورد نیاز برای انتقال را محاسبه کنید.
## راه حل

محدودیت نرخ یا Rate limit می‌تواند ترافیک شما را کاهش دهد و با کاهش تعداد رکورد‌های ارسال شده به یک سرویس در یک دوره زمانی معین، به طور محسوسی توان عملیاتی را بهبود بخشد.  
  
یک سرویس ممکن است بر اساس معیار‌های مختلف در طول زمان throttle شود، مانند:

*‏ تعداد عملیات‌ها (مثلاً 20 درخواست در ثانیه).  
*‏ مقدار داده‌ها (مثلاً 2 گیگابایت در دقیقه).  
*‏ هزینه‌‌های مالی نسبی عملیات (به عنوان مثال، 20000 ریال در ثانیه).

**محدود کردن نرخ برای مدیریت مصرف سرویس** 

فارغ از معیاری که برای محدودسازی (throttling) استفاده می‌شود، پیاده‌سازی محدود کردن نرخ (rate limit) شما شامل کنترل تعداد و/یا اندازه عملیات‌هایی است که در یک بازه زمانی مشخص به سرویس ارسال می‌شود. این کار به شما کمک می‌کند تا در عین حال که از ظرفیت محدودسازی سرویس تجاوز نمی‌کنید، استفاده خود را از آن بهینه کنید.

**محدود کردن نرخ برای عدم تطابق سرعت**

در سناریوهایی که APIهای شما می‌توانند درخواست‌ها را سریع‌تر از آنچه سرویس‌های انتقال محدود شده (throttled) اجازه می‌دهند، مدیریت کنند، باید نحوه استفاده سریع از سرویس را مدیریت کنید. با این حال، تنها در نظر گرفتن محدودسازی (throttling) به عنوان یک مشکل عدم تطابق سرعت انتقال داده؛ به سادگی بافر کردن درخواست‌های انتقال تا زمانی که سرویس محدود شده بتواند به آن برسد، ریسک‌پذیر است. در صورتی که برنامه شما در این سناریو دچار خطا (crash) شود، خطر از دست رفتن هر گونه داده‌ای که بافر شده است را به همراه دارد.

**استفاده از سیستم پیام‌رسانی بادوام برای جلوگیری از ریسک**

برای جلوگیری از این خطر، رکورد‌های خود را به یک سیستم پیام رسانی (messaging)  بادوام بفرستید که بتواند میزان مصرف کامل داد‌ه‌ها در سرویس شما را کنترل کند. (سرویس‌هایی مانند Azure Event Hubs می‌توانند میلیونها عملیات را در ثانیه انجام دهند). سپس می‌توانید از یک یا چند پردازشگر  برای خواندن رکوردها از سیستم پیام‌رسانی با نرخ کنترل‌شده‌ای استفاده کنید که در محدوده‌‌های سرویس throttled است. ارسال رکوردها به سیستم پیام‌رسانی می‌تواند میزان مصرف حافظه داخلی را بهینه کند و به شما امکان می‌دهد که فقط رکورد‌هایی را که در یک بازه زمانی معین پردازش می‌شوند را بعد از پردازش حذف کنید.  
  
‏ Azure چندین سرویس پیام رسانی بادوام ارائه می‌دهد که می‌توانید با این الگو از آنها استفاده کنید، از جمله:

- **Azure Event Hubs:** یک سرویس پیام‌رسانی با حجم بالا و تأخیر کم است که می‌تواند میلیون‌ها رویداد را در ثانیه مدیریت کند.
- **Azure Service Bus:** یک سرویس پیام‌رسانی انعطاف‌پذیر است که از پیام‌رسانی صف و انتشار/اشتراک (publish/subscribe) پشتیبانی می‌کند.

- **Azure Service Bus:** یک سرویس پیام‌رسانی انعطاف‌پذیر است که از پیام‌رسانی صف و انتشار/اشتراک (publish/subscribe) پشتیبانی می‌کند.
- **Azure Queue Storage:** یک سرویس ذخیره‌سازی ابری مقیاس‌پذیر برای پیام‌های بزرگ است که برای صف کردن ایمن و قابل اعتماد پیام‌ها در برنامه‌های ابری طراحی شده است.
- **Azure Event Hubs:** یک سرویس پیام‌رسانی با حجم بالا و تأخیر کم است که می‌تواند میلیون‌ها رویداد را در ثانیه مدیریت کند.


![rate-limiting-pattern-01](../assets/other/rate-limiting-pattern-01.png)

وقتی رکوردها را ارسال می‌کنید، ممکن است دوره زمانی که برای انتشار رکوردها استفاده می‌کنید  نسبت به دوره زمانی که از سرویس محدودسازی  می‌گذرد دقیق‌تر باشد. سیستم‌ها اغلب محدودیت‌ها را بر اساس بازه‌‌های زمانی تنظیم می‌کنند که به راحتی می‌توانید آن را درک کرده و با آن کار کنید. با این حال، برای رایانه ‌ای که یک سرویس را اجرا می‌کند، این بازه‌های زمانی ممکن است در مقایسه با سرعت پردازش اطلاعات بسیار طولانی باشد. به عنوان مثال، یک سیستم ممکن است در هر ثانیه یا در دقیقه محدود (throttle) شود، اما معمولاً  این کد در حدود نانوثانیه یا میلی‌ثانیه پردازش می‌شود.  

در حالی که ضروری نیست ولی توصیه می‌شود برای بهبود توان عملیاتی، مقادیر کمتری از رکوردها را به دفعات بیشتر ارسال کنید. پس به جای اینکه بخواهید یک بار در ثانیه یا یک بار در دقیقه موارد مورد نظر را به صورت دسته‌ای منتشر کنید، می‌توانید برای حفظ میزان مصرف منابع خود (حافظه، CPU، شبکه و غیره) با سرعت یکنواخت‌تر عمل کنید و از به وقوع پیوستن گلوگاه در سیستم جلوگیری کنید. به عنوان مثالی برای حجوم درخواست‌‌های لحظه‌ای، اگر یک سرویس اجازه 100 عملیات در ثانیه را بدهد، پیاده سازی یک محدود کننده نرخ (rate limiter) ممکن است درخواستها را با آزاد کردن 20 عملیات در هر 200 میلی ثانیه یکسان کند، همانطور که در نمودار زیر نشان داده شده است.


![rate-limiting-pattern-02](../assets/other/rate-limiting-pattern-02.png)

**محدود کردن نرخ برای فرایندهای غیرهماهنگ**

علاوه بر این، گاهی اوقات لازم است چندین فرآیند ناهماهنگ یک سرویس را به اشتراک بگذارند. برای پیاده سازی محدودیت نرخ در این سناریو، می‌توانید به طور منطقی ظرفیت سرویس را تقسیم بندی کنید و سپس از یک سیستم حذف متقابل توزیع شده برای مدیریت قفل‌های انحصاری روی آن پارتیشنها استفاده کنید. سپس فرآیند‌های ناهماهنگ می‌توانند هر زمان که به ظرفیت نیاز داشته باشند برای قفل کردن آن پارتیشنها رقابت کنند. برای هر پارتیشنی که یک فرآیند برای آن قفل نگه می‌دارد، مقدار مشخصی ظرفیت به آن داده می‌شود.  
  
به عنوان مثال، اگر سیستم محدود شده حدود 500 درخواست در ثانیه را اجازه مجاز می‌داند، ممکن است شما 20 پارتیشن به ارزش 25 درخواست در هر ثانیه  برای هر کدام ایجاد کنید. اگر فرآیندی نیاز به صدور 100 درخواست داشته باشد، ممکن است از سیستم ممانعت متقابل توزیع شده (distributed mutual exclusion) برای چهار پارتیشن دیگر درخواست کند. درنتیجه ممکن است سیستم دو پارتیشن به مدت 10 ثانیه را در دسترس قرار دهد. سپس این فرآیند به 50 درخواست در ثانیه محدودیت نرخ یا rate limit می‌دهد و تسک را در دو ثانیه انجام می‌دهد و سپس قفل را آزاد می‌کند.


یکی از راه‌‌های پیاده‌سازی این الگو، استفاده از Azure Storage است. در این سناریو، شما  یک Blob (شیء باینری بزرگ) یه مقدار 0 بایتی برای هر پارتیشن منطقی در یک ظرف ایجاد می‌کنید. سپس برنامه‌‌های شما می‌توانند مستقیماً برای مدت کوتاهی (مثلاً 15 ثانیه) در برابر آن Blob قرارداد‌های انحصاری ([exclusive leases](https://learn.microsoft.com/en-us/rest/api/storageservices/lease-blob)) دریافت کنند. برای هر قرارداد اجاره‌ که یک برنامه اعطا می‌شود، آن برنامه می‌تواند از ظرفیت آن پارتیشن استفاده کند. سپس برنامه باید زمان قرارداد/اجاره را ردیابی کند تا پس از انقضای آن، بتواند از ظرفیتی که داده شده است دیگر استفاده نکند.  هنگام پیاده سازی این الگو، اغلب اوقات می خواهید هر فرآیند زمانی که به ظرفیت نیاز دارد، تلاش کند تا یک پارتیشن تصادفی را اجاره کند.
 
  
برای کاهش بیشتر تاخیر، ممکن است مقدار کمی از ظرفیت انحصاری را برای هر فرآیند اختصاص دهید. در این صورت یک فرآیند تنها در صورتی به دنبال دریافت اجاره ظرفیت مشترک است که نیاز به فراتر رفتن از ظرفیت رزرو شده خود داشته باشد.

![rate-limiting-pattern-03](../assets/other/rate-limiting-pattern-03.png)

به عنوان جایگزینی برای Azure Storage، می‌توانید این نوع سیستم مدیریت قرارداد را با استفاده از فناوری‌‌هایی مانند [Zookeeper](https://zookeeper.apache.org/), [Consul](https://www.consul.io/), [etcd](https://etcd.io/), [Redis/Redsync](https://github.com/go-redsync/redsync) و غیره پیاده‌سازی کنید.


## مسائل و ملاحظات:

*‏ در حالی که الگوی محدود کننده نرخ می‌تواند تعداد خطا‌های محدودسازی سرویس را کاهش دهد، برنامه شما همچنان باید به درستی خطا‌های محدودسازی را که ممکن است رخ دهد مدیریت کند.  

*‏ اگر برنامه شما دارای چندین جریان کاری(workstreams) است که به همان سرویس محدود شده دسترسی دارند، پس باید همه آنها را در استراتژی محدود کردن نرخ خود ادغام کنید. به عنوان مثال، ممکن است از بارگذاری انبوه رکوردها (bulk loading records) در پایگاه داده پشتیبانی کنید اما همزمان از اعمال کوئری روی رکوردها را در همان پایگاه داده پشتیبانی کنید. می‌توانید با اطمینان از اینکه همه جریان‌‌های کاری از طریق مکانیسم محدودکننده نرخ یکسانی عبور می‌کنند، ظرفیت را مدیریت کنید. از طرف دیگر، می‌توانید ظرفیت‌های جداگانه ‌ای را برای هر جریان کاری در نظر بگیرید. 

*‏ سرویس محدود شده ممکن است در چندین برنامه استفاده شود. در برخی - اما نه همه - موارد، می‌توان نوع مصرف را هدایت کرد (همانطور که در بالا نشان داده شده است). اگر شروع به مشاهده تعداد بیشتر از حد انتظار خطا‌های محدودسازی کردید، ممکن است نشانه اختلاف بین برنامه‌هایی باشد که به یک سرویس دسترسی دارند. اگر چنین است، ممکن است لازم باشد به طور موقت میزان توان اعمال شده توسط مکانیسم محدودکننده نرخ خود را کاهش دهید تا زمانی که استفاده از سایر برنامه‌ها کاهش یابد.

## **چه زمانی از این الگو استفاده کنیم؟**

از این الگو برای موارد زیر استفاده کنید:  
  
*‏ کاهش خطاهای محدودسازی ناشی از یک سرویس با محدودیت نرخ 

*‏ کاهش ترافیک در مقایسه با یک روش ساده retry بر روی خطاها.  

*‏ کاهش مصرف حافظه با خروج از صف (dequeue) رکوردها فقط در زمانی که ظرفیت پردازش آنها وجود دارد.

## مثال

این برنامه نمونه به کاربران اجازه می دهد تا رکوردهای با انواع مختلف را به یک API ارسال کنند. برای هر نوع رکورد یک پردازشگر کار اختصاصی (job processor) وجود دارد که مراحل زیر را انجام می دهد:  
  
1- اعتبار سنجی  (Validation)
2- غنی‌سازی داده‌ ها  (Enrichment)
3- درج رکورد در پایگاه داده (Insertion)

همه اجزای برنامه (API، job processor A، و  job processor B ) فرآیند‌های جداگانه ‌ای هستند که ممکن است به طور مستقل مقیاس‌بندی شوند. این فرآیندها مستقیماً با یکدیگر ارتباط برقرار نمی‌کنند.

![rate-limiting-pattern-04](../assets/other/rate-limiting-pattern-04.png)


1- یک کاربر 10000 رکورد از نوع A را به API ارسال می‌کند.  
2- API آن 10000 رکورد را در صف A قرار می‌دهد.  
3- یک کاربر 5000 رکورد از نوع B را به API ارسال می‌کند.  
4- API آن 5000 رکورد را در صف B قرار می‌دهد.  
5- Job Processor A می‌بیند که Queue A دارای رکورد است و سعی می‌کند یک قرارداد(lease) انحصاری در blob 2 به دست آورد.  
6- Job Processor B می‌بیند که Queue B دارای رکورد است و سعی می‌کند یک قرارداد انحصاری در blob 2 به دست آورد.  
7- Job Processor A موفق به دریافت قرارداد نامه نمی‌شود.  
8- Job Processor B قرارداد blob 2 را به مدت 15 ثانیه دریافت می‌کند. اکنون می‌تواند درخواست‌های محدود به پایگاه داده را با نرخ 100 در ثانیه رتبه بندی کند.  
9- Job Processor B 100 رکورد را از صف B جدا می‌کند و آنها را می‌نویسد.  
10- یک ثانیه می‌گذرد.  
11- Job Processor A می‌بیند که Queue A رکورد‌های بیشتری دارد و سعی می‌کند قرارداد انحصاری را در blob 6 به دست آورد.  
12- Job Processor B می‌بیند که Queue B رکورد‌های بیشتری دارد و سعی می‌کند قرارداد انحصاری را در blob 3 به دست آورد.  
13- Job Processor A قرارداد blob 6 را به مدت 15 ثانیه دریافت می‌کند. اکنون می‌تواند درخواست‌های محدود به پایگاه داده را با نرخ 100 در ثانیه رتبه بندی کند.  
14- Job Processor B قرارداد blob 3 را به مدت 15 ثانیه دریافت می‌کند. اکنون می‌تواند درخواست‌‌های محدود به پایگاه داده را با نرخ 200 در ثانیه رتبه بندی کند. (همچنین قرارداد  2 blob را نیز در اختیار دارد.)  
15- Job Processor A 100 رکورد را از صف A جدا می‌کند و آنها را می‌نویسد.  
16- Job Processor B 200 رکورد را از صف B جدا می‌کند و آنها را می‌نویسد.  
17- یک ثانیه می‌گذرد.  
18- Job Processor A می‌بیند که Queue A رکورد‌های بیشتری دارد و سعی می‌کند یک قرارداد انحصاری در blob 0 به دست آورد.  
19- Job Processor B می‌بیند که Queue B رکورد‌های بیشتری دارد و سعی می‌کند یک قرارداد انحصاری در blob 1 به دست آورد.  
20- Job Processor A قرارداد blob 0 را به مدت 15 ثانیه دریافت می‌کند. اکنون می‌تواند درخواست‌های محدود به پایگاه داده را با نرخ 200 در ثانیه رتبه بندی کند. (همچنین قرارداد blob 6 را نیز دارد.)  
21- Job Processor B قرارداد blob 1 را به مدت 15 ثانیه دریافت می‌کند. اکنون می‌تواند درخواست‌های محدود به پایگاه داده را با نرخ 300 در ثانیه رتبه بندی کند. (همچنین قرارداد blob 2 و 3 را نیز دارد.)  
22- Job Processor A 200 رکورد را از صف A جدا می‌کند و آنها را می‌نویسد.  
23- Job Processor B 300 رکورد را از صف B جدا می‌کند و آنها را می‌نویسد.  
24- و غیره...  

**انقضای اجاره و کاهش درخواست‌ها**

پس از گذشت 15 ثانیه، ممکن است یکی یا هر دو کار همچنان تکمیل نشوند. با منقضی شدن اجاره ها، یک پردازشگر همچنین باید تعداد درخواست‌هایی را که از صف خارج (dequeue) کرده و می‌نویسد، کاهش دهد.

**پیاده سازی در زبان‌های برنامه نویسی**

پیاده سازی این الگو که در Go پیاده سازی شده است در [GitHub](https://github.com/mspnp/go-batcher) موجود است و همینطور پیاده سازی جاوا در [GitHub](https://github.com/Azure-Samples/java-rate-limiting-pattern-sample) در دسترس است.

## منابع مرتبط

الگوها و راهنمایی‌‌های زیر نیز ممکن است هنگام اجرای این الگو مرتبط باشند:  
  
*‏ الگوی محدودسازی  یا [Throttling](./Throttling%20pattern.md). الگوی محدود کننده نرخ که در اینجا مورد بحث قرار می‌گیرد، به طور معمول در پاسخ به سرویسی که محدود شده است (throttled) پیاده‌سازی می‌شود.

*‏ الگوی بازتکرار یا [Retry](./Retry%20pattern.md). هنگامی که درخواست‌ها برای سرویس محدود شده شده منجر به خطا‌های محدودسازی می‌شوند، معمولاً مناسب است که پس از یک بازه زمانی مناسب دوباره آن‌ها را retry کنید.  

این الگو با الگوی تراز سطح  بار مبتنی بر صف ([Queue-Based Load Leveling](./Queue-Based%20Load%20Leveling%20pattern.md) مشابه است اما از چند جهت کلیدی با الگوی محدود کردن نرخ که در این قسمت بیان شد متفاوت است:

1- محدود کردن نرخ (Rate limiting) لزوماً نیازی به استفاده از صف برای مدیریت بار ندارد، اما نیاز به استفاده از یک سرویس پیام رسانی بادوام دارد. به عنوان مثال، یک الگوی محدود کننده نرخ می‌تواند از سرویس‌هایی مانند  Apache Kafka یا Azure Event Hubs استفاده کند.  

2- الگوی محدود کننده نرخ، مفهوم یک سیستم ممانعت متقابل توزیع شده (distributed mutual exclusion) را در پارتیشنها معرفی می‌کند، که به شما امکان می‌دهد ظرفیت چندین فرآیند ناهماهنگ را که با یک سرویس محدود شده ارتباط برقرار می‌کنند را مدیریت کنید.

3- یک الگوی تراز سطح بار مبتنی بر صف (queue-based load leveling) در هر زمان که عدم تطابق کارکرد بین سرویس‌ها یا  بهبود انعطاف‌پذیری وجود داشته باشد، قابل اجرا است. این مورد باعث می‌شود که الگوی گسترده‌تری نسبت به محدود کردن نرخ، که به طور خاص به دسترسی موثر به یک سرویس محدود شده می‌پردازد را داشته باشد.

