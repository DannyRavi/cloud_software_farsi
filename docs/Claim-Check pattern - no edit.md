یک پیام بزرگ را به یک چک ادعا و یک محموله تقسیم کنید. چک ادعا را به پلتفرم پیام رسانی ارسال کنید و محموله را در یک سرویس خارجی ذخیره کنید. این الگو اجازه می دهد تا پیام های بزرگ پردازش شوند، در حالی که از گذرگاه پیام و مشتری در برابر غرق شدن یا کاهش سرعت محافظت می کند. این الگو همچنین به کاهش هزینه ها کمک می کند، زیرا ذخیره سازی معمولاً ارزان تر از واحدهای منبع استفاده شده توسط پلت فرم پیام رسانی است.  
  
این الگو به عنوان پیام رسانی مبتنی بر مرجع نیز شناخته می شود و در اصل در کتاب الگوهای یکپارچه سازی سازمانی توسط گرگور هوپ و بابی وولف توضیح داده شده است.

## Context and problem

یک معماری مبتنی بر پیام در برخی مواقع باید قادر به ارسال، دریافت و دستکاری پیام های بزرگ باشد. چنین پیام هایی ممکن است حاوی هر چیزی باشد، از جمله تصاویر (به عنوان مثال، اسکن MRI)، فایل های صوتی (به عنوان مثال، تماس های مرکز تماس)، اسناد متنی، یا هر نوع داده باینری با اندازه دلخواه.  
  
ارسال چنین پیام های بزرگ به طور مستقیم به گذرگاه پیام توصیه نمی شود، زیرا آنها نیاز به منابع و پهنای باند بیشتری برای مصرف دارند. پیام‌های بزرگ همچنین می‌توانند کل راه‌حل را کند کنند، زیرا پلتفرم‌های پیام‌رسان معمولاً برای رسیدگی به مقادیر عظیمی از پیام‌های کوچک به خوبی تنظیم می‌شوند. همچنین، اکثر پلتفرم‌های پیام‌رسان محدودیت‌هایی در اندازه پیام دارند، بنابراین ممکن است لازم باشد برای پیام‌های بزرگ این محدودیت‌ها را دور بزنید.

## Solution

کل بار پیام را در یک سرویس خارجی مانند پایگاه داده ذخیره کنید. ارجاع به بار ذخیره شده را دریافت کنید و فقط آن مرجع را به گذرگاه پیام ارسال کنید. مرجع مانند چک ادعایی عمل می‌کند که برای بازیابی یک چمدان استفاده می‌شود، از این رو نام الگوی آن است. مشتریان علاقه مند به پردازش آن پیام خاص می توانند در صورت نیاز از مرجع به دست آمده برای بازیابی محموله استفاده کنند.

![[Pasted image 20231203233401.png]]

1- پیام فرستادن  
2- ذخیره پیام در فروشگاه داده  
3- مرجع پیام را در نوبت قرار دهید  
4- مرجع پیام را بخوانید  
5- پیام را بازیابی کنید  
6- پیام را پردازش کنید

## Issues and considerations

هنگام تصمیم گیری در مورد نحوه اجرای این الگو به نکات زیر توجه کنید:  
  
* اگر نیازی به آرشیو کردن پیام‌ها ندارید، پس از مصرف، داده‌های پیام را حذف کنید. اگرچه ذخیره سازی حباب نسبتاً ارزان است، اما در درازمدت مقداری هزینه دارد، به خصوص اگر داده های زیادی وجود داشته باشد. حذف پیام می تواند به صورت همزمان توسط برنامه ای که پیام را دریافت و پردازش می کند یا به صورت ناهمزمان توسط یک فرآیند اختصاصی جداگانه انجام شود. رویکرد ناهمزمان داده‌های قدیمی را بدون تأثیر بر توان عملیاتی و عملکرد پردازش پیام برنامه دریافت‌کننده حذف می‌کند.  
  
* ذخیره و بازیابی پیام باعث ایجاد مقداری سربار و تأخیر اضافی می شود. ممکن است بخواهید منطق را در برنامه ارسال کننده پیاده سازی کنید تا از این الگو فقط زمانی استفاده کنید که اندازه پیام از حد داده های گذرگاه پیام فراتر رود. این الگو برای پیام های کوچکتر نادیده گرفته می شود. این رویکرد منجر به یک الگوی بررسی ادعای مشروط می شود.

## When to use this pattern

این الگو را می توان هر زمان که پیامی با محدودیت پیام پشتیبانی شده فناوری گذرگاه پیام انتخاب شده مطابقت نداشته باشد، استفاده شود. به عنوان مثال، سرویس Bus در حال حاضر دارای محدودیت 100 مگابایتی (سطح برتر) است، در حالی که Event Grid حداکثر 1 مگابایت پیام را پشتیبانی می کند.  
  
این الگو همچنین می تواند مورد استفاده قرار گیرد در صورتی که محموله فقط توسط سرویس هایی که مجاز به دیدن آن هستند قابل دسترسی باشد. با تخلیه بار به یک منبع خارجی، قوانین احراز هویت و مجوزهای سخت گیرانه تری را می توان وضع کرد تا اطمینان حاصل شود که هنگام ذخیره داده های حساس در محموله، امنیت اعمال می شود.

## Examples

در Azure می توان این الگو را به چند روش و با تکنولوژی های مختلف پیاده سازی کرد اما دو دسته اصلی وجود دارد. در هر دو مورد، گیرنده مسئولیت دارد چک ادعا را بخواند و از آن برای بازیابی محموله استفاده کند.  
  
* تولید خودکار ادعای چک. این رویکرد از Azure Event Grid برای تولید خودکار چک ادعا و فشار دادن آن به گذرگاه پیام استفاده می‌کند.  
  
* تولید چک ادعای دستی در این رویکرد فرستنده مسئولیت مدیریت بار را بر عهده دارد. فرستنده محموله را با استفاده از سرویس مناسب ذخیره می کند، چک ادعا را دریافت یا تولید می کند و چک ادعا را به اتوبوس پیام ارسال می کند.  
  
Event Grid یک سرویس مسیریابی رویداد است و سعی می کند رویدادها را در مدت زمان قابل تنظیم تا 24 ساعت ارائه دهد. پس از آن، رویدادها یا کنار گذاشته می شوند یا با حروف مرده نوشته می شوند. اگر نیاز دارید بارهای رویداد را بایگانی کنید یا جریان رویداد را دوباره پخش کنید، می‌توانید اشتراک Event Grid را به Event Hubs یا Queue Storage اضافه کنید، جایی که پیام‌ها را می‌توان برای مدت طولانی‌تری حفظ کرد و بایگانی کردن پیام‌ها پشتیبانی می‌شود. برای اطلاعات در مورد تنظیم دقیق تحویل پیام شبکه رویداد و تلاش مجدد، و پیکربندی حروف مرده، به خط مشی‌های نامه مرده و امتحان مجدد مراجعه کنید.

### Automatic claim-check generation with Blob Storage and Event Grid

در این روش، فرستنده محموله پیام را در یک محفظه ذخیره‌سازی حباب Azure مشخص می‌کند. Event Grid به طور خودکار یک برچسب/مرجع تولید می کند و آن را به یک گذرگاه پیام پشتیبانی شده مانند صف های ذخیره سازی Azure ارسال می کند. گیرنده می تواند صف را نظرسنجی کند، پیام را دریافت کند و سپس از داده های مرجع ذخیره شده برای دانلود مستقیم از Blob Storage استفاده کند.  
  
همان پیام شبکه رویداد را می‌توان مستقیماً توسط توابع Azure مصرف کرد، بدون اینکه نیازی به عبور از یک گذرگاه پیام باشد. این رویکرد از ماهیت بدون سرور هر دو شبکه رویداد و توابع بهره کامل می برد.  
  
شما می توانید کد نمونه برای این رویکرد را در اینجا بیابید.

### Event Grid with Event Hubs

مشابه مثال قبلی، Event Grid به طور خودکار پیامی را هنگامی که یک محموله در یک محفظه Azure Blob نوشته می شود تولید می کند. اما در این مثال، گذرگاه پیام با استفاده از Event Hubs پیاده سازی شده است. یک مشتری می تواند خود را ثبت کند تا جریان پیام ها را همانطور که در مرکز رویداد نوشته می شود دریافت کند. مرکز رویداد همچنین می‌تواند برای آرشیو کردن پیام‌ها پیکربندی شود و آنها را به‌عنوان یک فایل Avro در دسترس قرار دهد که می‌توان با استفاده از ابزارهایی مانند Apache Spark، Apache Drill یا هر یک از کتابخانه‌های Avro موجود، پرس و جو کرد.  
  
شما می توانید کد نمونه برای این رویکرد را در اینجا بیابید.

### Claim check generation with Service Bus

این راه حل از یک پلاگین Service Bus خاص، ServiceBus.AttachmentPlugin بهره می برد، که پیاده سازی گردش کار بررسی ادعا را آسان می کند. این افزونه هر پیامی را به یک پیوست تبدیل می‌کند که هنگام ارسال پیام در فضای ذخیره‌سازی Azure Blob ذخیره می‌شود.

```csharp
using ServiceBus.AttachmentPlugin;
...

// Getting connection information
var serviceBusConnectionString = Environment.GetEnvironmentVariable("SERVICE_BUS_CONNECTION_STRING");
var queueName = Environment.GetEnvironmentVariable("QUEUE_NAME");
var storageConnectionString = Environment.GetEnvironmentVariable("STORAGE_CONNECTION_STRING");

// Creating config for sending message
var config = new AzureStorageAttachmentConfiguration(storageConnectionString);

// Creating and registering the sender using Service Bus Connection String and Queue Name
var sender = new MessageSender(serviceBusConnectionString, queueName);
sender.RegisterAzureStorageAttachmentPlugin(config);

// Create payload
var payload = new { data = "random data string for testing" };
var serialized = JsonConvert.SerializeObject(payload);
var payloadAsBytes = Encoding.UTF8.GetBytes(serialized);
var message = new Message(payloadAsBytes);

// Send the message
await sender.SendAsync(message);
```

پیام سرویس اتوبوس به عنوان یک صف اعلان عمل می کند که مشتری می تواند در آن مشترک شود. هنگامی که مصرف کننده پیام را دریافت می کند، افزونه امکان خواندن مستقیم داده های پیام را از Blob Storage فراهم می کند. سپس می توانید نحوه پردازش بیشتر پیام را انتخاب کنید. مزیت این رویکرد این است که جریان کار بررسی ادعا را از فرستنده و گیرنده انتزاع می کند.  
  
شما می توانید کد نمونه برای این رویکرد را در اینجا بیابید.

### Manual claim-check generation with Kafka

در این مثال، یک مشتری کافکا، محموله را در Azure Blob Storage می‌نویسد. سپس یک پیام اعلان با استفاده از رویداد هاب های فعال کافکا ارسال می کند. مصرف کننده پیام را دریافت می کند و می تواند از Blob Storage به محموله دسترسی پیدا کند. این مثال نشان می دهد که چگونه می توان از یک پروتکل پیام رسانی متفاوت برای پیاده سازی الگوی بررسی ادعا در Azure استفاده کرد. به عنوان مثال، ممکن است لازم باشد از مشتریان فعلی کافکا حمایت کنید.  
  
شما می توانید کد نمونه برای این رویکرد را در اینجا بیابید.
## Next steps

نمونه هایی که در بالا توضیح داده شد در GitHub موجود هستند.  
سایت Enterprise Integration Patterns توضیحاتی در مورد این الگو دارد.  
برای مثال دیگر، به برخورد با پیام‌های بزرگ سرویس اتوبوس با استفاده از الگوی بررسی ادعا (پست وبلاگ) مراجعه کنید.  
یک الگوی جایگزین برای مدیریت پیام های بزرگ، تقسیم و جمع است.  
کتابخانه‌هایی مانند NServiceBus با عملکرد «گذرگاه داده» خود از این الگو پشتیبانی می‌کنند.

## Related resources

- [Asynchronous Request-Reply Pattern](https://learn.microsoft.com/en-us/azure/architecture/patterns/async-request-reply)
- [Competing Consumers pattern](https://learn.microsoft.com/en-us/azure/architecture/patterns/competing-consumers)
- [Sequential Convoy pattern](https://learn.microsoft.com/en-us/azure/architecture/patterns/sequential-convoy)

