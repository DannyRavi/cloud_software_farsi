زمانی که داده‌ها برای عملیات query(query) مورد نیاز format‌ بندی نشده باشند، <mark style="background: #FF5582A6;">نماهای از پیش پرجمع‌شده (prepopulated) </mark>روی داده‌ها را در یک یا چند data store ایجاد کنید. این حالت می تواند به پشتیبانی کارآمد از queryها و استخراج داده ها و بهبود عملکرد برنامه کمک کند.

## Context and problem

هنگام ذخیره داده ها، اولویت برای توسعه دهندگان و مدیران داده ها (data administrators) اغلب بر نحوه ذخیره داده ها متمرکز است، نه نحوه خواندن آنها. فرمت ذخیره سازی انتخاب شده معمولاً با فرمت داده ها، الزامات مدیریتی در سایز داده ها و یکپارچگی و نوع ذخیره شدن آن‌ها در حال استفاده ارتباط نزدیکی دارد. به عنوان مثال، هنگام استفاده از ذخیره‌سازی اسناد NoSQL، داده‌ها اغلب به صورت دنباله‌ای از مجموعه‌ها نشان داده می‌شوند که هر کدام شامل تمام اطلاعات آن موجودیت است.
  
به هر حال، این گزینه می تواند تأثیر منفی بر query (query) داشته باشد. هنگامی که یک query فقط به زیرمجموعه ای از داده ها و در برخی موجودیت‌‌ها نیاز دارد، مانند خلاصه ای از سفارش‌ها برای چندین مشتری بدون دانستن تمام جزئیات سفارش، باید تمام داده ها را برای موجودیت‌‌های مربوطه استخراج کند تا اطلاعات مورد نیاز را به دست آورد.

## Solution

برای پشتیبانی از query به شیوه مناسب یک راه حل متداول این است که؛ دیدگاهی تولید شود که داده ها را در فرمت مناسب با مجموعه نتیجه‌های مورد نیاز، امکان پذیر کند. الگوی Materialized View تولید نماهای از پیش یکپارچه شده داده‌ها را در محیط‌هایی توصیف می‌کند که داده‌های مبدأ در فرمت مناسب برای query نیستند، جایی که ایجاد یک query مناسب دشوار است، یا جایی که عملکرد query به دلیل ماهیت داده‌ها یا  data store ضعیف است.  
  
<mark style="background: #FF5582A6;">این materialized view ها، که فقط حاوی داده های مورد نیاز یک query هستند که به applicationها فرصت این را می دهد تا ب سرعت اطلاعات مورد نیاز خود را به دست آورند. علاوه بر پیوستن به جدول‌ها( joining tables) یا ترکیب موجودیت‌های داده ها، materialized view می‌توانند شامل مقادیر محاسبه‌شده از ستون‌ها یا آیتم های داده‌ای باشد و نتیجه ترکیب یان مقادیر یا اجرای تبدیل‌ها بر روی اقلام داده و مقادیر مشخص‌شده به عنوان بخشی از فرآیند query باشند. یک materialized view   حتی می تواند تنها برای یک query بهینه شود.  </mark>
  
یک نکته کلیدی این است که یک materialized view و  داده‌های موجود در آن کاملاً یکبار مصرف است زیرا می‌توان آن را به طور کامل از منابع data storeها، بازسازی کرد. materialized view هرگز مستقیماً توسط یک برنامه به‌روزرسانی نمی‌شود و بنابراین یک cache یا حافظه موقت خاص است.  
  
هنگامی که  source data برای نما(view) تغییر می کند، view باید برای گنجاندن اطلاعات جدید به روز شود. می‌توانید این کار را به‌طور خودکار یا زمانی که سیستم تغییری در داده‌های اصلی تشخیص دهد، برنامه‌ریزی کنید. در برخی موارد ممکن است لازم باشد که view را به صورت دستی بازسازی کنید. شکل نمونه ای از نحوه استفاده از الگوی materialized view شده را نشان می دهد.

![[Pasted image 20231205111417.png]]

## Issues and considerations

هنگام تصمیم گیری در مورد نحوه اجرای این الگو به نکات زیر توجه کنید:  
  
چگونه و چه زمانی نما به روز می شود. در حالت ایده‌آل، در پاسخ به رویدادی که نشان‌دهنده تغییر در داده‌های منبع (source data) است، تولید می‌شود، به هر حال اگر داده‌های منبع به سرعت تغییر کنند، می‌تواند منجر به سربار بیش از حد شود. روش دیگر، استفاده از یک کار زمان‌بندی‌شده(scheduled)، یک trigger خارجی یا یک اقدام دستی برای بازسازی view را در نظر بگیرید.  
  
در برخی از سیستم‌ها، مانند زمانی که از الگوی  Event Sourcing pattern  استفاده می‌شود تا ذخیره‌ای از رویدادهایی که داده‌ها را تغییر داده‌اند را نگهداری کند، استفاده از materialized view ضروری هستند. از پیش یکپارچه سازی  نماها با بررسی همه رویدادها برای تعیین وضعیت فعلی برنامه ممکن است تنها راه برای به دست آوردن اطلاعات از event store باشد. اگر از Event Sourcing استفاده نمی کنید، باید در نظر بگیرید که آیا یک materialized view مفید است یا خیر. materialized view  به طور خاص برای یک یا تعداد کمی از queryها تنظیم می شوند. اگر queryهای زیادی استفاده شود، materialized view می تواند منجر به نیازهای ظرفیت ذخیره سازی غیرقابل قبول و هزینه ذخیره سازی شود.  
  
هنگام ایجاد نما و در صورت بروز این اتفاق در یک زمانبندی(schedule) یا در حین به‌روزرسانی نما، حتما تأثیر آن را بر روی ثبات داده‌ها(data consistency) در نظر بگیرید. اگر داده‌های منبع در نقطه‌ای که نما تولید می‌شود در حال تغییر باشد، کپی داده‌ها در نما کاملاً با داده‌های اصلی سازگار نخواهد بود.  
  
محل ذخیره نما را در نظر بگیرید. لازم نیست نما در همان store یا پارتیشن داده اصلی قرار گیرد. می تواند زیرمجموعه ای از چند پارتیشن مختلف باشد.  
  
<mark style="background: #FF5582A6;">در صورت مفقود شدن یک نما(view)، می توان آن نما را بازسازی کرد. به همین دلیل، اگر view گذرا باشد و فقط برای بهبود عملکرد query با انعکاس وضعیت فعلی داده‌ها یا بهبود مقیاس‌پذیری استفاده شود، می‌توان آن را در حافظه پنهان یا در مکانی کمتر قابل اطمینان ذخیره کرد.  </mark>
  
<mark style="background: #FF5582A6;">هنگام تعریف materialized view، با افزودن آیتم یا ستون‌های داده به آن بر اساس محاسبات یا تبدیل آیتم‌ داده‌های موجود، مقادیر ارسال شده در query یا ترکیبی از این مقادیر در صورت نیاز حتما ارزش آن را به حداکثر برسانید. </mark> 
  
در جایی که مکانیسم ذخیره سازی پشتیبانی می شود، materialized view را برای افزایش بیشتر عملکرد در نظر بگیرید. اکثر پایگاه های داده رابطه ای از نمایه سازی برای view ها پشتیبانی می کنند، مانند راه حل های کلان داده مبتنی بر Apache Hadoop.

## When to use this pattern

این الگو زمانی مفید است که:  
  
* ایجاد materialized views بر روی داده هایی که اجرای query به صورت  مستقیم روی آنها دشوار است یا در جایی که queryها باید بسیار پیچیده باشند تا داده هایی را که به صورت عادی، نیمه ساختاریافته یا بدون ساختار ذخیره می شوند، استخراج کنند.  
* ایجاد viewهای موقتی که می تواند عملکرد query را به طور چشمگیری بهبود بخشد که می تواند مستقیماً به عنوان source views یا objectهای انتقال داده برای رابط کاربری، گزارش یا نمایش عمل کند.  
* پشتیبانی از حالت‌های گاهی متصل یا گاهی اتصال قطع شده که در آن اتصال به data store همیشه در دسترس نیست. در این مورد می توان نما را به صورت محلی(locally) ذخیره کرد.  
* ساده‌سازی پرس‌و‌جوها و نمایش داده‌ها برای آزمایش به شیوه‌ای که نیازی به دانش فرمت داده‌های منبع ندارد. برای مثال، با پیوستن جداول مختلف در یک یا چند پایگاه داده یا یک یا چند دامنه در  NoSQL، و سپس فرمت‌بندی داده‌ها برای استفاده نهایی آنها.  
* ارائه دسترسی به زیرمجموعه‌های خاصی از داده‌های منبع که به دلایل امنیتی یا حفظ حریم خصوصی، عموماً نباید در دسترس باشند ولی قابل تغییر باشند یا به طور کامل در معرض دید کاربران قرار نگیرند.  
* پل زدن data store های داده مختلف، برای استفاده از قابلیت های فردی آنها. به عنوان مثال،<mark style="background: #FF5582A6;"> استفاده از یک cloud store که برای نوشتن به عنوان ذخیره داده مرجع کارآمد است و یک پایگاه داده رابطه‌ای که  query و خواندن داده‌ به صورت مناسب و خوبی را برای نگهداری materialized viewها ارائه می‌دهد.</mark>  
* هنگام استفاده از میکروسرویس‌ها توصیه می‌شود که ارتباط سرویس‌ها به صورت loosely coupled باشد و این شامل ارتباط با data storage نیز می‌شود. بنابراین، materialized viewها می‌توانند به شما در یک پارچه سازی داده‌های سرویس مورد نظر کمک کنند. اگر materialized view در معماری میکروسرویس‌ها یا سناریوی خاص شما مناسب نیستند، بهتر است مرزهای کاملاً مشخص شده‌ای داشته باشید که با طراحی [domain driven design (DDD)](https://learn.microsoft.com/en-us/azure/architecture/microservices/model/tactical-ddd) تراز باشد و داده‌های آنها را در صورت درخواست جمع‌آوری کنید.  

این الگو در شرایط زیر مفید نیست:  
  
* داده های منبع (source data) ساده و آسان برای انواع query باشد.  
* داده‌های منبع خیلی سریع تغییر می‌کنند یا می‌توان بدون استفاده از نما به آنها دسترسی داشت. در این موارد، باید از سربار پردازش ایجاد نماها اجتناب کنید.  
* سازگاری(Consistency) اولویت بالایی دارد. نماها ممکن است همیشه با داده های اصلی مطابقت کامل نداشته باشند.

## Example

شکل زیر نمونه ای از استفاده از الگوی Materialized View برای تولید خلاصه ای از یه سناریو مربوط به فروش را نشان می دهد. داده‌های موجود در جداول Order، OrderItem و Customer در پارتیشن‌های جداگانه در یک حساب ذخیره‌سازی Azure ترکیب می‌شوند تا یک نمای حاوی کل ارزش فروش برای هر محصول در دسته Electronics، همراه با شمارش تعداد مشتریانی که هر موردی را خرید کرده‌اند، ایجاد کنند.

![[Pasted image 20231205111604.png]]

ایجاد این materialized view نیاز به queryهای پیچیده دارد. با این حال، با نمایش نتیجه query به عنوان یک materialized view، کاربران می توانند به راحتی نتایج را به دست آورند و مستقیماً از آنها استفاده کنند یا آنها را در query دیگری بگنجانند. این نما احتمالاً در یک سیستم گزارش دهی یا داشبورد استفاده می شود و می تواند به صورت برنامه ریزی شده مانند هفتگی به روزرسانی شود.

> 	اگرچه این مثال از Azure table storage استفاده می‌کند اما بسیاری از سیستم‌های مدیریت پایگاه داده رابطه‌ای نیز پشتیبانی native را برای materialized views ارائه می‌کنند.


## Next steps

*  [Data Consistency Primer](https://learn.microsoft.com/en-us/previous-versions/msp-n-p/dn589800(v=pandp.10)) اطلاعات خلاصه در یک materialized view باید به گونه ای نگهداری شود که مقادیر داده های اساسی را منعکس کند. با تغییر مقادیر داده ها، ممکن است به روز رسانی خلاصه داده ها در زمان واقعی عملی نباشد، و در عوض باید یک رویکرد در نهایت سازگار(eventually consistent) را اتخاذ کنید. این مورد مسائل مربوط به حفظ ثبات در داده های توزیع شده را بیان می کند و مزایا و معاوضه های مدل های سازگاری مختلف را شرح می دهد.

## Related resources

الگوهای زیر نیز ممکن است هنگام اجرای این الگو مرتبط باشند:  
  
* الگوی [Command and Query Responsibility Segregation (CQRS) pattern](https://learn.microsoft.com/en-us/azure/architecture/patterns/cqrs). برای به روز رسانی اطلاعات در materialized view با پاسخ دادن به رویدادهایی که هنگام تغییر مقادیر داده های اساسی رخ می دهند، استفاده کنید.  

* الگوی[Event Sourcing pattern](https://learn.microsoft.com/en-us/azure/architecture/patterns/event-sourcing) در ارتباط با الگوی CQRS برای حفظ اطلاعات در یک materialized view استفاده کنید. هنگامی که مقادیر داده‌ای که یک materialized view بر اساس آن است، تغییر می‌کند، سیستم می‌تواند رویدادهایی را که این تغییرات را توصیف می‌کنند، افزایش دهد و آنها را در یک فروشگاه رویداد ذخیره کند.

* الگوی [Index Table pattern](https://learn.microsoft.com/en-us/azure/architecture/patterns/index-table). داده‌ها درmaterialized view معمولاً توسط یک کلید اصلی سازمان‌دهی می‌شوند، اما پرس‌و‌جوها(query) ممکن است نیاز به بازیابی اطلاعات از این نمای با بررسی داده‌ها در فیلدهای دیگر داشته باشند. در نتیجه باید برای ایجاد ایندکس‌های ثانویه روی datasetهایی که برای ذخیره‌سازی داده‌ها از ایندکس‌های ثانویه native پشتیبانی نمی‌کنند، استفاده کنید.