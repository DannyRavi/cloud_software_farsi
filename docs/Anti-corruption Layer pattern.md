
یک لایه نما(façade) یا آداپتور بین زیرسیستم های مختلف که معنایی یکسانی ندارند پیاده سازی کنید. این لایه request های یک زیرسیستم را برای زیرسیستم دیگر تفسیر و ترجمه می کند. از این الگو زمانی استفاده کنید تا اطمینان حاصل کنید که طراحی یک برنامه توسط وابستگی به زیرسیستم های خارجی محدود نمی شود. این الگو برای اولین بار توسط اریک ایوانز در _Domain-Driven Design_ توصیف شد.
## Context and problem


اکثر برنامه ها برای برخی داده ها یا عملکردها به سیستم های دیگر متکی هستند. به عنوان مثال، هنگامی که یک برنامه قدیمی به یک سیستم مدرن منتقل می شود، ممکن است همچنان به منابع قدیمی موجود نیاز داشته باشد. ویژگی های جدید باید قادر به فراخوانی سیستم قدیمی باشند. این به ویژه در مورد migration های تدریجی صادق است، جایی که ویژگی های مختلف یک برنامه بزرگتر به مرور زمان به یک سیستم مدرن منتقل می شود.

اغلب این سیستم های قدیمی از مشکلات کیفی مانند طراحی های داده های (data schemas) پیچیده یا API های منسوخ رنج می برند. ویژگی‌ها و فناوری‌های مورد استفاده در سیستم‌های قدیمی می‌تواند به طور گسترده‌ای با سیستم‌های مدرن‌تر متفاوت باشد. برای تعامل با سیستم قدیمی، برنامه جدید ممکن است نیاز به پشتیبانی از زیرساخت‌های قدیمی، پروتکل‌ها، مدل‌های داده، APIها یا سایر ویژگی‌هایی داشته باشد که در غیر این صورت در یک برنامه مدرن قرار نمی‌دادید.

حفظ دسترسی بین سیستم‌های جدید و قدیمی می‌تواند سیستم جدید را مجبور کند حداقل به برخی از APIهای سیستم قدیمی  پایبند باشد. وقتی این ویژگی‌های قدیمی مشکلات کیفی خاص خود را دارند، پشتیبانی از آن‌ها باعث می‌شود برنامه‌ای را که به صورت مدرن‌تر و بهتر طراحی شده است را احتمالا «خراب)» کند.

مشکلات مشابهی ممکن است در مورد هر external system که  توسط تیم توسعه شما کنترل نمی‌شود، نه فقط سیستم های قدیمی، ایجاد شود.

## راه حل

زیرسیستم های مختلف را با قرار دادن یک لایه anti-corruption بین آنها جدا کنید. این لایه ارتباطات بین دو سیستم را ترجمه و تفسیر می کند و به یک سیستم اجازه می دهد بدون تغییر بماند در حالی که دیگری می تواند از به خطر افتادن طراحی و رویکرد تکنولوژیکی خود جلوگیری کند.

![anti-corruption-layer](../assets/design_implementation/anti-corruption-layer.png)


نمودار بالا یک اپلیکیشن را با دو زیرسیستم را نشان می دهد. زیرسیستم A از طریق یک لایه anti-corruption  زیر سیستم B فراخوانی را می کند. ارتباط بین زیرسیستم A و لایه anti-corruption همیشه از مدل داده و معماری زیرسیستم A استفاده می کند. تماس ها از لایه anti-corruption به زیر سیستم B مطابق با مدل یا روش های داده آن زیر سیستم است. لایه anti-corruption حاوی تمام منطق لازم برای ترجمه بین دو سیستم است. لایه را می توان به عنوان یک جزء در برنامه یا به عنوان یک سرویس مستقل پیاده سازی کرد.

## Issues and considerations

* لایه anti-corruption ممکن است به تماس های برقرار شده بین دو سیستم تاخیر بیافزاید.  
* لایه anti-corruption یک سرویس اضافی را اضافه می کند که باید مدیریت و نگهداری شود.  
* در نظر بگیرید که لایه anti-corruption شما چگونه scale خواهد شد.  
* در نظر بگیرید که آیا به بیش از یک لایه anti-corruption نیاز دارید یا خیر. ممکن است بخواهید با استفاده از فناوری ها یا زبان های مختلف عملکرد را به چندین سرویس تجزیه کنید یا ممکن است دلایل دیگری برای تقسیم لایه anti-corruption وجود داشته باشد.
* در نظر بگیرید که چگونه لایه anti-corruption در رابطه با سایر برنامه ها یا سرویس های شما مدیریت می شود و چگونه در سیستم نظارت یا monitoring شما ادغام خواهد شد،
* اطمینان حاصل کنید که تراکنش ها و داده ها سازگاری دارند و قابل نظارت هستند.
* در نظر بگیرید که آیا لایه anti-corruption نیاز به مدیریت همه ارتباطات بین زیرسیستم های مختلف دارد یا فقط زیر مجموعه ای از ویژگی ها مورد نیاز است.
* اگر لایه anti-corruption بخشی از یک استراتژی migration برنامه است، در نظر بگیرید که آیا دائمی خواهد بود یا پس از انتقال همه عملکردهای قدیمی تعدیل می شود.
* این الگو با زیرسیستم‌های مجزا در بالا نشان داده شده است، اما می‌تواند برای سایر معماری‌های سرویس نیز اعمال شود، مانند زمانی که کدهای قدیمی را با هم در یک معماری یکپارچه ادغام می‌کنیم.

## چه زمانی از این الگپ استفاده کنیم؟

از این الگو زمانی استفاده کنید که:  
  
* در حالتی که برنامه ریزی شده است که یک migration در چند مرحله اتفاق بیفتد، اما یکپارچگی بین سیستم های جدید و قدیمی حتما باید حفظ شود.  
* دو یا چند زیرسیستم semantic متفاوتی دارند، اما همچنان نیاز به ارتباط دارند.  

اگر تفاوت مفهومی قابل توجهی بین سیستم های جدید و قدیمی وجود نداشته باشد، ممکن است این الگو مناسب نباشد.


## منابع مرتبطت

- [Strangler Fig pattern](https://learn.microsoft.com/en-us/azure/architecture/patterns/strangler-fig)
- [Messaging Bridge pattern](https://learn.microsoft.com/en-us/azure/architecture/patterns/messaging-bridge)