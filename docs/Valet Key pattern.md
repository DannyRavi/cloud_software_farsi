# ‏ Valet Key pattern


از یک token خصوص که دسترسی مستقیم و محدودی به یک منبع خاص را برای کلاینت‌ها فراهم می‌کند استفاده کنید تا با این کار بتواند سنگینی انتقال داده را از روی برنامه بردارد. این کار به‌ویژه در برنامه‌هایی که از سیستم‌های ذخیره‌سازی میزبان ابری (cloud-hosted) یا صف‌ها استفاده می‌کنند مفید است و می‌تواند هزینه‌ها را به حداقل برساند و پارامترهای مقیاس‌پذیری و کارایی را به حداکثر برساند.

## **زمینه و مشکل**

برنامه‌های کاربری و مرورگرهای وب اغلب نیاز به خواندن و نوشتن فایل‌ها یا جریان‌های داده (data streams) به‌صورت دوطرفه از فضای ذخیره‌سازی برنامه دارند. به طور معمول، برنامه حرکت داده‌ها را کنترل می‌کند – یا با واکشی آن‌ها از ذخیره‌سازی و پخش جریانی آن به کاربر یا با خواندن جریان آپلود شده از کاربر و ذخیره آن در  ذخیره‌گاه داده (data store). بااین‌حال، این رویکرد منابع ارزشمندی مانند محاسبات، حافظه و پهنای باند را جذب می‌کند.

ذخیره‌گاه داده‌ها یا به‌عبارت‌دیگر data storeها این توانایی را دارند که مستقیماً بارگذاری و بارگیری داده‌ها را مدیریت کنند، بدون اینکه برنامه‌ای برای انتقال این داده‌ها نیازی به پردازش بیشتری انجام دهد. اما این کار معمولاً مستلزم دسترسی کاربر به اعتبارنامه امنیتی store است. این مورد می‌تواند یک تکنیک مفید برای به‌حداقل‌رساندن هزینه‌های انتقال داده و نیاز به scale out کردن برنامه و به حداکثر رساندن کارایی برنامه باشد. اما به این معنی است که برنامه دیگر قادر به مدیریت امنیت داده‌ها نیست. پس از اینکه کاربر برای دسترسی مستقیم به data store متصل شد، برنامه نمی‌تواند به‌عنوان دروازه‌بان (gatekeeper) عمل کند. در نتیجه دیگر کنترل فرایند را در دست ندارد و نمی‌تواند از آپلود یا دانلودهای بعدی از data store جلوگیری کند.

این یک رویکرد واقع‌بینانه در سیستم‌های توزیع شده‌ای نیست که باید به کاربران غیرقابل‌اعتماد خدمت‌رسانی کند. در عوض، برنامه‌ها باید بتوانند به طور ایمن دسترسی به داده‌ها را به‌صورت دانه‌بندی (granular) کنترل کنند، اما همچنان با راه‌اندازی این اتصال، بار روی سرور را کاهش دهند و سپس به کاربر اجازه دهند مستقیماً با ذخیره‌گاه داده (data store) ارتباط برقرار کند تا عملیات خواندن یا نوشتن موردنیاز را انجام دهد.


## راه حل

شما باید مشکل کنترل دسترسی به یک ذخیره‌گاه داده را که در آن ذخیره‌گاه نمی‌تواند احراز هویت و مجوز کاربران را مدیریت کند را به‌درستی حل کنید. یک راه‌حل معمولی محدودکردن دسترسی به اتصال عمومی ذخیره‌گاه داده و ارائه کلید یا token ای به کاربری است که ذخیره‌گاه داده می‌تواند اعتبارسنجی آن را انجام دهد.

این کلید یا token معمولاً به‌عنوان کلید valet شناخته می‌شود که دسترسی محدود به منابع خاص را فراهم می‌کند و فقط عملیات از پیش تعریف شده مانند خواندن و نوشتن در فضای ذخیره‌سازی یا صف‌ها یا آپلود و دانلود در یک مرورگر وب را امکان‌پذیر می‌کند. برنامه‌ها می‌توانند کلیدهای valet را به‌سرعت و به‌آسانی برای دستگاه‌های سرویس‌گیرنده و مرورگرهای وب ایجاد و صادر کنند و به کاربرها این امکان را می‌دهند تا عملیات موردنیاز را بدون نیاز به برنامه‌های دیگر برای مدیریت مستقیم انتقال داده انجام دهند. این امر سربار پردازش و تأثیر بر عملکرد و مقیاس‌پذیری را از برنامه و سرور حذف می‌کند.

کلاینت از این token برای دسترسی به یک منبع خاص در ذخیره‌گاه داده فقط برای یک دوره خاص و با محدودیت‌های خاص در مجوزهای دسترسی استفاده می‌کند، همان‌طور که در شکل نشان‌داده‌شده است. پس از مدت‌زمان مشخص شده، کلید نامعتبر می‌شود و اجازه دسترسی به منبع را نمی‌دهد.


![](../assets/dataManagement/valet-key-pattern.png)

همچنین می‌توان کلیدی را پیکربندی کرد که وابستگی‌های دیگری مانند محدوده مشخصی از داده‌ها را داشته باشد. برای مثال، بسته به قابلیت‌های ذخیره‌سازی داده، کلید می‌تواند یک جدول کامل در یک ذخیره‌گاه داده یا فقط ردیف‌های خاص در یک جدول را مشخص کند. در دستگاه‌های ذخیره‌سازی ابری، کلید می‌تواند یک کانتینر (container) یا فقط یک کانتینر خاص را در یک ظرف مشخص کند.

کلید همچنین می‌تواند توسط برنامه نامعتبر یا غیرفعال شود. اگر کاربر به سرور اطلاع دهد که عملیات انتقال داده کامل شده است که این خود یک رویکرد بسیار مناسب است. سپس سرور می‌تواند برای جلوگیری از دسترسی بیشتر کاربر آن کلید را نامعتبر یا غیرفعال کند.

استفاده از این الگو می‌تواند مدیریت دسترسی به منابع را ساده‌تر کند، زیرا نیازی به ایجاد و احراز هویت کاربر (authenticate)، اعطای مجوزها (grant permissions) و سپس حذف مجدد کاربر وجود ندارد. همچنین محدودکردن مکان، مجوز و دوره تناوب اعتبارسنجی را آسان می‌کند - همه این موارد با تولید یک کلید در زمان اجرا مقدور است. عوامل مهم این است که مدت اعتبار و به‌ویژه محل فیزیکی منابع را تاحدامکان نزدیک کنید تا گیرنده فقط بتواند از آن برای هدف موردنظر استفاده کند.



## مسائل و ملاحظات:

هنگام تصمیم‌گیری در مورد نحوه اجرای این الگو به نکات زیر توجه کنید: 

**وضعیت اعتبار و دوره زمانی اعتبار کلیدها را مدیریت کنید.** در صورت لورفتن یا به‌خطرافتادن اطلاعات مربوط به کلید یا توکن، این کلید دسترسی مهاجم را جهت استفاده غیرمجاز باز می‌کند و آن را برای استفاده مخرب در طول مدت اعتبار آن در دسترس قرار می‌دهد. بسته به نحوه صدور کلید یا توکن، یک کلید معمولاً می‌تواند نامعتبر یا غیرفعال شود. همچنین می‌توان خط‌مشی‌ها و سیاست‌های سمت سرور را تغییر داد یا کلید سروری که با آن امضا شده است را می‌توان باطل کرد. یک دوره اعتبار کوتاه را برای به‌حداقل‌رساندن خطر اجازه‌دادن به عملیات غیرمجاز در برابر ذخیره داده‌ها را مشخص کنید. بااین‌حال، اگر مدت اعتبار خیلی کوتاه باشد، کاربر ممکن است نتواند عملیات را قبل از انقضای کلید کامل کند. در صورت نیاز به دسترسی‌های متعدد به منبع محافظت شده، به کاربران مجاز اجازه دهید تا قبل از پایان دوره اعتبار، کلید را تمدید کنند.

**سطح دسترسی کلید را کنترل کنید.** به طور معمول، کلید باید به کاربر اجازه دهد که فقط اقدامات لازم برای تکمیل عملیات را انجام دهد، مانند دسترسی فقط خواندنی، اگر کاربر نتواند داده‌ها را در ذخیره‌گاه داده، آپلود کند. برای آپلود فایل؛ مشخص‌کردن کلیدی که مجوز فقط نوشتنی (write-only)  دارد و همچنین مکان و مدت اعتبار را فراهم می‌کند بسیار متداول است. در نهایت تعیین دقیق منبع یا مجموعه منابعی که کلید برای آنها اعمال می‌شود بسیار مهم است.

**نحوه کنترل رفتار کاربران را در نظر بگیرید**. اجرای این الگو به معنای ازدست‌دادن کنترل منابعی است که کاربران به آنها دسترسی دارند. سطح کنترلی که می‌تواند اعمال شود، توسط قابلیت‌های خط‌مشی‌ها و مجوزهای موجود برای سرویس یا ذخیره‌گاه داده هدف محدود می‌شود. به‌عنوان‌مثال، معمولاً نمی‌توان کلیدی ایجاد کرد که اندازه داده‌هایی را که باید برای ذخیره‌سازی نوشته شوند یا تعداد دفعاتی که می‌توان از کلید برای دسترسی به یک فایل استفاده کرد را محدود کند. این امر می‌تواند منجر به هزینه‌های غیرمنتظره هنگفتی برای انتقال داده شود، حتی زمانی که کاربر موردنظر از آن استفاده می‌کند و حتی ممکن است ناشی از یک خطا در کد برنامه باشد که در نتیجه باعث بارگذاری یا دانلود مکرر می‌شود. برای محدودکردن تعداد دفعاتی که یک فایل می‌تواند آپلود شود، در صورت امکان، کاربر را مجبور کنید که پس از اتمام یک عملیات به برنامه اطلاع دهد. به‌عنوان‌مثال، برخی از ذخیره‌گاه‌های داده رویدادهایی را افزایش می‌دهند که کد برنامه می‌تواند از آنها برای نظارت بر عملیات و کنترل رفتار کاربر استفاده کند. بااین‌حال، در سناریوی multi-tenant که در آن همه کاربران از یک مستأجر (tenant)  از یک کلید مشابه استفاده می‌کنند، اجرای این روش برای تک، تک کاربران سخت است.

*تمام داده‌های آپلود شده را اعتبارسنجی و به‌صورت اختیاری پاک‌سازی کنید.*  یک کاربر مخرب که به کلید دسترسی پیدا می‌کند می‌تواند داده‌هایی را که برای به خطر انداختن سیستم طراحی شده‌اند بارگذاری کند. از طرف دیگر، کاربران مجاز ممکن است داده‌هایی را آپلود کنند که نامعتبر است و در صورت پردازش، ممکن است منجر به خطا و خرابی سیستم شود. برای محافظت در برابر این حالت، اطمینان حاصل کنید که تمام داده‌های آپلود شده قبل از استفاده اعتبارسنجی شده و از نظر محتوای مخرب بررسی می‌شوند.

‏**بررسی دقیق همه عملیات.** بسیاری از سازوکارهای مبتنی بر کلید می‌توانند عملیات مانند آپلود، دانلود و خرابی را ثبت یا log برداری کنند. این logها معمولاً می‌توانند در یک فرایند بررسی دقیق‌تر گنجانده شوند و همچنین درصورتی‌که کاربر بر اساس اندازه فایل یا حجم داده‌ها هزینه دریافت می‌کند، برای صورت‌حساب پرداختی کاربر استفاده شود. از logها‌ها برای شناسایی خرابی‌های احراز هویت (authentication failures) که ممکن است به دلیل مشکلات ارائه‌دهنده کلید یا حذف تصادفی یک خط‌مشی دسترسی ذخیره‌شده ایجاد شود، استفاده کنید.

‏**کلید را ایمن تحویل دهید.** می‌توان کلید را در یک URL که کاربر در یک صفحه وب فعال می‌کند جاسازی (embedded) کرد یا می‌توان از آن در عملیات تغییر مسیر (redirection) سرور استفاده کرد تا دانلود به طور خودکار انجام شود. همیشه از HTTPS برای تحویل کلید از طریق یک کانال امن استفاده کنید.

‏**محافظت از داده‌های حساس**. به طور معمول جابه‌جایی داده‌های حساسی که از طریق برنامه صورت می‌پذیرد به کمک TLS انجام می‌شوند پس مشابه این کار باید برای کاربرانی که مستقیماً به ذخیره‌گاه داده دسترسی دارند اعمال شود.


موارد دیگری که در اجرای این الگو باید از آنها آگاه بود عبارت‌اند از: 

*‏ در مورد اعلام اتمام عملیات که در حین انجام است اگر کاربر عملیات رو اتمام نکند، پس باید به‌نوعی باید اتمام عملیات را به سرور اطلاع دهید به‌عنوان‌مثال محدودیت ناشی مدت‌زمان انقضای کلید که باید به‌نوعی برای اتمام عملیات پردازشی در نظر گرفته شود، همین‌طور این برنامه قادر به انجام عملیات قابل‌بررسی مانند شمارش تعداد آپلودها یا دانلودها یا جلوگیری از بارگذاری یا دانلودهای متعدد نخواهد بود.

*‏ سیاست‌ها یا خط‌مشی‌های کلید یا tokenهای قابل‌تولید ممکن است محدود باشد. به‌عنوان‌مثال، برخی سازوکارها فقط استفاده از یک دوره انقضای زمان‌بندی‌شده را مجاز می‌دانند. بقیه موارد قادر به تعیین جزئیات کافی از مجوزهای خواندن/نوشتن نیستند.

*‏ اگر زمان شروع برای دوره اعتبار کلید یا token مشخص شده است، مطمئن شوید که کمی زودتر از زمان سرور فعلی باشد تا ساعت‌های سیستم کاربرها که ممکن است کمی از همگام‌سازی خارج شده باشند قابلیت ادامه عملیات را داشته باشند. در حالت پیش‌فرض، اگر زمان تعیین نشده باشد، معمولاً زمان فعلی سرور است.

*‏ آن URL ای که حاوی کلید است، در فایل‌های log سرور ثبت می‌شود. درحالی‌که کلید معمولاً قبل از استفاده از فایل‌های log برای تجزیه‌وتحلیل منقضی می‌شود، در نتیجه اطمینان حاصل کنید که دسترسی به آنها را محدود کرده‌اید. اگر داده‌های log به یک سیستم مانیتورینگ منتقل می‌شوند یا در مکان دیگری ذخیره می‌شوند، برای جلوگیری از نشت کلیدها تا پایان دوره اعتبار آن‌ها، تأخیری را در نظر بگیرید.

*‏ اگر کد کلاینت در یک مرورگر وب اجرا می‌شود، ممکن است مرورگر نیاز به پشتیبانی از اشتراک‌گذاری منابع متقاطع cross-origin resource sharing (CORS) داشته باشد تا کدی را که در مرورگر وب اجرا می‌شود برای دسترسی به داده‌ها در دامنه‌ای متفاوت از دامنه‌ای که صفحه ارائه می‌کند، فعال کند. برخی از مرورگرهای قدیمی و برخی از ذخیره‌گاه‌های داده از CORS پشتیبانی نمی‌کنند و ممکن است کدی که در این مرورگرها اجرا می‌شود، نتواند از کلید نوبت برای دسترسی به داده‌ها در دامنه‌های مختلف، مانند حساب ذخیره‌سازی ابری، استفاده کند.

## **چه زمانی از این الگو استفاده کنیم؟**

این الگو برای شرایط زیر مفید است:

*‏ برای به حداقل رساندن حجم بار روی منابع و به حداکثر رساندن توان عملکردی و مقیاس پذیری. استفاده از valet key نیازی به تخصیص منابع خاصی ندارد در ادامه نیازی به فراخوانی remote server نیست، محدودیتی در تعداد valet keyها وجود ندارد و از یک نقطه شکست ناشی از انجام انتقال داده از طریق کد برنامه جلوگیری می‌کند. ایجاد یک valet key معمولاً شامل یک یک عملیات رمزنگاری ساده برای امضای یک رشته با یک کلید است.

*‏ برای به حداقل رساندن هزینه‌های عملیاتی، فعال کردن دسترسی مستقیم به ذخیر‌گاه‌ها و صف‌ها و منابع تا حدودی مقرون به صرفه است و می‌تواند منجر به رفت و برگشت داده‌‌های کمتری در شبکه شود که ممکن است امکان کاهش تعداد منابع محاسباتی مورد نیاز را فراهم کند.

*‏ زمانی که کلاینت‌ها به طور منظم داده‌ها را آپلود یا دانلود می‌کنند، به خصوص در جا‌هایی که داده‌‌هایی با حجم زیادی وجود دارد یا زمانی که هر عملیات شامل فایل‌‌های بزرگی است.

*‏ زمانی که برنامه دارای منابع محاسباتی محدودی است، چه به دلیل محدودیت‌‌های میزبانی(hosting) یا ملاحظات هزینه. در این سناریو، اگر بارگذاری یا بارگیری همزمان داده‌‌های زیادی وجود داشته باشد، استفاده از این الگو  مفیدتر است زیرا برنامه را از مدیریت انتقال داده خلاص می‌کند.

*‏ هنگامی که داده‌ها در یک ذخیره‌گاه داده به صورت remote یا یک datacenter  ذخیره می‌شوند. اگر لازم  باشد که برنامه به عنوان دروازه‌بان(gatekeeper) عمل کند، ممکن است هزینه‌ای برای پهنای باند اضافی انتقال داده‌ها بین دیتاسنترها یا از طریق شبکه‌‌های عمومی یا خصوصی بین کلاینت و برنامه و سپس بین برنامه و ذخیره‌گاه داده، وجود داشته باشد.



##### این الگو ممکن است در شرایط زیر مفید نباشد:

*‏ اگر برنامه باید قبل از ذخیره داده یا قبل از ارسال داده به کاربر، برخی از دست‌کاری‌ها را روی داده‌ها انجام می‌دهد. به‌عنوان‌مثال؛ اگر برنامه نیاز به اعتبارسنجی داشته باشد یا نیاز به‌نوعی log موفقیت‌آمیز داشته باشد یا تغییری روی داده‌ها اجرا کند. بااین‌حال، برخی از ذخیره‌گاه‌های داده و کاربرها قادر به مذاکره و انجام تغییرات ساده مانند فشرده‌سازی فایل‌ها و داده‌ها و برگرداندن فایل و داده‌های فشرده‌سازی شده به غیرفشرده هستند (به‌عنوان‌مثال، یک مرورگر وب معمولاً می‌تواند فرمت‌های gzip را مدیریت کند).

*‏ اگر طراحی مجدد یک اپلیکیشن از قبل موجود با این الگو را در نظر داشته باشیم و ترکیب‌سازی با این الگو را دشوار باشد. در نتیجه استفاده از این الگو معمولاً نیازمند یک رویکرد معماری متفاوت برای تحویل و دریافت داده است.

*‏ اگر لازم است مسیرهای قابل‌بررسی را حفظ کنید یا تعداد دفعات اجرای عملیات انتقال داده را کنترل کنید؛ ولی سازوکار valet key در حال استفاده از اعلان‌هایی که سرور می‌تواند برای مدیریت این عملیات استفاده کند را پشتیبانی نمی‌کند.

اگر لازم است اندازه داده‌ها را محدود کنید، به‌خصوص در طول عملیات آپلود. تنها راه‌حل این است که برنامه پس از اتمام عملیات، اندازه داده‌ها را بررسی کند یا اندازه آپلودها را پس از یک دوره مشخص یا بر اساس برنامه زمان‌بندی‌شده بررسی کند.


## مثال

<mark style="background: #FF5582A6;"> در نسخه جدید این مثال تغییر کرده است ### </mark>

‏ Azure از signatures دسترسی مشترک در Azure Storage برای کنترل دسترسی دانه‌ای (granular) به داده‌ها در حباب‌ها (blobs)، جداول و صف‌ها و برای صف‌های Service Bus پشتیبانی می‌کند. یک signature token دسترسی مشترک را می‌توان برای ارائه حقوق دسترسی خاص مانند خواندن، نوشتن، به‌روزرسانی و حذف در یک جدول خاص پیکربندی کرد. یک محدوده کلیدی در جدول‌ها؛ یک صف؛ یک blob؛ یا blob container. این اعتبارسنجی می‌تواند یک دوره زمانی مشخص یا بدون محدودیت زمانی باشد.

در واقع signatureهای دسترسی اشتراکی Azure همچنین از سیاست‌های دسترسی ذخیره شده در سرور پشتیبانی می‌کنند که می‌توانند با یک منبع خاص مانند جدول یا blob مرتبط شوند. این ویژگی در مقایسه با signature token دسترسی اشتراکی تولید شده توسط برنامه، کنترل و انعطاف‌پذیری بیشتری را فراهم می‌کند و باید در صورت امکان استفاده شود. تنظیمات تعریف شده در یک خط‌مشی ذخیره شده در سرور را می‌توان تغییر داد و بدون نیاز به صدور توکن جدید در توکن منعکس می‌شود، اما تنظیمات تعریف شده در توکن بدون صدور توکن جدید قابل‌تغییر نیستند. این رویکرد همچنین امکان لغو یک signature token دسترسی مشترک معتبر را قبل از منقضی شدن آن فراهم می‌کند.

در نهایت، ایجاد signatureهای دسترسی مشترک را می‌توان با یک کلید واگذاری کاربر (_user delegation key_) به‌جای استفاده از کلید حساب ذخیره‌سازی (Storage account key) انجام داد. این روش از Microsoft Entra ID استفاده می‌کند و فقط Blob Storage را پشتیبانی می‌کند. هنگامی که Blob Storage تنها سرویسی است که به آن دسترسی دارید، این راه‌حل ارجحیت است.

> برای اطلاعات بیشتر، به اعطای دسترسی محدود به منابع ذخیره‌سازی Azure با استفاده از [shared access signatures (SAS)] (https://learn.microsoft.com/en-us/azure/storage/common/storage-sas-overview) مراجعه کنید.


کد زیر نحوه ایجاد یک signature token دسترسی اشتراکی را نشان می‌دهد که به مدت پنج دقیقه معتبر است. متد `GetSharedAccessReferenceForUpload` یک toekn امضای دسترسی مشترک را بر می‌گرداند که می‌تواند برای آپلود یک فایل در Azure Blob Storage استفاده شود.

```csharp
[ApiController]
public class SasController : ControllerBase
{
  private readonly string blobContainer = "valetkeysample";
  private readonly string blobEndpoint = "https://<StorageAccountName>.blob.core.windows.net";
  ...
  /// <summary>
  /// Return a limited access key that allows the caller to upload a file
  /// to this specific destination for about the next five minutes.
  /// </summary>
  private async Task<StorageEntitySas> GetSharedAccessReferenceForUpload(string blobName)
  {
    var blobServiceClient = new BlobServiceClient(new Uri(blobEndpoint), new DefaultAzureCredential());

    var blobContainerClient = blobServiceClient.GetBlobContainerClient(this.blobContainer);
    var blobClient = blobContainerClient.GetBlobClient(blobName);

    UserDelegationKey key = await blobServiceClient.GetUserDelegationKeyAsync(DateTimeOffset.UtcNow, DateTimeOffset.UtcNow.AddDays(1));

    var blobSasBuilder = new BlobSasBuilder
    {
      BlobContainerName = blobClient.BlobContainerName,
      BlobName = blobClient.Name,
      Resource = "b",
      StartsOn = DateTimeOffset.UtcNow.AddMinutes(-5),
      ExpiresOn = DateTimeOffset.UtcNow.AddMinutes(5)
    };
    blobSasBuilder.SetPermissions(BlobSasPermissions.Write);

    var storageSharedKeySignature = blobSasBuilder.ToSasQueryParameters(key, blobServiceClient.AccountName).ToString();

    return new StorageEntitySas
    {
      BlobUri = blobClient.Uri,
      Signature = storageSharedKeySignature
    };
  }

  public class StorageEntitySas
  {
    public string? Signature { get; internal set; }
    public Uri? BlobUri { get; internal set; }
  }
}
```


نمونه کامل این مسئله در راه‌حل ValetKey موجود برای دانلود از **GitHub** موجود است. پروژه **ValetKey.Web** در این راه‌حل شامل یک برنامه تحت وب است که شامل کلاس `SasController` است که در بالا نشان‌داده‌شده است. یک نمونه client application که از این برنامه وب برای بازیابی signatures key دسترسی مشترک و آپلود یک فایل در فضای ذخیره‌سازی حباب استفاده می‌کند، در پروژه ValetKey.Client موجود است.

## قدم بعدی

راهنمایی زیر ممکن است هنگام اجرای این الگو مرتبط باشد:

-‏ نمونه ‌ای که این الگو را نشان می‌دهد در [GitHub](https://github.com/mspnp/cloud-design-patterns/tree/master/valet-key) موجود است.  

-‏ اعطای دسترسی محدود به منابع ذخیره‌سازی Azure با استفاده از [shared access signatures (SAS)](https://learn.microsoft.com/en-us/azure/storage/common/storage-sas-overview)  

-‏ احراز هویت signatures دسترسی مشترک با [Service Bus](https://learn.microsoft.com/en-us/azure/service-bus-messaging/service-bus-sas)


## منابع مرتبط

-‏ الگوی دروازه‌بان ([Gatekeeper pattern] (https://learn.microsoft.com/en-us/azure/architecture/patterns/gatekeeper)). این الگو را می‌توان همراه با الگوی Valet Key برای محافظت از برنامه‌ها و سرویس‌هایی با استفاده از یک نمونه host اختصاصی که به‌عنوان یک واسطه بین کلاینت و برنامه یا سرویس عمل می‌کند، استفاده کرد. دروازه‌بان درخواست‌ها را اعتبارسنجی و پاک‌سازی می‌کند و درخواست‌ها و داده‌ها را بین کلاینت و برنامه ارسال می‌کند. همچنین می‌تواند یک‌لایه امنیتی اضافی را فراهم کند و سطح حمله سیستم را کاهش دهد.

-‏ الگوی [Static Content Hosting] (https://learn.microsoft.com/en-us/azure/architecture/patterns/static-content-hosting). نحوه استقرار منابع استاتیک در یک سرویس ذخیره‌سازی مبتنی برابر را شرح می‌دهد که می‌تواند این منابع را مستقیماً به کاربرها تحویل دهد تا نیاز به نمونه‌های محاسباتی گران‌قیمت را کاهش دهد. در مواردی که قرار نیست منابع به‌صورت عمومی در دسترس باشند، می‌توان از الگوی Valet Key برای ایمن‌سازی آنها استفاده کرد.

