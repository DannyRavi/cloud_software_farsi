زمانی که داده‌ها برای عملیات query(query) مورد نیاز format‌ بندی نشده باشند، <mark style="background: #FF5582A6;">نماهای از پیش پرجمع‌شده (prepopulated) </mark>روی داده‌ها را در یک یا چند data store ایجاد کنید. این حالت می تواند به پشتیبانی کارآمد از queryها و استخراج داده ها و بهبود عملکرد برنامه کمک کند.

## Context and problem

هنگام ذخیره داده ها، اولویت برای توسعه دهندگان و مدیران داده ها (data administrators) اغلب بر نحوه ذخیره داده ها متمرکز است، نه نحوه خواندن آنها. فرمت ذخیره سازی انتخاب شده معمولاً با فرمت داده ها، الزامات مدیریتی در سایز داده ها و یکپارچگی و نوع ذخیره شدن آن‌ها در حال استفاده ارتباط نزدیکی دارد. به عنوان مثال، هنگام استفاده از ذخیره‌سازی اسناد NoSQL، داده‌ها اغلب به صورت دنباله‌ای از مجموعه‌ها نشان داده می‌شوند که هر کدام شامل تمام اطلاعات آن موجودیت است.
  
به هر حال، این گزینه می تواند تأثیر منفی بر query (query) داشته باشد. هنگامی که یک query فقط به زیرمجموعه ای از داده ها و در برخی موجودیت‌‌ها نیاز دارد، مانند خلاصه ای از سفارش‌ها برای چندین مشتری بدون دانستن تمام جزئیات سفارش، باید تمام داده ها را برای موجودیت‌‌های مربوطه استخراج کند تا اطلاعات مورد نیاز را به دست آورد.

## Solution

برای پشتیبانی از query به شیوه مناسب یک راه حل متداول این است که؛ دیدگاهی تولید شود که داده ها را در فرمت مناسب با مجموعه نتیجه‌های مورد نیاز، امکان پذیر کند. الگوی Materialized View تولید نماهای از پیش یکپارچه شده داده‌ها را در محیط‌هایی توصیف می‌کند که داده‌های مبدأ در فرمت مناسب برای query نیستند، جایی که ایجاد یک query مناسب دشوار است، یا جایی که عملکرد query به دلیل ماهیت داده‌ها یا  data store ضعیف است.  
  
<mark style="background: #FF5582A6;">این materialized view ها، که فقط حاوی داده های مورد نیاز یک query هستند که به applicationها فرصت این را می دهد تا ب سرعت اطلاعات مورد نیاز خود را به دست آورند. علاوه بر پیوستن به جدول‌ها( joining tables) یا ترکیب موجودیت‌های داده ها، materialized view می‌توانند شامل مقادیر محاسبه‌شده از ستون‌ها یا آیتم های داده‌ای باشد و نتیجه ترکیب یان مقادیر یا اجرای تبدیل‌ها بر روی اقلام داده و مقادیر مشخص‌شده به عنوان بخشی از فرآیند query باشند. یک materialized view   حتی می تواند تنها برای یک query بهینه شود.  </mark>
  
یک نکته کلیدی این است که یک materialized view و  داده‌های موجود در آن کاملاً یکبار مصرف است زیرا می‌توان آن را به طور کامل از منابع data storeها، بازسازی کرد. materialized view هرگز مستقیماً توسط یک برنامه به‌روزرسانی نمی‌شود و بنابراین یک cache یا حافظه موقت خاص است.  
  
هنگامی که  source data برای نما(view) تغییر می کند، view باید برای گنجاندن اطلاعات جدید به روز شود. می‌توانید این کار را به‌طور خودکار یا زمانی که سیستم تغییری در داده‌های اصلی تشخیص دهد، برنامه‌ریزی کنید. در برخی موارد ممکن است لازم باشد که view را به صورت دستی بازسازی کنید. شکل نمونه ای از نحوه استفاده از الگوی materialized view شده را نشان می دهد.

![[Pasted image 20231205111417.png]]

## Issues and considerations

هنگام تصمیم گیری در مورد نحوه اجرای این الگو به نکات زیر توجه کنید:  
  
چگونه و چه زمانی نما به روز می شود. در حالت ایده‌آل، در پاسخ به رویدادی که نشان‌دهنده تغییر در داده‌های منبع (source data) است، تولید می‌شود، به هر حال اگر داده‌های منبع به سرعت تغییر کنند، می‌تواند منجر به سربار بیش از حد شود. روش دیگر، استفاده از یک کار زمان‌بندی‌شده(scheduled)، یک trigger خارجی یا یک اقدام دستی برای بازسازی view را در نظر بگیرید.  
  
در برخی از سیستم‌ها، مانند زمانی که از الگوی  Event Sourcing pattern  استفاده می‌شود تا ذخیره‌ای از رویدادهایی که داده‌ها را تغییر داده‌اند را نگهداری کند، استفاده از materialized view ضروری هستند. از پیش یکپارچه سازی  نماها با بررسی همه رویدادها برای تعیین وضعیت فعلی برنامه ممکن است تنها راه برای به دست آوردن اطلاعات از event store باشد. اگر از Event Sourcing استفاده نمی کنید، باید در نظر بگیرید که آیا یک materialized view مفید است یا خیر. materialized view  به طور خاص برای یک یا تعداد کمی از queryها تنظیم می شوند. اگر queryهای زیادی استفاده شود، materialized view می تواند منجر به نیازهای ظرفیت ذخیره سازی غیرقابل قبول و هزینه ذخیره سازی شود.  
  
هنگام ایجاد نما و در صورت بروز این اتفاق در یک زمانبندی(schedule) یا در حین به‌روزرسانی نما، حتما تأثیر آن را بر روی ثبات داده‌ها(data consistency) در نظر بگیرید. اگر داده‌های منبع در نقطه‌ای که نما تولید می‌شود در حال تغییر باشد، کپی داده‌ها در نما کاملاً با داده‌های اصلی سازگار نخواهد بود.  
  
محل ذخیره نما را در نظر بگیرید. لازم نیست نما در همان store یا پارتیشن داده اصلی قرار گیرد. می تواند زیرمجموعه ای از چند پارتیشن مختلف باشد.  
  
<mark style="background: #FF5582A6;">در صورت مفقود شدن یک نما(view)، می توان آن نما را بازسازی کرد. به همین دلیل، اگر view گذرا باشد و فقط برای بهبود عملکرد query با انعکاس وضعیت فعلی داده‌ها یا بهبود مقیاس‌پذیری استفاده شود، می‌توان آن را در حافظه پنهان یا در مکانی کمتر قابل اطمینان ذخیره کرد.  </mark>
  
<mark style="background: #FF5582A6;">هنگام تعریف materialized view، با افزودن آیتم یا ستون‌های داده به آن بر اساس محاسبات یا تبدیل آیتم‌ داده‌های موجود، مقادیر ارسال شده در query یا ترکیبی از این مقادیر در صورت نیاز حتما ارزش آن را به حداکثر برسانید. </mark> 
  
در جایی که مکانیسم ذخیره سازی پشتیبانی می شود، materialized view را برای افزایش بیشتر عملکرد در نظر بگیرید. اکثر پایگاه های داده رابطه ای از نمایه سازی برای view ها پشتیبانی می کنند، مانند راه حل های کلان داده مبتنی بر Apache Hadoop.
تا اینجاااااااااااااااااااااااااااااااااااااااااااااااااااااااااااااااا
## When to use this pattern

این الگو زمانی مفید است که:  
  
* ایجاد نماهای تحقق یافته بر روی داده هایی که queryی مستقیم آنها دشوار است، یا در جایی که queryها باید بسیار پیچیده باشند تا داده هایی را که به صورت عادی، نیمه ساختاریافته یا بدون ساختار ذخیره می شوند استخراج کنند.  
* ایجاد نماهای موقتی که می تواند عملکرد query را به طور چشمگیری بهبود بخشد، یا می تواند مستقیماً به عنوان نماهای منبع یا اشیاء انتقال داده برای رابط کاربری، گزارش یا نمایش عمل کند.  
* پشتیبانی از سناریوهای گهگاهی متصل یا قطع شده که در آن اتصال به فروشگاه داده همیشه در دسترس نیست. در این مورد می توان نما را به صورت محلی ذخیره کرد.  
* ساده‌سازی پرس‌و‌جوها و نمایش داده‌ها برای آزمایش به شیوه‌ای که نیازی به دانش فرمت داده‌های منبع ندارد. برای مثال، با پیوستن جداول مختلف در یک یا چند پایگاه داده، یا یک یا چند دامنه در فروشگاه‌های NoSQL، و سپس فرمت‌بندی داده‌ها برای استفاده نهایی آن.  
* ارائه دسترسی به زیرمجموعه‌های خاصی از داده‌های منبع که به دلایل امنیتی یا حفظ حریم خصوصی، عموماً نباید در دسترس باشند، قابل تغییر باشند یا به طور کامل در معرض دید کاربران قرار نگیرند.  
* پل زدن بین فروشگاه های داده مختلف، برای استفاده از قابلیت های فردی آنها. به عنوان مثال، استفاده از یک فروشگاه ابری که برای نوشتن به عنوان ذخیره داده مرجع کارآمد است، و یک پایگاه داده رابطه‌ای که عملکرد query و خواندن خوبی را برای نگهداری نماهای تحقق‌یافته ارائه می‌دهد.  
* هنگام استفاده از میکروسرویس‌ها، به شما توصیه می‌شود که آن‌ها را از جمله ذخیره‌سازی داده‌ها، به‌صورت آزاد به هم متصل کنید. بنابراین، نماهای مادی می‌توانند به شما در ادغام داده‌های خدماتتان کمک کنند. اگر نماهای تحقق‌یافته در معماری میکروسرویس‌ها یا سناریوی خاص شما مناسب نیستند، لطفاً مرزهای کاملاً تعریف شده‌ای داشته باشید که با طراحی مبتنی بر دامنه (DDD) تراز باشد و داده‌های آنها را در صورت درخواست جمع‌آوری کنید.  

این الگو در شرایط زیر مفید نیست:  
  
* داده های منبع ساده و آسان برای query هستند.  
* داده‌های منبع خیلی سریع تغییر می‌کنند یا می‌توان بدون استفاده از نما به آنها دسترسی داشت. در این موارد، باید از سربار پردازش ایجاد نماها اجتناب کنید.  
* سازگاری اولویت بالایی دارد. نماها ممکن است همیشه با داده های اصلی مطابقت کامل نداشته باشند.

## Example

شکل زیر نمونه ای از استفاده از الگوی Materialized View برای تولید خلاصه ای از فروش را نشان می دهد. داده‌های موجود در جداول Order، OrderItem و Customer در پارتیشن‌های جداگانه در یک حساب ذخیره‌سازی Azure ترکیب می‌شوند تا یک نمای حاوی کل ارزش فروش برای هر محصول در دسته Electronics، همراه با شمارش تعداد مشتریانی که خرید کرده‌اند، ایجاد کنند. هر مورد.

![[Pasted image 20231205111604.png]]

ایجاد این نمای مادی شده نیاز به queryهای پیچیده دارد. با این حال، با نمایش نتیجه query به عنوان یک نمای مادی شده، کاربران می توانند به راحتی نتایج را به دست آورند و مستقیماً از آنها استفاده کنند یا آنها را در query دیگری بگنجانند. این نما احتمالاً در یک سیستم گزارش دهی یا داشبورد استفاده می شود و می تواند به صورت برنامه ریزی شده مانند هفتگی به روز شود.

> اگرچه این مثال از ذخیره‌سازی جدول Azure استفاده می‌کند، بسیاری از سیستم‌های مدیریت پایگاه داده رابطه‌ای نیز پشتیبانی بومی را برای نماهای مادی‌شده ارائه می‌کنند.


## Next steps

* پرایمر سازگاری داده اطلاعات خلاصه در یک نمای مادی شده باید به گونه ای نگهداری شود که مقادیر داده های اساسی را منعکس کند. با تغییر مقادیر داده ها، ممکن است به روز رسانی خلاصه داده ها در زمان واقعی عملی نباشد، و در عوض باید یک رویکرد در نهایت سازگار را اتخاذ کنید. مسائل مربوط به حفظ ثبات در داده های توزیع شده را خلاصه می کند و مزایا و معاوضه های مدل های سازگاری مختلف را شرح می دهد.

## Related resources

الگوهای زیر نیز ممکن است هنگام اجرای این الگو مرتبط باشند:  
  
* الگوی تفکیک مسئولیت فرمان و query (CQRS). برای به روز رسانی اطلاعات در نمای مادی شده با پاسخ دادن به رویدادهایی که هنگام تغییر مقادیر داده های اساسی رخ می دهند، استفاده کنید.  

* الگوی منبع یابی رویداد در ارتباط با الگوی CQRS برای حفظ اطلاعات در یک نمای مادی استفاده کنید. هنگامی که مقادیر داده‌ای که یک نمای واقعی بر اساس آن است، تغییر می‌کند، سیستم می‌تواند رویدادهایی را که این تغییرات را توصیف می‌کنند، افزایش دهد و آنها را در یک فروشگاه رویداد ذخیره کند.

* الگوی جدول شاخص. داده‌ها در نمای مادی‌شده معمولاً توسط یک کلید اصلی سازمان‌دهی می‌شوند، اما پرس‌و‌جوها ممکن است نیاز به بازیابی اطلاعات از این نمای با بررسی داده‌ها در زمینه‌های دیگر داشته باشند. برای ایجاد نمایه‌های ثانویه روی مجموعه‌های داده برای ذخیره‌سازی داده‌هایی که از فهرست‌های ثانویه بومی پشتیبانی نمی‌کنند استفاده کنید.