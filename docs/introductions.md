
----------------------------------


---------------------------
what is cloud

https://learn.microsoft.com/en-us/azure/architecture/guide/

https://azure.microsoft.com/en-us/resources/cloud-computing-dictionary/what-is-cloud-computing

https://learn.microsoft.com/en-us/azure/architecture/guide/architecture-styles/microservices

https://learn.microsoft.com/en-us/azure/architecture/guide/architecture-styles/web-queue-worker





-----------------------------
on-premises:

نرم‌افزار داخلی (به اختصار on-prem، یا به عنوان on-premise نامیده می‌شود)[1]  روی رایانه‌ها در محل شخصی یا سازمانی که از نرم‌افزار استفاده می‌کند، نصب و اجرا می‌شود، نه در یک مرکز ریموت مانند یک سرور. [server farm](https://en.wikipedia.org/wiki/Server_farm "Server farm") یا محیط ابری نرم‌افزار داخلی گاهی اوقات به عنوان نرم‌افزار «[shrinkwrap](https://en.wikipedia.org/wiki/Shrink_wrap_contract "Shrink wrap contract")» نامیده می‌شود و نرم‌افزار خارج از محل معمولاً «نرم‌افزار به‌عنوان سرویس» یا [software as a service](https://en.wikipedia.org/wiki/Software_as_a_service "Software as a service") («SaaS») یا «محاسبات ابری» ([cloud computing](https://en.wikipedia.org/wiki/Cloud_computing)) نامیده می‌شود.  

نرم افزار متشکل از پایگاه داده و ماژول هایی است که به طور خاص به نیازهای منحصر به فردی یا سازمان های بزرگ در مورد اتوماسیون سیستم تجاری در سطح شرکت و کارایی آن‌ها پاسخ می دهند.[2]

## مقایسه بین  on-premises و ابری (SaaS)
#### محل
نرم‌افزار داخلی در سیستم داخلی سازمان به همراه سخت‌افزار و سایر زیرساخت‌های لازم برای کارایی نرم‌افزار ایجاد می‌شود.[3][4][5]  
  
نرم افزار مبتنی بر ابر معمولاً از طریق اینترنت ارائه می شود و کاربران می توانند بدون توجه به زمان و مکان آنها به صورت آنلاین به آن دسترسی داشته باشند.[3][4][5] بر خلاف نرم‌افزارهای داخلی، کاربران نرم‌افزار مبتنی بر ابر برای دسترسی به سرویس‌های آن فقط باید یک برنامه  یا یک مرورگر وب نصب کنند.

#### هزینه های مورد نیاز برای دسترسی به سرویس‌ها

برای نرم‌افزار داخلی، تا زمانی که نرم‌افزار و سرویس‌های آن به‌طور کامل برای استفاده در دسترس قرار گیرند، انتظار می‌رود چندین هزینه متحمل شوند. اول از همه، ساخت نرم‌افزار درون سازمانی نیازمند هزینه‌های اولیه بالایی است، از جمله هزینه‌های انجام شده برای خرید سخت‌افزار و سایر زیرساخت‌ها و همچنین هزینه‌های لازم برای نصب و بررسی نرم‌افزار است.[3][4][5] علاوه بر این، واحد حقوقی حق خرید مجوز ویژه نرم افزار را دارد که مستلزم هزینه و زمان برای آماده سازی و مراحل مورد نیاز است. همینطور زیر ساخت هایی  برای حفظ کارایی نرم‌افزار، نگهداری و فعالیت‌های پایدار مورد نیاز است و واحد مورد رسیدگی این کار نیز متحمل هزینه‌های برای این موارد حساب می‌شود.  
  
از سوی دیگر، به طور کلی، هزینه های اولیه مورد نیاز برای استفاده از سرویس‌های نرم افزاری برای نرم افزارهای مبتنی بر ابر نسبتاً کم در نظر گرفته می شود و بنابراین برای شرکت های کوچک بدون سرمایه زیاد مناسب است.[3][4][5] علاوه بر این، کاربران نرم‌افزار مبتنی بر ابر مشمول هزینه‌های مجوز و همچنین هزینه‌های نگهداری و بهره‌برداری نمی‌شوند، زیرا این هزینه‌ها در دست فروشندگان نرم‌افزار است. علاوه بر این، انتظار می‌رود هزینه‌های متحمل شده برای زیرساخت‌ها در مقایسه با نرم‌افزارهای داخلی کمتر باشد، زیرا کاربران فقط به دستگاه‌های الکترونیکی خود نیاز دارند تا بتوانند به خدمات دسترسی داشته باشند.  
  
اگرچه هزینه‌های اولیه برای دسترسی به خدمات معمولاً برای نرم‌افزار مبتنی بر ابر کم است، کل هزینه‌های مورد نیاز برای استفاده از نرم‌افزار در یک دوره زمانی خاص مطمئن نیستند زیرا نرم‌افزار مبتنی بر ابر به پرداخت معمولی (یعنی هزینه اشتراک ماهانه) برای استفاده از نرم‌افزار نیاز دارد. سرویس‌‌ها در حالی که نرم افزار درون محل این کار را نمی کند.




-------------------------------
scaling


https://www.binadox.com/blog/scalability-in-cloud-computing/
https://fa.wikipedia.org/wiki/مقیاس%E2%80%8Cپذیری
https://azure.microsoft.com/en-us/resources/cloud-computing-dictionary/scaling-out-vs-scaling-up

https://learn.microsoft.com/en-us/azure/architecture/best-practices/auto-scaling
-------------------------------------------
data store
ذخیره‌گاه داده
ذخیره‌ساز داده




-----------------------------------------------
 Workload



----------------------------------------------

throttling



--------------------------------------------------
shard






---------------------------------------------------

replica







-------------------------------------------------

shard








---------------------
پرس و جوهایی

---------------------------------------
دسترس بودن


------------------------------------------

  endpoint

--------------
tenant


[**Tenants** در مفهوم نرم‌افزاری به گروه‌هایی از کاربران یا نرم‌افزارها اشاره دارد که همگی به یک منبع سخت‌افزاری دسترسی مشترک دارند](https://sokanacademy.com/blog/multi-tenancy-%D9%85%D8%B9%D8%B1%D9%81%DB%8C-%D9%85%D8%B2%D8%A7%DB%8C%D8%A7-%D9%88-%D9%85%D8%B9%D8%A7%DB%8C%D8%A8)[1](https://sokanacademy.com/blog/multi-tenancy-%D9%85%D8%B9%D8%B1%D9%81%DB%8C-%D9%85%D8%B2%D8%A7%DB%8C%D8%A7-%D9%88-%D9%85%D8%B9%D8%A7%DB%8C%D8%A8). به عبارت دیگر، چندین **مستاجر (tenant)** یا گروه کاربری می‌توانند از یک سرور فیزیکی استفاده کنند تا به خدمات مشابه دسترسی داشته باشند. هر مستاجر از یک حافظه RAM و پردازنده CPU در سرور استفاده می‌کند.

برای مقایسه، در مفهوم **single-tenancy**، سرور تنها یک نمونه از برنامه را اجرا می‌کند. اما در معماری **multi-tenancy**، چندین نمونه از یک برنامه روی یک سرور اجرا می‌شوند، به نحوی که هر مستاجر به صورت مجزا از منابع سخت‌افزاری استفاده می‌کند.

مفهوم مستاجر در نرم‌افزارها مشابه مفهوم دیگری است که در مهندسی عمران نیز به کار می‌رود. [به عنوان مثال، در یک ساختمان چند واحدی، هر واحد می‌تواند یک مستاجر محسوب شود که از منابع مشترک ساختمان استفاده می‌کند](https://sokanacademy.com/blog/multi-tenancy-%D9%85%D8%B9%D8%B1%D9%81%DB%8C-%D9%85%D8%B2%D8%A7%DB%8C%D8%A7-%D9%88-%D9%85%D8%B9%D8%A7%DB%8C%D8%A8)[1](https://sokanacademy.com/blog/multi-tenancy-%D9%85%D8%B9%D8%B1%D9%81%DB%8C-%D9%85%D8%B2%D8%A7%DB%8C%D8%A7-%D9%88-%D9%85%D8%B9%D8%A7%DB%8C%D8%A8).


---------------------------------------------

پایداری نهایی (eventual consistency) 

@@@ سازگاری شرطی به پایداری نهایی تبدیل شود


برای اطلاعات در مورد سازگاری شرطی (eventual consistency) به [Data Consistency Primer](https://learn.microsoft.com/en-us/previous-versions/msp-n-p/dn589800(v=pandp.10)) یا فصل مقدمه مراجعه کنید.



[پایداری نهایی یک مدل سازگاری است که در محاسبات توزیع شده برای دستیابی به در دسترس بودن بالا استفاده می‌شود و به طور غیررسمی تضمین می‌کند که اگر به یک مورد داده‌ای تغییری اعمال نشود، در نهایت همه دسترسی‌ها به آن مورد، آخرین مقدار به‌روز شده را برمی‌گردانند](https://en.wikipedia.org/wiki/Eventual_consistency)[1](https://en.wikipedia.org/wiki/Eventual_consistency)[2](https://www.scylladb.com/glossary/eventual-consistency/)

به عبارت ساده‌تر، پایداری نهایی به این معنی است که یک درخواست خواندن باید نتیجه آخرین نوشتن موفق را برگرداند. [این به نظر ساده می‌رسد، اما چنین تضمینی در یک توپولوژی پایگاه داده توزیع شده جهانی که شامل چندین خوشه هر کدام شامل تعداد زیادی گره است، بسیار دشوار است](https://www.scylladb.com/glossary/eventual-consistency/)[2](https://www.scylladb.com/glossary/eventual-consistency/)

پایگاه داده‌های رابطه‌ای که از پایداری قوی پشتیبانی می‌کنند، معمولاً تضمین‌های ACID را ارائه می‌دهند. ACID یک مخفف است که برای درک عناصر اساسی یک پایگاه داده با پایداری قوی طراحی شده است. اجزای ACID به شرح زیر است:

- اتمیته: اگر معامله در هر نقطه شکست بخورد، عملیات کلی برگشت می‌خورد
- سازگاری: پایگاه داده با هر معامله، ساختاری سالم را حفظ می‌کند
- جدایی: هر معامله به طور مستقل از معاملات دیگر اجرا می‌شود
- دوام: هر معامله موفق به طور دائمی در پایگاه داده ذخیره می‌شود

[پایگاه داده‌هایی که از پایداری نهایی پشتیبانی می‌کنند، معمولاً به عنوان دارای معنای BASE شناخته می‌شوند (در دسترس بودن اساسی، حالت نرم، پایداری نهایی)](https://en.wikipedia.org/wiki/Eventual_consistency)[1](https://en.wikipedia.org/wiki/Eventual_consistency)[2](https://www.scylladb.com/glossary/eventual-consistency/)[3](https://www.voltactivedata.com/blog/2022/09/what-is-eventual-consistency/) [در شیمی، باز برعکس اسید است که در یادآوری مخفف کمک می‌کند](https://en.wikipedia.org/wiki/Eventual_consistency)[4](https://serverlessland.com/event-driven-architecture/visuals/eventual-consistency)

به گفته همان منبع، اینها تعاریف تقریبی هر عبارت در BASE هستند:

- در دسترس بودن اساسی: عملیات خواندن و نوشتن تا حد امکان (با استفاده از تمام گره‌های یک خوشه پایگاه داده) در دسترس هستند، اما ممکن است سازگار نباشند (نوشتن ممکن است پس از رفع تضادها ماندگار نشود و خواندن ممکن است آخرین نوشتن را دریافت نکند)
- حالت نرم: بدون تضمین‌های سازگاری، پس از مقداری زمان، فقط احتمالی از دانستن وضعیت داریم، زیرا ممکن است هنوز همگرا نشده باشد
- پایداری نهایی: اگر ما چند نوشتن را انجام دهیم و سپس سیستم به مدت کافی عمل کند، می‌توانیم وضعیت داده‌ها را بدانیم؛ هر خواندن بعدی از آن مورد داده‌ای، همان مقدار را برمی‌گرداند

[](https://en.wikipedia.org/wiki/Eventual_consistency)[1](https://en.wikipedia.org/wiki/Eventual_consistency): [](https://en.wikipedia.org/wiki/Eventual_consistency)[2](https://www.scylladb.com/glossary/eventual-consistency/): [](https://en.wikipedia.org/wiki/Eventual_consistency)[3](https://www.voltactivedata.com/blog/2022/09/what-is-eventual-consistency/): [](https://en.wikipedia.org/wiki/Eventual_consistency)[4](https://serverlessland.com/event-driven-architecture/visuals/eventual-consistency):




----------------------------------------------

deployment




----------------------------------------------
container


--------------------------------------------
 storage account

https://learn.microsoft.com/en-us/rest/api/storageservices/lease-blob?tabs=microsoft-entra-id
----------------------------------------------

timestamp

--------------------------------------------------
queue

------------------------------------------------------
cache

https://learn.microsoft.com/en-us/azure/architecture/best-practices/caching
https://en.wikipedia.org/wiki/Cache_(computing)

----------------------------------------------------

cdn

https://learn.microsoft.com/en-us/azure/architecture/best-practices/cdn


-------------------------------------------------------
performance
https://learn.microsoft.com/en-us/azure/architecture/performance/

-------------------------------------------------------

expose

----------------------------------------------------------

endpoint

[**Endpoint** در نرم‌افزار به دستگاه‌های فیزیکی یا مجازی اشاره دارد که به یک شبکه متصل شده و اطلاعات را با آن تبادل می‌کنند](https://www.microsoft.com/en-us/security/business/security-101/what-is-an-endpoint)[1](https://www.microsoft.com/en-us/security/business/security-101/what-is-an-endpoint)[2](https://www.paloaltonetworks.com/cyberpedia/what-is-an-endpoint)[3](https://www.cloudflare.com/learning/security/glossary/what-is-endpoint/). این دستگاه‌ها می‌توانند شامل موارد زیر باشند:

- **دستگاه‌های موبایل**: مانند تلفن‌های همراه.
- **کامپیوترهای رومیزی**: مانند کامپیوترهای شخصی.
- **ماشین‌های مجازی**: که در محیط‌های مجازی‌سازی اجرا می‌شوند.
- **دستگاه‌های تعبیه‌شده**: مانند دستگاه‌های کنترلی، دستگاه‌های صنعتی و سایر دستگاه‌های الکترونیکی.
- **سرورها**: که نقش‌های مختلفی در شبکه دارند.
- **دستگاه‌های اینترنت اشیاء (IoT)**: مانند دوربین‌ها، لامپ‌ها، یخچال‌ها، سیستم‌های امنیتی، اسپیکرهای هوشمند و ترموستات‌ها.

**امنیت انتها** یا **حفاظت انتها** به محافظت از این دستگاه‌ها در برابر حملات و تهدیدات مخرب اشاره دارد. این دستگاه‌ها به عنوان دروازه‌هایی برای دسترسی به داده‌های سازمانی مورد هدف قرار می‌گیرند و به طبیعت خود آسیب‌پذیر به حملات هستند. [امنیت انتها اهمیت بیشتری پیدا کرده است، زیرا نیروی کار به صورت پراکنده‌تری کار می‌کند و کاربران از سراسر جهان از دستگاه‌های مختلف استفاده می‌کنند](https://www.microsoft.com/en-us/security/business/security-101/what-is-an-endpoint)[1](https://www.microsoft.com/en-us/security/business/security-101/what-is-an-endpoint).

[در کل، امنیت انتها با استفاده از فرآیندها، خدمات و راه‌حل‌های مختلف، دستگاه‌ها را در برابر تهدیدات سایبری محافظت می‌کند](https://www.microsoft.com/en-us/security/business/security-101/what-is-an-endpoint)[1](https://www.microsoft.com/en-us/security/business/security-101/what-is-an-endpoint).
------------------------------------------------
materialized view
یک نمای مادی ([materialized view](https://learn.microsoft.com/en-us/azure/architecture/patterns/materialized-view)) یک جدول شامل داده‌ها است که نتیجه یک پرس و جو را در خود ذخیره می‌کند. این روش باعث می‌شود که دسترسی به داده‌ها سریع‌تر و کارآمدتر شود، اما به قیمت اشغال فضای بیشتر و احتمال عدم به‌روز بودن برخی از داده‌ها.

---------------------
 event store
 
 
یک ذخیره‌گاه رویداد یا event store یک نوع پایگاه داده است که برای ذخیره رویدادها بهینه‌سازی شده است. [به طور مفهومی، یک ذخیره‌گاه رویداد فقط رویدادهایی را ثبت می‌کند که بر یک موجودیت، پرونده یا سیاست تأثیر می‌گذارند و حالت موجودیت در هر نقطه از تاریخش را می‌توان با بازپخش رویدادهای مشارکت‌کننده در ترتیب متوالی بازسازی کرد](https://www.eventstore.com/)[1](https://www.eventstore.com/)

یک ذخیره‌گاه رویداد برای کاربردهایی که از معماری رویدادگرا، معماری مبتنی بر رویداد و میکروسرویس‌ها استفاده می‌کنند، مناسب است. [این نوع پایگاه داده امکاناتی مانند نوشتن تضمین شده، مدل همزمانی، رابط‌های جریان و جریان دانه‌دار را ارائه می‌دهد که آن را بهترین گزینه برای سیستم‌های مبتنی بر رویداد می‌کند](https://www.eventstore.com/)[2](https://www.eventstore.com/eventstoredb)

برخی از مزایای استفاده از یک فروشگاه رویداد عبارتند از:

- ذخیره داده‌ها به صورت یک سری رویدادهای غیرقابل تغییر در طول زمان، که یکی از قوی‌ترین گزینه‌های ثبت وقایع را فراهم می‌کند
- امکان بازپخش رویدادها برای تحلیل، پیش‌بینی و بازسازی حالت‌های گذشته
- امکان ایجاد رویدادهای جدید بر اساس ترکیب‌های جالب رویدادهای موجود با استفاده از پروژه‌ها
- امکان اتصال به مشتریان مختلف با استفاده از رابط‌های بر پایه gRPC برای اکثر زبان‌ها و پلتفرم‌ها
- امکان اجرای فروشگاه رویداد به صورت یک خوشه از گره‌هایی که داده‌های یکسان را دارند و در دسترس بودن بالا را ارائه می‌دهند
- امکان انتخاب بین گزینه‌های مختلف میزبانی برای فروشگاه رویداد، اعم از سرورهای محلی یا ابری
 -----------------------------------
 migration

-------------
event stream
یک جریان رویداد یک دنباله مرتب از رویدادها است که اعمال مهمی را در یک حوزه نرم‌افزاری نشان می‌دهند. این می‌تواند چیزی ساده مانند کلیک بر روی یک پیوند باشد، یا ممکن است چیزی پیچیده‌تر مانند انتقال وجوه بین دو بانک باشد. [پردازش جریان رویداد (ESP) یک جریان پیوسته از رویدادها را دریافت می‌کند و به محض ایجاد تغییر آن‌ها را پردازش می‌کند](https://www.npmjs.com/package/event-stream)[1](https://www.npmjs.com/package/event-stream)

به عنوان مثال، یک برنامه تجارت الکترونیکی می‌تواند از یک جریان رویداد برای ثبت تمام فعالیت‌های کاربران استفاده کند، مانند مشاهده محصولات، افزودن به سبد خرید، پرداخت و ارسال. [این جریان رویداد می‌تواند برای اهداف مختلفی مانند تحلیل رفتار مشتری، پیشنهاد محصولات مرتبط، ارزیابی عملکرد فروش و ایجاد گزارش‌های مالی مورد استفاده قرار گیرد](https://www.ibm.com/products/event-streams)[2](https://www.ibm.com/products/event-streams)

جریان رویدادها می‌تواند با استفاده از پلتفرم‌های جریان رویداد مانند Apache Kafka مدیریت شود. Apache Kafka یک سیستم پیام‌رسانی توزیع شده است که امکان انتقال، ذخیره و پردازش جریان‌های رویداد را فراهم می‌کند. [Apache Kafka از مفاهیمی مانند تولید‌کنندگان، مصرف‌کنندگان، موضوعات، پارتیشن‌ها و آفست‌ها برای ایجاد یک مدل داده مقیاس‌پذیر و قابل اعتماد برای جریان رویدادها استفاده می‌کند](https://www.confluent.io/learn/event-streaming/)[3](https://www.confluent.io/learn/event-streaming/)

[](https://www.npmjs.com/package/event-stream)[1](https://www.npmjs.com/package/event-stream): [](https://www.npmjs.com/package/event-stream)[2](https://www.ibm.com/products/event-streams): [](https://www.npmjs.com/package/event-stream)[3](https://www.confluent.io/learn/event-streaming/):

------------
idempotent
یک عملیات در نرم‌افزار زمانی idempotent است که انجام چندین بار آن تأثیر یکسانی را داشته باشد. به عبارت دیگر، نتیجهٔ یک عملیات idempotent مستقل از تعداد دفعاتی است که آن عملیات اجرا می‌شود. برای مثال، در یک وب سرویس RESTful، متدهای GET ، PUT و DELETE idempotent هستند، چون فراخوانی چندین بار آن‌ها تغییری در وضعیت منبع مورد نظر ایجاد نمی‌کند. [اما متد POST idempotent نیست، چون هر بار که فراخوانی شود، یک منبع جدید ایجاد می‌کند](https://sokanacademy.com/academy/courses/%D8%A2%D9%85%D9%88%D8%B2%D8%B4-restful-api/%D9%81%D8%B5%D9%84-%DB%B1-98/%D8%AF%D8%B1%D8%A2%D9%85%D8%AF%DB%8C-%D8%A8%D8%B1-%D9%85%D9%81%D9%87%D9%88%D9%85-idempotent-%D8%AF%D8%B1-%D8%AA%D9%88%D8%B3%D8%B9%D9%87-restful-api)[1](https://sokanacademy.com/academy/courses/%D8%A2%D9%85%D9%88%D8%B2%D8%B4-restful-api/%D9%81%D8%B5%D9%84-%DB%B1-98/%D8%AF%D8%B1%D8%A2%D9%85%D8%AF%DB%8C-%D8%A8%D8%B1-%D9%85%D9%81%D9%87%D9%88%D9%85-idempotent-%D8%AF%D8%B1-%D8%AA%D9%88%D8%B3%D8%B9%D9%87-restful-api)

[](https://sokanacademy.com/academy/courses/%D8%A2%D9%85%D9%88%D8%B2%D8%B4-restful-api/%D9%81%D8%B5%D9%84-%DB%B1-98/%D8%AF%D8%B1%D8%A2%D9%85%D8%AF%DB%8C-%D8%A8%D8%B1-%D9%85%D9%81%D9%87%D9%88%D9%85-idempotent-%D8%AF%D8%B1-%D8%AA%D9%88%D8%B3%D8%B9%D9%87-restful-api)[1](https://sokanacademy.com/academy/courses/%D8%A2%D9%85%D9%88%D8%B2%D8%B4-restful-api/%D9%81%D8%B5%D9%84-%DB%B1-98/%D8%AF%D8%B1%D8%A2%D9%85%D8%AF%DB%8C-%D8%A8%D8%B1-%D9%85%D9%81%D9%87%D9%88%D9%85-idempotent-%D8%AF%D8%B1-%D8%AA%D9%88%D8%B3%D8%B9%D9%87-restful-api):

--------------
event source 

یک event source در نرم‌افزار یک مولد رویداد است که از طریق یک ارتباط پایدار با یک سرور، رویدادهایی را به مشترکان خود ارسال می‌کند. این رویدادها می‌توانند اطلاعاتی را در مورد وضعیت یا تغییرات سرور منتقل کنند. [برای مثال، یک وب سایت می‌تواند از یک event source برای اطلاع رسانی به کاربران در مورد اخبار جدید، نظرات جدید یا به‌روزرسانی‌های جدید استفاده کند](https://www.zoomit.ir/computer-learning/272299-find-read-windows-error-log-files-event-logs/)[1](https://www.zoomit.ir/computer-learning/272299-find-read-windows-error-log-files-event-logs/)

یک event source معمولاً با استفاده از پروتکل HTTP و فرمت text/event-stream با سرور ارتباط برقرار می‌کند. این فرمت یک فرمت ساده و استاندارد برای ارسال داده‌های متنی از سرور به مشترکان است. [هر رویداد می‌تواند یک نام، یک شناسه و یک داده داشته باشد](https://blog.faradars.org/windows-event-viewer/)[2](https://blog.faradars.org/windows-event-viewer/)

یک event source می‌تواند با استفاده از رابط برنامه‌نویسی EventSource در وب API ایجاد شود. این رابط یک نمونه از EventSource را با یک آدرس سرور به عنوان پارامتر می‌سازد. این نمونه یک اتصال پایدار به سرور باز می‌کند و رویدادهایی را که از سرور دریافت می‌کند را به صورت خودکار به شیء EventSource اضافه می‌کند. [این شیء می‌تواند رویدادهای مختلف را با استفاده از تابع addEventListener گوش دهد و با استفاده از تابع close اتصال را ببندد](https://developer.mozilla.org/en-US/docs/Web/API/EventSource)[3](https://developer.mozilla.org/en-US/docs/Web/API/EventSource)

[](https://www.zoomit.ir/computer-learning/272299-find-read-windows-error-log-files-event-logs/)[1](https://www.zoomit.ir/computer-learning/272299-find-read-windows-error-log-files-event-logs/): [](https://www.zoomit.ir/computer-learning/272299-find-read-windows-error-log-files-event-logs/)[2](https://blog.faradars.org/windows-event-viewer/)[: [Server-Sent Events - Web APIs | MDN]](https://developer.mozilla.org/en-US/docs/Web/API/EventSource) [3](https://developer.mozilla.org/en-US/docs/Web/API/EventSource): [EventSource - Web APIs | MDN]

--------------
event publication
یک event publication یک فرایند است که در آن یک event source یک رویداد را به یک یا چند event consumer ارسال می‌کند. این فرایند می‌تواند به صورت همزمان یا ناهمزمان انجام شود. در حالت همزمان، event consumer در زمان ارسال رویداد، آن را دریافت و پردازش می‌کند. [در حالت ناهمزمان، event consumer می‌تواند رویداد را در زمان دیگری دریافت و پردازش کند](https://www.eventindustrynews.com/)[1](https://www.eventindustrynews.com/)

یک event publication می‌تواند از الگوهای مختلفی برای ارتباط بین event source و event consumer استفاده کند. برخی از این الگوها عبارتند از:

- انتشار-اشتراک: در این الگو، event source یک رویداد را به یک موضوع یا یک کانال ارسال می‌کند و event consumer می‌تواند به موضوع یا کانال مورد علاقه‌اش مشترک شود. [این الگو از اتصال مستقیم بین event source و event consumer جلوگیری می‌کند و امکان ارسال رویداد به چندین event consumer را فراهم می‌کند](https://www.specialevents.com/)[2](https://www.specialevents.com/)
- انتشار-مشترک: در این الگو، event source یک رویداد را به یک صف ارسال می‌کند و event consumer می‌تواند از صف رویداد را بردارد. [این الگو از انباشته شدن رویدادها در event source جلوگیری می‌کند و امکان پردازش رویداد توسط یک event consumer را فراهم می‌کند](https://learn.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/devenv-publishing-events)[3](https://learn.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/devenv-publishing-events)
- انتشار-پاسخ: در این الگو، event source یک رویداد را به یک event consumer ارسال می‌کند و event consumer یک پاسخ را به event source برمی‌گرداند. [این الگو از تبادل اطلاعات دوطرفه بین event source و event consumer استفاده می‌کند و امکان انجام یک معامله را فراهم می‌کند](https://www.eventbrite.com/blog/ds00-how-to-write-a-post-event-blog/)[4](https://www.eventbrite.com/blog/ds00-how-to-write-a-post-event-blog/)

[](https://www.eventindustrynews.com/)[1](https://www.eventindustrynews.com/): [](https://www.eventindustrynews.com/)[2](https://www.specialevents.com/): [](https://www.eventindustrynews.com/)[3](https://learn.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/devenv-publishing-events): [](https://www.eventindustrynews.com/)[4](https://www.eventbrite.com/blog/ds00-how-to-write-a-post-event-blog/):

---------------

[**پروب‌ها (Probes)** در مهندسی ابر به عنوان **بررسی‌های سلامت** برای کنترل‌کننده‌ها و مدیران سیستم‌ها استفاده می‌شوند](https://www.padok.fr/en/blog/kubernetes-probes)[1](https://www.padok.fr/en/blog/kubernetes-probes)[2](https://cloud.google.com/blog/products/containers-kubernetes/kubernetes-best-practices-setting-up-health-checks-with-readiness-and-liveness-probes). این پروب‌ها به منظور نظارت بر وضعیت سلامت و عملکرد سرویس‌ها و کانتینرها در محیط‌های ابری ایجاد می‌شوند.

سه نوع پرکاربرد پروب‌ها عبارتند از:

1. **پروب زنده‌بودن (Liveness Probe)**: این نوع پروب تشخیص می‌دهد که آیا کانتینر به درستی در حال اجرا است یا خیر. اگر تعداد خطاها به حد نصاب رسید، کانتینر متوقف می‌شود. در اکثر موارد، بسته به سیاست راه‌اندازی مجدد کانتینر، Kubernetes به طور خودکار کانتینر را مجدداً راه‌اندازی می‌کند.
    
2. **پروب آماده‌بودن (Readiness Probe)**: این نوع پروب بررسی می‌کند که آیا کانتینر آماده پاسخ‌دهی به درخواست‌ها است یا خیر. اگر کانتینر آماده نباشد، Kubernetes آن را از مجموعه‌های خدمات حذف می‌کند تا به درخواست‌ها پاسخ ندهد.
    
3. **پروب راه‌اندازی (Startup Probe)**: این نوع پروب در زمان راه‌اندازی کانتینر اجرا می‌شود و بررسی می‌کند که آیا کانتینر به درستی آماده پذیرش درخواست‌ها است یا خیر.
    

[با استفاده از پروب‌ها، می‌توانیم به Kubernetes اطلاع دهیم که کانتینرها در چه زمانی به درستی عمل می‌کنند و در چه زمانی نیاز به مداخله دارند](https://www.padok.fr/en/blog/kubernetes-probes)[1](https://www.padok.fr/en/blog/kubernetes-probes)[2](https://cloud.google.com/blog/products/containers-kubernetes/kubernetes-best-practices-setting-up-health-checks-with-readiness-and-liveness-probes).


------------
event storage
یک event storage یک نوع پایگاه داده است که برای ذخیره رویدادها بهینه‌سازی شده است. رویدادها اطلاعاتی در مورد تغییراتی هستند که در یک سیستم یا یک موجودیت رخ می‌دهند. یک event storage رویدادها را به صورت یک سری غیرقابل تغییر در یک event log ذخیره می‌کند. [این event log می‌تواند برای بازسازی حالت گذشته یا فعلی یک سیستم یا یک موجودیت، تحلیل رفتار، پیش‌بینی آینده و ایجاد گزارش‌ها مورد استفاده قرار گیرد](https://developer.mozilla.org/en-US/docs/Web/API/Window/storage_event)[1](https://developer.mozilla.org/en-US/docs/Web/API/Window/storage_event)

برخی از مزایای استفاده از یک event storage عبارتند از:

- امکان ثبت وقایع به صورت کامل و دقیق، بدون از دست دادن یا بازنویسی داده‌ها
- امکان پیگیری علت و اثر رویدادها و تشخیص خطاها و مشکلات
- امکان اعمال مدل‌های مختلف بر روی داده‌ها با استفاده از پروژه‌ها و پردازش جریان رویداد
- امکان انطباق با معماری رویدادگرا و میکروسرویس‌ها
- امکان ارتباط با مشترکان مختلف با استفاده از اشتراک‌های رویداد

[](https://developer.mozilla.org/en-US/docs/Web/API/Window/storage_event)[1](https://developer.mozilla.org/en-US/docs/Web/API/Window/storage_event):

---------------
Backing store
**Backing store** به معنای هر حافظه‌ای است که داده‌ها در آن ذخیره می‌شوند، اما اجرا نمی‌شوند. به عبارت دیگر، دیسک به عنوان **بک‌آپ** حافظه‌ی RAM عمل می‌کند. در واقع، دیسک یک **مخزن پشتیبان** برای حافظه‌ی سریع‌تر و کوچک‌تر RAM است. این ممکن است در ابتدا به نظر بیاید که این موضوع مشکلات عملکرد بزرگی را ایجاد می‌کند، زیرا در نهایت درایوهای دیسک نسبت به RAM خیلی کندتر هستند. اگرچه این موضوع درست است، اما می‌توان از رفتار دسترسی متوالی و محلی برنامه‌ها بهره برد و اکثر تأثیرات عملکرد استفاده از درایوهای دیسک به عنوان حافظه‌ی پشتیبان برای RAM را از بین ببریم. این کار با ساختاردهی زیرسیستم حافظه‌ی مجازی انجام می‌شود تا تلاش کند که قسمت‌هایی از برنامه که در حال حاضر نیاز دارند یا احتمالاً در آینده نزدیک نیاز خواهند داشت، تنها تا زمانی که واقعاً نیاز دارند در RAM نگه داشته شوند. [از نظر بسیاری این مشابه رابطه‌ی بین حافظه‌ی نهان (cache) و RAM است: ایجاد مقدار کمی از حافظه‌ی سریع همراه با مقدار زیادی از حافظه‌ی کند به نحوی که مانند یک مقدار زیادی از حافظه‌ی سریع عمل کند](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/4/html/introduction_to_system_administration/s2-memory-virt-where)[1](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/4/html/introduction_to_system_administration/s2-memory-virt-where)[2](https://www.computerhope.com/jargon/b/backing-storage.htm).

----------------
**Third party** در نرم‌افزار به برنامه‌ها یا سرویس‌هایی اشاره دارد که نه شما آن‌ها را ساخته‌اید و نه شرکتی که نرم‌افزار را تولید کرده است. [به عبارت دیگر، **third party** برنامه‌ها توسط افراد یا شرکت‌های دیگری نوشته می‌شوند](https://camelcase.ir/%d8%aa%d9%88%d8%b6%db%8c%d8%ad-%d8%b3%db%8c%d8%b3%d8%aa%d9%85-%db%8c%d8%a7-third-party/)[1](https://camelcase.ir/%D8%AA%D9%88%D8%B6%DB%8C%D8%AD-%D8%B3%DB%8C%D8%B3%D8%AA%D9%85-%DB%8C%D8%A7-third-party/)[2](https://bing.com/search?q=third+party+%D8%AF%D8%B1+%D9%86%D8%B1%D9%85+%D8%A7%D9%81%D8%B2%D8%A7%D8%B1+%DA%86%DB%8C%D8%B3%D8%AA%D8%9F)[3](https://bit-and.com/blog/%D9%86%D8%B1%D9%85-%D8%A7%D9%81%D8%B2%D8%A7%D8%B1-third-party-%DA%86%DB%8C%D8%B3%D8%AA%D8%9F/). [این نرم‌افزارها می‌توانند به عنوان پلاگین‌ها یا افزونه‌ها به نرم‌افزار‌های اصلی اضافه شوند و قابلیت‌های جدیدی را به آن‌ها اضافه کنند](https://camelcase.ir/%d8%aa%d9%88%d8%b6%db%8c%d8%ad-%d8%b3%db%8c%d8%b3%d8%aa%d9%85-%db%8c%d8%a7-third-party/)[1](https://camelcase.ir/%D8%AA%D9%88%D8%B6%DB%8C%D8%AD-%D8%B3%DB%8C%D8%B3%D8%AA%D9%85-%DB%8C%D8%A7-third-party/). [به عنوان مثال، در نرم‌افزار‌های مرورگر و برنامه‌های چندرسانه‌ای، افزونه‌ها و پلاگین‌های third party می‌توانند تجربه کاربری را بهبود بخشند](https://camelcase.ir/%d8%aa%d9%88%d8%b6%db%8c%d8%ad-%d8%b3%db%8c%d8%b3%d8%aa%d9%85-%db%8c%d8%a7-third-party/)[1](https://camelcase.ir/%D8%AA%D9%88%D8%B6%DB%8C%D8%AD-%D8%B3%DB%8C%D8%B3%D8%AA%D9%85-%DB%8C%D8%A7-third-party/)[4](http://mathpc.ir/fa/department-of-computer/computer-trick/517-Third-Party-%DB%8C%D8%B9%D9%86%DB%8C-%DA%86%D9%87). [از طرفی، نرم‌افزارهای third party ممکن است از منابع خارجی دانلود شوند و نیاز به تنظیمات امنیتی داشته باشند تا بتوانید آن‌ها را نصب کنید](https://camelcase.ir/%d8%aa%d9%88%d8%b6%db%8c%d8%ad-%d8%b3%db%8c%d8%b3%d8%aa%d9%85-%db%8c%d8%a7-third-party/)[3](https://bit-and.com/blog/%D9%86%D8%B1%D9%85-%D8%A7%D9%81%D8%B2%D8%A7%D8%B1-third-party-%DA%86%DB%8C%D8%B3%D8%AA%D8%9F/).

--------------
 load balancin
----------------
[**Polling** یک تکنیک ساده اما قدرتمند است که به شما امکان می‌دهد به طور دوره‌ای جدیدترین مقادیر داده‌ها را بررسی کرده و از ارائه درخواست‌های اضافی تا زمانی که به حالت مطلوب نرسیده است جلوگیری کنید](https://blog.faradars.org/polling-in-javascript/)[1](https://blog.faradars.org/polling-in-javascript/). در واقع، با استفاده از Polling، ما در یک بازه زمانی معین، با ارسال درخواست‌های API به یک سرور، داده‌های تازه را بررسی می‌کنیم. این تکنیک معمولاً در مواردی که نیاز به بررسی دوره‌ای داده‌ها داریم، مورد استفاده قرار می‌گیرد.

**زمان‌هایی که می‌توان از Polling استفاده کرد:**

- **احراز هویت کاربران**: مثلاً در فرآیند ثبت نام کاربران، می‌توانیم از Polling برای ارتباط با ارائه‌دهنده‌های شخص ثالثِ خدمات احراز هویت مانند Firebase یا Auth 0 استفاده کنیم. در این حالت، کلاینت منتظر تایید احراز هویت و ایجاد کاربر در سمت سرور می‌ماند.
- [**ردگیری مکان**: مثلاً در نقشه‌های ردگیری مکان مانند Uber، می‌توانیم با Polling نزدیک شدن راننده را به طور مکرر بررسی کنیم تا همیشه داده‌ها به‌روز باشند](https://blog.faradars.org/polling-in-javascript/)[1](https://blog.faradars.org/polling-in-javascript/).

در ادامه، یک تابع `poll` را در جاوا اسکریپت پیاده‌سازی می‌کنیم. این تابع با استفاده از Promise‌ها، داده‌ها را بررسی می‌کند و تا زمانی که به حالت مطلوب نرسیده است، درخواست‌های API را ارسال می‌کند:

```javascript
const poll = async ({ fn, validate, interval, maxAttempts }) => {
  let attempts = 0;

  const executePoll = async (resolve, reject) => {
    const result = await fn();
    attempts++;

    if (validate(result)) {
      return resolve(result);
    } else if (maxAttempts && attempts === maxAttempts) {
      return reject(new Error('Exceeded max attempts'));
    } else {
      setTimeout(executePoll, interval, resolve, reject);
    }
  };

  return new Promise(executePoll);
};
```

این تابع `poll` یک تابع مرتبه بالا است که تابع دیگری به نام `executePoll` را بازگشت می‌دهد. تابع `executePoll` یک Promise بازگشت می‌دهد و به طور بازگشتی تا زمانی که شرطی محقق شود، اجرا می‌شود. تابع `poll` چهار متغیر به عنوان آرگومان می‌گیرد:

- `fn`: تابعی که در طی یک بازه مفروض اجرا می‌شود (معمولاً یک درخواست API

---------------------
**وب هوک (Webhook)** یک پیام خودکاری است که در صورت وقوع یک رویداد، به وسیله‌ی اپلیکیشن‌ها ارسال می‌شود. این روش در برنامه‌نویسی وب کاربرد دارد. وب هوک حاوی یک بسته‌ی اطلاعاتی (Payload) است که به یک آدرس منحصربفرد (URL) ارسال می‌شود. از وب هوک معمولاً به عنوان روش بهتری نسبت به سرکشی کردن (Polling) استفاده می‌شود. [این روش بسیار شبیه به نوتیفیکیشن پیامک عمل می‌کند](https://blog.faradars.org/%D9%88%D8%A8-%D9%87%D9%88%DA%A9-webhook-%DA%86%DB%8C%D8%B3%D8%AA%D8%9F/)[1](https://blog.faradars.org/%D9%88%D8%A8-%D9%87%D9%88%DA%A9-webhook-%DA%86%DB%8C%D8%B3%D8%AA%D8%9F/)[2](https://bing.com/search?q=webhook+%D8%AF%D8%B1+%D9%86%D8%B1%D9%85+%D8%A7%D9%81%D8%B2%D8%A7%D8%B1+%DA%86%DB%8C%D8%B3%D8%AA%D8%9F). اگر بخواهید داده‌ها را به برنامه‌های دیگر تحویل دهید، وب هوک به شما این امکان را می‌دهد که فوراً داده‌ها را دریافت کنید.

------------
index table جدول شاخص

-------------------
sharded data داده خرد شده

--------------------------
elasticity



-----------
workflows
wildcard
eventual consistency
container
daemon
roll back
Expose 
remote
replication backplane
MapReduce
big data
split tcp -> https://learn.microsoft.com/en-us/azure/frontdoor/front-door-traffic-acceleration?pivots=front-door-standard-premium
Anycast   -> [Anycast routing](https://en.wikipedia.org/wiki/Anycast) 
Serverless -> Serverless computing
pay as you go -> https://en.wikipedia.org/wiki/Pay_as_you_go
granular control  کنترل دانه
load balancers
session -> https://en.wikipedia.org/wiki/Session_(computer_science)
daemon -> https://en.wikipedia.org/wiki/Daemon_(computing)
façade -> https://en.wikipedia.org/wiki/Facade_pattern
migrate -> https://en.wikipedia.org/wiki/Data_migration
connection pool -> https://en.wikipedia.org/wiki/Connection_pool
thread pool -> https://en.wikipedia.org/wiki/Thread_pool
tenant -> https://en.wikipedia.org/wiki/Multitenancy
Kubernetes ->wiki
pod -> https://kubernetes.io/docs/concepts/workloads/pods/
blob storage -> [blob storage](https://en.wikipedia.org/wiki/Object_storage)
rollback
scaling out
Edge
 Serverless computing
vocab
--------------------
circuit breaker - قطع کننده مدار
request - درخواست
shards - قطعه
expose
endpoint
سازگاری(eventual consistency)؟
تراکنش جبرانی (Compensating Transaction)







![[Pasted image 20240312232952.png]]



https://roadmap.sh/system-design

  





