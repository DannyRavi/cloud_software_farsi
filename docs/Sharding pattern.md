یک ذخیره‌گاه داده (data store) را به مجموعه ای از پارتیشن های افقی یا shard تقسیم کنید. این گزینه می تواند مقیاس پذیری را هنگام ذخیره سازی و دسترسی به حجم زیادی از داده ها بهبود بخشد.
## **طرح صورت مسئله:**

یک ذخیره‌گاه داده که توسط یک سرور واحد میزبانی می شود ممکن است مشمول محدودیت های زیر باشد:  
  
* **فضای ذخیره سازی**. انتظار می رود که یک ذخیره‌گاه داده برای یک برنامه ابری در مقیاس بزرگ حاوی حجم عظیمی از داده ها باشد که می تواند در طول زمان به میزان قابل توجهی افزایش یابد. یک سرور معمولاً فقط مقدار محدودی از دیسک را فراهم می‌کند، اما می‌توانید دیسک‌های موجود را با دیسک‌های بزرگ‌تر جایگزین کنید یا با افزایش حجم داده، دیسک‌های بیشتری را به دستگاه اضافه کنید. با این حال، سیستم در نهایت به حدی می رسد که امکان افزایش آسان ظرفیت ذخیره سازی در یک سرور خاص وجود ندارد.  
  
* **منابع محاسباتی**. یک برنامه اجرایی در محیط ابری معمولا باید توانایی پشتیبانی و پاسخ به صورت همزمان  یا موازی به تعداد زیادی از کاربرها را داشته باشد، پس بسیاری از این درخواست‌های کاربرها پرس و جوهایی(queries) را اجرا می کنند که اطلاعات را از ذخیره‌گاه داده بازیابی می کنند.  ممکن است یک سرور که وظیفه میزبانی ذخیره داده‌ها را دارند، نتواند قدرت محاسباتی لازم را برای پشتیبانی از این بار فراهم کند که در نتیجه منجر به طولانی‌تر شدن زمان پاسخ دهی برای کاربران شده و خرابی‌های مکرر برنامه‌ به صورت مشکلات ناشی از time-out به خصوص برای ذخیره و بازیابی داده‌ها  می‌شود. ممکن است امکان افزودن حافظه یا ارتقاء پردازنده ها وجود داشته باشد، اما زمانی که امکان افزایش منابع محاسباتی بیشتر نباشد، سیستم به یک محدودیت نهایی می رسد.  
  
* **پهنای باند شبکه.** در نهایت، عملکرد یک ذخیره‌گاه داده که روی یک سرور واحد اجرا می‌شود، توسط نرخی که سرور می‌تواند درخواست‌ها و ارسال پاسخ‌ها را دریافت کند، کنترل می‌شود. ممکن است حجم ترافیک شبکه از ظرفیت شبکه ای که برای اتصال به سرور استفاده می شود بیشتر باشد و در نتیجه درخواست‌ها ناموفق باشد.  
  
* **جغرافیا.** ممکن است به دلایلی مثل موارد قانونی  یا کارایی برنامه یا کاهش تأخیر دسترسی به داده و بسیاری از موارد دیگر، داده های تولید شده توسط کاربران خاص در همان منطقه جغرافیایی مربوط به کاربران خاص، ذخیره شود. اگر کاربران در کشورها یا مناطق مختلف پراکنده باشند، ممکن است امکان ذخیره کل داده های برنامه در یک ذخیره‌گاه داده وجود نداشته باشد.  
  
مقیاس عمودی(Scaling vertically) با افزودن ظرفیت دیسک، قدرت پردازش، حافظه و اتصالات شبکه بیشتر می‌تواند اثرات برخی از این محدودیت‌ها را به تعویق بیندازد، اما احتمالاً تنها یک راه‌حل موقتی است. یک برنامه تجاری ابری که قادر به پشتیبانی از تعداد زیادی کاربر و حجم بالای داده است، باید تقریباً به طور نامحدود مقیاس پذیر باشد، بنابراین مقیاس‌دهی عمودی لزوماً بهترین راه حل نیست.

## **راه حل:**

ذخیره داده را به پارتیشن های افقی یا shard تقسیم کنید. هر shard طرحواره یکسانی دارد، اما زیرمجموعه مجزایی از داده ها را در خود دارد. یک shard به خودی خود یک ذخیره‌‌گاه داده است (می‌تواند حاوی داده‌های بسیاری از موجودیت‌های مختلف باشد)، که روی سروری اجرا می‌شود که به عنوان یک گره ذخیره‌سازی عمل می‌کند.  
  
این الگو دارای مزایای زیر است:

* می‌توانید با افزودن shard‌های بیشتر در حال اجرا بر روی گره‌های ذخیره‌سازی اضافی، سیستم را کوچک کنید.  
  
* یک سیستم می تواند برای هر گره ذخیره سازی به جای کامپیوترهای تخصصی و گران قیمت، از سخت افزار آماده استفاده کند.  
  
* شما می توانید با ایجاد تعادل در حجم کار در بین shard ها، مغایرت‌ها را کاهش دهید و کارایی سیستم را بهبود بخشید.  
  
* در فضای ابری، shard‌ها را می‌توان از نظر فیزیکی نزدیک به کاربرانی که به داده‌ها دسترسی دارند، قرار داد.  
  
هنگام تقسیم یک ذخیره‌سازی داده‌ها به shard‌ها، تصمیم بگیرید که کدام داده در هر shard قرار گیرد. یک shard معمولاً شامل مواردی است که در محدوده مشخصی قرار می‌گیرند که توسط یک یا چند ویژگی داده تعیین می‌شود. این ویژگی ها کلیدی shard (که گاهی اوقات به عنوان کلید پارتیشن نامیده می شود) را تشکیل می دهند. کلید shard باید ثابت باشد. این کلید نباید بر اساس داده هایی باشد که ممکن است تغییر کند.  
  
معمولا با استفاده از shard می‌توان  داده ها را به صورت فیزیکی سازماندهی کرد. هنگامی که یک برنامه داده ها را ذخیره و بازیابی می کند، sharding logic برنامه را به shard مناسب هدایت می کند. این sharding logic می تواند به عنوان بخشی از کد دسترسی به داده ها در برنامه پیاده سازی شود یا اگر سیستم ذخیره سازی داده ها به طور شفاف از sharding پشتیبانی می کند، می تواند آن را پیاده سازی کند. 
  
انتزاعی کردن موقعیت فیزیکی داده ها در sharding logic، سطح بالایی از کنترل بر روی اینکه کدام shard ها حاوی چه داده ای هستند را فراهم می کند. همچنین اگر داده‌های موجود در shard‌ها باید بعداً و در فرصتی دیگر توزیع شوند (مثلاً اگر shardها نامتعادل شوند) داده‌ها را قادر می‌سازد تا بین shardها بدون تغییر منطق تجاری یک برنامه مهاجرت (migrate) کنند. این مبادله، منجر به سربار دسترسی به داده اضافی است که برای تعیین مکان هر مورد داده در زمان بازیابی آن لازم است.  

برای اطمینان از کارایی و مقیاس پذیری بهینه در برنامه مهم است که داده ها را به گونه ای تقسیم کنید که برای انواع پرس و جوهایی (queries) که برنامه انجام می دهد، مناسب باشد. در بسیاری از موارد، بعید است که طرح اشتراک گذاری دقیقاً با الزامات هر پرس و جو مطابقت داشته باشد. به عنوان مثال، در یک سیستم multi-tenant، ممکن است یک برنامه نیاز به بازیابی داده های tenant با استفاده از شناسه tenant داشته باشد، اما ممکن است نیاز به جستجوی این داده ها بر اساس برخی ویژگی های دیگر مانند نام یا مکان tenant داشته باشد. برای مدیریت این شرایط، یک استراتژی sharding را با یک کلید shard که متداول ترین پرس و جوها را پشتیبانی می کند، اجرا کنید.  
  
اگر پرس و جوها (queries) به طور منظم داده‌ها را با استفاده از ترکیبی از مقادیر مشخصه بازیابی می کنند، احتمالاً می توانید با پیوند دادن ویژگی ها به یکدیگر، یک کلید shard ترکیبی تعریف کنید. روش دیگر، از الگویی مانند [Index Table](https://learn.microsoft.com/en-us/azure/architecture/patterns/index-table) برای ارائه جستجوی سریع به داده ها بر اساس ویژگی هایی که توسط کلید shard پوشیده نشده اند استفاده کنید.


## استراتژی‌های Sharding 

معمولاً هنگام انتخاب کلید shard و تصمیم‌گیری درباره نحوه توزیع داده‌ها در بین shardها از سه استراتژی مختلف استفاده می‌شود. توجه داشته باشید که لازم نیست یک ارتباط یک به یک بین shard ها و سرورهایی که آنها را میزبانی می کنند وجود داشته باشد در واقع یک سرور واحد می تواند چندین shard را میزبانی کند. این استراتژی‌های مورد نظر عبارتند از:  
  
**استراتژی جستجو**؛ در این استراتژی sharding logic مسیری را پیاده سازی می کند که درخواست برای داده‌ها را با استفاده از کلید shard به قطعه ای که حاوی آن داده است هدایت می کند. در یک برنامه multi-tenant، تمام داده‌های یک مستاجر(tenant) ممکن است با هم در یک shard با استفاده از شناسه مستاجر(tenant ID) به عنوان کلید shard ذخیره شود. ممکن است multi-tenantها یک shard را به اشتراک بگذارند، اما داده‌های یک tenant در چند shard پخش نمی‌شود. شکل زیر به اشتراک گذاری داده های مستاجر بر اساس شناسه های مستاجر را نشان می دهد.



![[Pasted image 20231205121504.png]]

نگاشت بین کلید shard و حافظه فیزیکی می تواند بر اساس shard های فیزیکی باشد که در آن هر کلید shard به یک پارتیشن فیزیکی نگاشت می شود. روش پیشنهادی دیگر استفاده از یک تکنیک انعطاف‌پذیرتر برای متعادل‌سازی مجدد شاردها به کمک پارتیشن‌بندی مجازی است که در آن کلیدهای shard به همان تعداد shardهای مجازی نگاشت می‌شوند که آن ها نیز به نوبه خود به پارتیشن‌های فیزیکی کمتری نگاشت می‌شوند. در این رویکرد، یک برنامه داده‌ها را با استفاده از یک کلید shard که به یک shard مجازی اشاره دارد، مکان یابی می کند و سیستم به طور شفاف، shard های مجازی را به پارتیشن های فیزیکی نگاشت می کند. نگاشت بین یک پارتیشن مجازی و یک پارتیشن فیزیکی می تواند بدون نیاز به تغییر کد برنامه برای استفاده از مجموعه متفاوتی از کلیدهای shard تغییر کند.  
  
**استراتژی محدوده.** این استراتژی اقلام مرتبط را با هم در یک shard گروه بندی می کند و آنها را بر اساس کلید shard مرتب می کند - معمولا کلیدهای shard به صورت متوالی هستند. برای برنامه‌هایی که همیشه مجموعه‌هایی از آیتم‌ها را با استفاده از پرس‌وجوهای محدوده(range queries) بازیابی می‌کنند (پرس‌وجوهایی که مجموعه‌ای از آیتم‌های داده را برای یک کلید shardای که در محدوده معینی قرار می‌گیرد، برمی‌گردانند) مناسب است. به عنوان مثال، اگر یک برنامه به طور همیشگی نیاز به یافتن همه سفارش‌های ثبت‌شده در یک ماه خاص داشته باشد و اگر همه سفارش‌های یک ماه به ترتیب تاریخ و زمان در یک قطعه(shard) ذخیره شوند در نتیجه می‌توان این داده‌ها را سریع‌تر بازیابی کرد. اگر هر سفارش در shardای متفاوت ذخیره می‌شد در آن موقع باید با انجام تعداد زیادی پرس‌وجوی دقیق (پرس‌وجوهایی که یک مورد داده واحد را برمی‌گرداند) به‌صورت جداگانه واکشی شوند. شکل بعدی ذخیره مجموعه های متوالی (محدوده) داده ها را به صورت shard نشان می دهد.

![[Pasted image 20231205121518.png]]

در این مثال، کلید shard یک کلید ترکیبی است که حاوی ماه سفارش به عنوان مهم‌ترین عنصر و به دنبال آن روز سفارش و زمان است. زمانی که سفارش‌های جدید ایجاد می‌شوند و به یک shard اضافه می‌شوند، داده‌های سفارش‌ها به طور طبیعی مرتب می‌شوند. برخی از ذخیره‌گاه های داده از کلیدهای shard دو قسمتی حاوی یک عنصر کلید پارتیشن که shard را شناسایی می کند و یک کلید ردیفی که به طور منحصر به فرد یک مورد خاص را در shard شناسایی می کند، پشتیبانی می کنند. داده ها معمولاً به ترتیب کلیدهای ردیفی در shard نگهداری می شوند. مواردی که در معرض پرس و جوهای محدوده (range queries) هستند و باید با هم گروه بندی شوند، می توانند از کلید shard ای استفاده کنند که مقدار یکسانی برای کلید پارتیشن داشته و یک مقدار منحصر به فرد برای کلید ردیف نیز دارند.  
  
**استراتژی هش**. هدف از این استراتژی کاهش شانس hotspot ها (تکه ها یا shard هایی که مقدار نامتناسبی از بار دریافت می کنند) است. این گزینه داده ها را در بین shard ها به گونه ای توزیع می کند که بین اندازه هر shard و میانگین باری که هر shard با آن مواجه می شود تعادل ایجاد می کند.  sharding logic، شارد را برای ذخیره یک آیتم بر اساس هش یک یا چند ویژگی از داده ها محاسبه می کند. تابع هش انتخاب شده باید داده ها را به طور یکنواخت در بین shard ها توزیع کند و احتمالاً  این کار را به کمک با وارد کردن برخی از عناصر تصادفی در محاسبات خود انجام می‌دهد. شکل بعدی  داده های sharding tenant را بر اساس هش مربوط به شناسه tenant ها نشان می دهد.

![[Pasted image 20231205121531.png]]

برای درک مزیت استراتژی هش نسبت به سایر استراتژی‌های sharding این مورد را در نظر بگیرید که چگونه یک application یا برنامه  multi-tenant که مستاجران(tenants) جدید را به‌طور متوالی ثبت‌نام می‌کند و ممکن است tenantها را به shardهایی در ذخیره‌گاه داده(data store) ربط دهد. هنگام استفاده از استراتژی محدوده  (Range)، داده‌های مستاجران(tenants) از شماره  1 تا n همگی در قطعه A، داده‌های  tenantها از شماره n+1 تا m همه در shard B ذخیره می‌شوند. اگر tenantهایی که اخیراً ثبت نام کرده اند فعالیت بالایی نیز داشته باشند، پس این به معنی بیشترین فعالیت داده در تعداد کمی از shard ها رخ می دهد که می تواند باعث ایجاد hotspot ها شود. در مقابل، استراتژی هش مستاجران را بر اساس هش tenant ID به shardها اختصاص می‌دهد. این بدان معنی است که tenantهای متوالی به احتمال زیاد به shard های مختلف اختصاص داده می شوند که بار را در بین آنها توزیع می کند. شکل قبلی این موضوع را برای tenantهای شماره 55 و 56 نشان می دهد.



سه استراتژی اشتراک گذاری دارای مزایا و ملاحظات زیر است:

* **جستجو (Lookup)**. این امر کنترل بیشتری بر نحوه پیکربندی و استفاده از shard ها ارائه می دهد. استفاده از shardهای مجازی، اثر بخشی را هنگام متعادل‌سازی مجدد داده‌ها کاهش می‌دهد، زیرا می‌توان پارتیشن‌های فیزیکی جدیدی اضافه کرد تا حجم کار(workload) را یکنواخت کند. نگاشت بین یک shard مجازی و پارتیشن‌های فیزیکی که آن را پیاده‌سازی می‌کنند می تواند قابل تغییر باشد و این کار را بدون تأثیرگذاری بر کد برنامه‌ای که از یک کلید shard برای ذخیره و بازیابی داده‌ها استفاده می‌کند را انجام دهد،  در نهایت جست‌وجوی مکان‌های shard می‌تواند هزینه‌های اضافی را تحمیل کند.  
  
* **محدوده (Range).** پیاده سازی این کار آسان است و به خوبی با پرس و جوهای محدوده(range queries) کار می کند زیرا آنها اغلب می توانند چندین مورد داده را از یک قطعه(shard) واحد در یک عملیات واحد واکشی کنند. این استراتژی مدیریت داده ها را آسان تر می کند. به عنوان مثال، اگر کاربران در همان منطقه در یک shard باشند، به روز رسانی ها را می توان در هر منطقه زمانی بر اساس بار محلی و الگوی تقاضا برنامه ریزی کرد. با این حال، این استراتژی تعادل مطلوب بین shard ها را فراهم نمی کند. تعادل مجدد shard ها دشوار است و اگر بیشتر فعالیت ها برای کلیدهای shard مجاور باشد، ممکن است مشکل بار ناهموار را حل نکند.  
  
* هش. این استراتژی شانس بیشتری برای توزیع یکنواخت داده و بار ارائه می دهد. مسیریابی درخواست را می توان مستقیماً با استفاده از تابع هش انجام داد و نیازی به نگهداری نگاشت‌ها نیست. توجه داشته باشید که محاسبه هش ممکن است سربار اضافی را تحمیل کند. همچنین تعادل مجدد shard ها در این روش تا حدودی دشوار است.


اکثر سیستم های اشتراک گذاری رایج یکی از رویکردهای شرح داده شده در بالا را اجرا می کنند، اما باید الزامات تجاری application  خود و الگوهای استفاده از داده آنها را نیز در نظر بگیرید. به عنوان مثال، در یک برنامه multi-tenant:  
  
* شما می توانید داده ها را بر اساس حجم کاری، خرد(shard) کنید. شما می توانید داده ها را برای  tenantها بسیار زود گذر( highly volatile tenants) در shard های جداگانه تفکیک کنید. در نتیجه سرعت دسترسی به داده‌ها برای سایر tenantها ممکن است بهبود یابد.  
  
* می توانید داده ها را بر اساس موقعیت مکانی tenantها، خرد(shard) کنید. می‌توانید داده‌های tenantها را در یک منطقه جغرافیایی خاص را برای پشتیبان‌گیری و نگهداری در ساعات شلوغی در آن منطقه به‌صورت آفلاین دریافت کنید، در حالی که داده‌های tenantها در مناطق دیگر آنلاین و در ساعات کاری آن‌ها در دسترس است.  
  
* به tenantهای ارزشمند می‌توان shardهای خصوصی با کارایی بالا و دارای بار سبک (lightly loaded) اختصاص داد، در حالی که از tenantهای کم‌ارزش‌تر می‌توان انتظار داشت که shardهای پرمشغله‌تر و متراکم‌تری را به اشتراک بگذارند.  
  
* داده های tenantهای که به درجه بالایی از جداسازی داده ها و حفظ حریم خصوصی نیاز دارند را می توان در یک سرور کاملا مجزا ذخیره کرد.

## عملیات Scaling و data movement 

هر یک از استراتژی های به اشتراک گذاری مستلزم قابلیت ها و سطوح پیچیدگی متفاوتی برای مدیریت scale in و  scale out، جابجایی داده ها و حفظ وضعیت است.  
  
استراتژی Lookup یا جستجو اجازه می دهد تا عملیات مقیاس گذاری(scaling) و جابجایی داده ها در سطح کاربر، به صورت آنلاین یا آفلاین انجام شود. این تکنیک عبارت است از تعلیق برخی یا تمام فعالیت‌های کاربر (شاید در دوره‌های غیر اوج مصرف)، انتقال داده‌ها به پارتیشن مجازی یا قطعه فیزیکی جدید، تغییر نگاشت‌ها، نامعتبر کردن یا refresh کردن حافظه‌های پنهانی(caches) که این داده‌ها را در خود نگه می‌دارد و در ادامه دوباره اجازه فعالیت کردن یا ادامه دادن را به کاربر را می‌دهد. اغلب این نوع عملیات را می توان به صورت متمرکز مدیریت کرد. استراتژی Lookup یا جستجو مستلزم آن است که وضعیت داده ها قابل ذخیره‌سازی (cacheable)  و تکثیر یا replica شدن باشد.  
  
استراتژی محدوده یا Range محدودیت‌هایی را بر مقیاس‌گذاری و عملیات جابجایی داده اعمال می‌کند که معمولاً باید زمانی انجام شود که بخشی یا تمام ذخیره‌سازی داده آفلاین است، زیرا داده‌ها باید تقسیم شده و در بین shardها ادغام شوند. اگر بیشتر فعالیت‌ها مربوط به کلیدهای  shard مجاور یا شناسه‌های داده‌ای است که در محدوده یکسان هستند، انتقال داده‌ها به تعادل مجدد shardها ممکن است مشکل بار ناهموار را حل نکند. استراتژی Range همچنین ممکن است برای نگاشت محدوده(map ranges) به پارتیشن‌های فیزیکی نیاز به حفظ وضعیت خود داشته باشد.  

استراتژی هش، مقیاس‌گذاری و عملیات جابجایی داده‌ها را پیچیده‌تر می‌کند، زیرا کلیدهای پارتیشن هش‌های کلیدهای  shard یا شناسه داده‌ها هستند. مکان جدید هر قطعه باید از تابع هش تعیین شود یا تابع اصلاح شود تا نگاشت صحیح را ارائه دهد. با این حال، استراتژی Hash نیازی به حفظ وضعیت خود ندارد.

## مسائل و ملاحظات:

هنگام تصمیم گیری در مورد نحوه اجرای این الگو به نکات زیر توجه کنید:  
  
* استفاده از Sharding مکمل سایر اشکال پارتیشن بندی مانند پارتیشن بندی عمودی و پارتیشن بندی تابعی(functional) است. به عنوان مثال، یک shard به تنهایی می‌تواند شامل موجودیت‌هایی باشد که به صورت عمودی پارتیشن بندی شده‌اند و یک پارتیشن تابعی می‌تواند به صورت چند shard پیاده‌سازی شود. برای اطلاعات بیشتر در مورد پارتیشن بندی، به راهنمای پارتیشن بندی داده ها( [Data Partitioning Guidance](https://learn.microsoft.com/en-us/previous-versions/msp-n-p/dn589795(v=pandp.10))) مراجعه کنید.  
  
* همیشه shard ها را متعادل نگه دارید تا همه آنها حجم مشابهی از I/O (ورودی/خروجی) را کنترل کنند. از آنجایی که داده ها درج و حذف می شوند، لازم است که به صورت دوره ای دوباره تعادل shard ها را برای تضمین توزیع یکنواخت و کاهش وقوع هات‌اسپات‌ها تنظیم کنید. متعادل سازی مجدد shard ها می تواند یک عملیات پرهزینه باشد. برای کاهش نیاز به متعادل سازی مجدد باید با اطمینان از اینکه هر shard دارای فضای خالی کافی برای رسیدگی به حجم مورد انتظار تغییرات است برای رشد برنامه ریزی کنید. همچنین باید استراتژی‌ها و اسکریپت‌هایی را ایجاد کنید که در صورت لزوم، می‌توانید از آنها برای متعادل کردن مجدد سریع shard‌ها استفاده کنید.  
  
* از داده‌های پایدار برای کلید shard استفاده کنید. اگر کلید shard تغییر کند، آیتم داده مربوطه ممکن است باید بین shardها جابه‌جا شود و میزان کار انجام شده توسط عملیات به‌روزرسانی افزایش یابد. به همین دلیل از قرار دادن کلید خرد بر روی اطلاعات بالقوه فرار خودداری کنید. در عوض، به دنبال ویژگی هایی باشید که ثابت هستند یا به طور طبیعی ویژگی‌های لازم برای یک کلید را تشکیل می دهند.  
  
* اطمینان حاصل کنید که کلیدهای shard شده منحصر به فرد هستند. به عنوان مثال، از استفاده از فیلدهای افزایش خودکار (autoincrement) به عنوان کلید shard خودداری کنید. در برخی سیستم‌ها، فیلدهای افزایش‌یافته خودکار را نمی‌توان در بین shardها هماهنگ و بروزرسانی کرد که در نهایت منجر به این می‌شود که آیتم‌هایی در shardهای مختلف کلید shard یکسانی داشته باشند.

> مقادیر افزایش یافته خودکار (autoincrement) در سایر فیلدها که کلیدهای shard نیستند نیز می تواند باعث ایجاد مشکل شود. به عنوان مثال، اگر از فیلدهای افزایش یافته خودکار برای تولید شناسه های منحصر به فرد ( unique IDs) استفاده می کنید، ممکن است به دو مورد مختلف که در shard های مختلف قرار دارند، یک شناسه اختصاص داده شود.

* ممکن است طراحی یک کلید shard ای که با الزامات هر درخواست  در برابر داده ها مطابقت داشته باشد، امکان پذیر نباشد. داده‌ها را برای پشتیبانی از اغلب پرس‌و‌جوهای انجام‌شده تکه تکه و تقسیم بندی کنید و در صورت لزوم جداول index ثانویه را برای پشتیبانی از پرس‌و‌جوهای (queries) که داده‌ها را با استفاده از معیارهایی بر اساس ویژگی‌هایی که بخشی از کلید shard نیست ایجاد کنید. برای اطلاعات بیشتر،  [Index Table pattern](https://learn.microsoft.com/en-us/azure/architecture/patterns/index-table) را ببینید.  
  
* پرس و جوهایی که فقط به یک shard دسترسی دارند کارآمدتر از آنهایی هستند که داده ها را از چند shard بازیابی می کنند، بنابراین از پیاده سازی یک سیستم اشتراک گذاری که منجر به اجرای تعداد زیادی پرس و جو توسط برنامه هایی می شود که داده های نگهداری شده در shard های مختلف را به هم می پیوندند خودداری کنید. به یاد داشته باشید که یک shard می‌تواند حاوی داده‌های چند نوع موجودیت باشد. غیر نرمال سازی کردن (denormalizing) داده‌های خود را در نظر بگیرید تا موجودیت‌های مرتبطی را که معمولاً در کنار هم جستجو می‌شوند (مانند جزئیات مشتریان و سفارش‌هایی که آنها انجام داده‌اند) در یک shard نگه دارید تا تعداد خواندن‌های جداگانه‌ای که یک برنامه انجام می‌دهد کاهش یابد.

> اگر موجودی در یک shard به یک موجودیت ذخیره شده در shard دیگر ارجاع دهد، کلید shard موجودیت دوم را به عنوان بخشی از طرح موجودیت اول وارد کنید. این گزینه می تواند به بهبود عملکرد پرس و جوهایی که به داده های مرتبط در سراسر shard ارجاع می دهند کمک کند.

* اگر یک برنامه باید پرس و جوهایی را انجام دهد که داده ها را از چند shard بازیابی می کند، ممکن است بتوان این داده ها را با استفاده از تسک‌های موازی واکشی کرد. مثال‌هایی شامل  پرس‌وجوهای fan-out، که در آن داده‌های چند shard به صورت موازی بازیابی می‌شوند و سپس در یک نتیجه نهایی جمع می‌شوند. با این حال، این رویکرد پیچیدگی هایی را به منطق دسترسی به داده های مربوط به این راه حل اضافه می کند.  
  
* برای بسیاری از کاربردها ایجاد تعداد بیشتر shardهای کوچک می‌تواند کارآمدتر از داشتن تعداد کمی shardهای بزرگ باشد، زیرا می‌توانند فرصت‌های بیشتری را برای متعادل کردن بار ارائه دهند. این مورد هم می تواند مفید باشد اگر شما نیاز به مهاجرت shard‌ها از یک مکان فیزیکی به مکان دیگر را پیش بینی کنید. حرکت دادن یک قطعه(shard) کوچک سریعتر از حرکت دادن یک shard بزرگ است.  
  
* اطمینان حاصل کنید که منابع موجود برای هر گره ذخیره‌سازی shard  برای رسیدگی به نیازهای مقیاس‌پذیری از نظر اندازه و توان داده کافی است. برای اطلاعات بیشتر، بخش 'طراحی پارتیشن ها برای مقیاس پذیری' را در راهنمای پارتیشن بندی داده‌ها ([Data Partitioning Guidance](https://learn.microsoft.com/en-us/previous-versions/msp-n-p/dn589795(v=pandp.10))) را ببینید.  
  
* تکرار داده‌های مرجع (replicating reference) برای همه shard ها را در نظر بگیرید. اگر عملیاتی که داده‌ها را از یک shard بازیابی می‌کند به داده‌های ثابت یا داده‌های دارای حرکت آهسته نیز به عنوان بخشی از همان پرس و جو (query) اشاره می‌کند پس باید این داده‌ها را به shard اضافه کنید. سپس برنامه می‌تواند تمام داده‌های مربوط به پرس و جو را به راحتی واکشی کند بدون اینکه نیازی به رفت و برگشت اضافی به یک ذخیره‌گاه داده جداگانه داشته باشد.

> اگر داده های مرجع نگهداری شده در چند shard تغییر کند، سیستم باید این تغییرات را در همه shard ها همگام سازی  کند. هر چند سیستم می تواند درجه ای از ناهماهنگی را در زمانی که این همگام سازی رخ می دهد را تجربه و تحمل کند. در نتیجه اگر این کار را انجام می دهید بهتر است برنامه های خود را طوری طراحی کنید که توانایی مدیریت این مورد را داشته باشید.



* حفظ یکپارچگی ارجاع‌ها و سازگاری بین shardها می‌تواند دشوار باشد، بنابراین باید عملیات‌هایی را که روی داده‌ها در چند shard تأثیر می‌گذارند، به حداقل برسانید. اگر برنامه‌ای باید داده‌ها را در بین shardها تغییر دهد ابن نکته را ارزیابی کنید که آیا سازگاری کامل داده‌ها(complete data consistency) واقعاً مورد نیاز است یا خیر. درعوض، یک رویکرد رایج در فضای ابری، اجرای حالت سازگاری احتمالی (eventual consistency) است. در این حالت داده‌های هر پارتیشن به‌طور جداگانه به‌روزرسانی می‌شوند و منطق برنامه باید مسئولیت اطمینان از تکمیل موفقیت‌آمیز به‌روزرسانی‌ها و همچنین رسیدگی به ناهماهنگی‌هایی را که می‌تواند از جستجوی داده‌ها در زمانی که یک عملیات در حالت  سازگاری احتمالی(eventually consistent) در حال اجرا است، به عهده بگیرد. برای اطلاعات بیشتر در مورد اجرای سازگاری احتمالی، به [Data Consistency Primer](https://learn.microsoft.com/en-us/previous-versions/msp-n-p/dn589800(v=pandp.10)) مراجعه کنید.  
  
* پیکربندی و مدیریت تعداد زیادی از shardها می تواند  چالش برانگیز باشد. وظایفی مانند نظارت(monitoring)، تهیه نسخه پشتیبان، بررسی سازگاری و ثبت لاگ‌ها(logging) یا بررسی‌ها(auditing) باید بر روی چندین shard و سرور انجام شود که احتمالاً در مکان‌های مختلف نگهداری می‌شوند. این وظایف احتمالاً با استفاده از اسکریپت ها یا سایر راه حل های اتوماسیون اجرا می شوند، اما ممکن است الزامات اجرایی اضافی را به طور کامل حذف نکند.  
  
* گاهی shardها را می‌توان به گونه‌ای مکان‌یابی کرد که داده‌های موجود در آنها به نمونه‌های برنامه‌ای که از آن استفاده می‌کند نزدیک باشد. این رویکرد می‌تواند کارایی برنامه  را به طور قابل توجهی بهبود بخشد، اما برای تسک‌هایی که باید به چند shard در مکان‌های مختلف دسترسی داشته باشند، نیاز به بررسی بیشتری دارد.

## **چه زمانی از این الگو استفاده کنیم؟**

از این الگو زمانی استفاده کنید که یک ذخیره‌گاه داده به احتمال زیاد نیاز به مقیاس پذیری فراتر از منابع موجود برای یک گره ذخیره سازی دارد یا حالتی که بهبود کارایی با کاهش مغایرت در یک ذخیره‌گاه داده را در نظر دارد.

```
توجه داشته باشید  
  
تمرکز اصلی sharding بهبود کارایی و مقیاس پذیری یک سیستم است، اما به عنوان یک محصول جانبی می تواند به دلیل نحوه تقسیم داده ها به پارتیشن های جداگانه، قابلیت‌های  دسترسی(availability) را نیز بهبود بخشد. خرابی در یک پارتیشن لزوماً مانع از دسترسی یک برنامه به داده‌های نگهداری شده در پارتیشن‌های دیگر نمی‌شود و یک اپراتور می‌تواند تعمیر و نگهداری یا بازیابی یک یا چند پارتیشن را بدون اینکه کل داده‌های یک برنامه غیرقابل دسترسی باشد، انجام دهد. برای اطلاعات بیشتر، به راهنمای پارتیشن بندی داده ها [Data Partitioning Guidance](https://learn.microsoft.com/en-us/previous-versions/msp-n-p/dn589795(v=pandp.10)) مراجعه کنید.
```

## مثال

مثال زیر در سی شارپ از مجموعه ای از پایگاه داده های SQL Server استفاده می کند که به عنوان shard عمل می کنند. هر پایگاه داده زیرمجموعه ای از داده های مورد استفاده یک برنامه را در خود جای می دهد. این برنامه داده‌هایی را که در بین shardها توزیع شده است را با استفاده از sharding logic خودش بازیابی می‌کند (این نمونه‌ای از یک fan-out query است). جزئیات داده‌هایی که در هر shard قرار دارند با روشی به نام  `GetShards` بازگردانده می‌شوند. این روش یک لیست قابل شمارش از اشیاء `ShardInformation` را برمی گرداند، که در آن نوع `ShardInformation` شامل یک شناسه برای هر شارد و رشته اتصال به SQL Server است که برنامه باید از آن برای اتصال به  shard استفاده کند (رشته های اتصال (connection strings) در مثال کد زیر نشان داده نشده‌اند).

```csharp
private IEnumerable<ShardInformation> GetShards()
{
  // This retrieves the connection information from a shard store
  // (commonly a root database).
  return new[]
  {
    new ShardInformation
    {
      Id = 1,
      ConnectionString = ...
    },
    new ShardInformation
    {
      Id = 2,
      ConnectionString = ...
    }
  };
}
```

کد زیر نشان می‌دهد که چگونه برنامه از فهرست اشیاء `ShardInformation` برای انجام پرس و جو (query) استفاده می‌کند که داده‌ها را از هر shard به صورت موازی واکشی می‌کند. هر چند در این مثال جزئیات پرس و جو نشان داده نمی شود اما  داده های بازیابی شده حاوی رشته ای است که می تواند اطلاعاتی مانند نام مشتری را در خود نگه دارد، اگر shard ها حاوی جزئیات مشتریان باشند. نتایج در یک مجموعه `ConcurrentBag` برای پردازش توسط برنامه تجمیع می‌شوند.

```csharp
// Retrieve the shards as a ShardInformation[] instance.
var shards = GetShards();

var results = new ConcurrentBag<string>();

// Execute the query against each shard in the shard list.
// This list would typically be retrieved from configuration
// or from a root/primary shard store.
Parallel.ForEach(shards, shard =>
{
  // NOTE: Transient fault handling isn't included,
  // but should be incorporated when used in a real world application.
  using (var con = new SqlConnection(shard.ConnectionString))
  {
    con.Open();
    var cmd = new SqlCommand("SELECT ... FROM ...", con);

    Trace.TraceInformation("Executing command against shard: {0}", shard.Id);

    var reader = cmd.ExecuteReader();
    // Read the results in to a thread-safe data structure.
    while (reader.Read())
    {
      results.Add(reader.GetString(0));
    }
  }
});

Trace.TraceInformation("Fanout query complete - Record Count: {0}",
                        results.Count);
```

## قدم بعدی

راهنمایی زیر ممکن است هنگام اجرای این الگو نیز مرتبط باشد:  
  
* [Data Consistency Primer](https://learn.microsoft.com/en-us/previous-versions/msp-n-p/dn589800(v=pandp.10)). ممکن است لازم باشد برای داده های توزیع شده در shard های مختلف ویژگی سازگاری (consistency) حفظ شود. در واقع این گزینه مسائل مربوط به حفظ سازگاری در داده های توزیع شده را خلاصه می کند و مزایا و سبک و سنگین کردن‌های (tradeoffs)  مدل های سازگاری مختلف را شرح می دهد.  
* [Data Partitioning Guidance](https://learn.microsoft.com/en-us/previous-versions/msp-n-p/dn589795(v=pandp.10)). استفاده از Sharding در یک ذخیره‌گاه داده می تواند طیف وسیعی از مسائل اضافی را ایجاد کند. این مسائل  در رابطه با پارتیشن بندی ذخیره‌گاه‌های داده در فضای ابری برای بهبود مقیاس پذیری، کاهش مغابرت‌ها و بهینه سازی کارایی برنامه را توضیح می دهد.

## منابع مرتبط

الگوهای زیر نیز ممکن است هنگام اجرای این الگو مرتبط باشند:  
  
* الگوی جدول شاخص([Index Table pattern](https://learn.microsoft.com/en-us/azure/architecture/patterns/index-table)). گاهی اوقات پشتیبانی کامل از پرس و جوها فقط از طریق طراحی کلید shard امکان پذیر نیست. پس این مورد برنامه را قادر می‌سازد تا با تعیین کلیدی غیر از کلید shard، داده‌ها را از یک ذخیره‌گاه بزرگ داده به سرعت بازیابی کند.  
* الگوی نمای مادی([Materialized View pattern](https://learn.microsoft.com/en-us/azure/architecture/patterns/materialized-view)). برای حفظ کارایی برخی از عملیات پرس و جو، ایجاد Materialized View  که داده ها را جمع آوری و خلاصه می کند بسیار مناسب است، به خصوص اگر این داده های خلاصه بر اساس اطلاعاتی باشد که در بین shard ها توزیع شده است.در نهایت این مورد نحوه تولید و پر کردن این نماها را شرح می دهد.