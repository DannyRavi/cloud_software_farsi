
از هر یک از اجزای سیستم بخواهید به جای تکیه بر یک نقطه کنترل مرکزی، در فرآیند تصمیم گیری در مورد گردش کار یک معامله تجاری شرکت کنند.

## Context and problem

در معماری میکروسرویس‌ها، اغلب اتفاق می‌افتد که یک برنامه کاربردی مبتنی بر ابر به چندین سرویس کوچک تقسیم می‌شود که با هم کار می‌کنند تا یک تراکنش تجاری را سرتاسر پردازش کنند. برای کاهش اتصال بین خدمات، هر سرویس مسئول یک عملیات تجاری واحد است. برخی از مزایا عبارتند از توسعه سریعتر، پایه کد کوچکتر و مقیاس پذیری. با این حال، طراحی یک گردش کار کارآمد و مقیاس پذیر یک چالش است و اغلب به ارتباطات بین سرویسی پیچیده نیاز دارد.  
  
سرویس ها با استفاده از API های تعریف شده با یکدیگر ارتباط برقرار می کنند. حتی یک عملیات تجاری منفرد می تواند منجر به چندین تماس نقطه به نقطه در بین همه خدمات شود. یک الگوی رایج برای ارتباط استفاده از یک سرویس متمرکز است که به عنوان ارکستر کننده عمل می کند. تمام درخواست های دریافتی را تایید می کند و عملیات را به سرویس های مربوطه واگذار می کند. با انجام این کار، گردش کار کل معامله تجاری را نیز مدیریت می کند. هر سرویس فقط یک عملیات را تکمیل می کند و از گردش کار کلی آگاه نیست.  
  
الگوی ارکستراتور ارتباط نقطه به نقطه بین سرویس ها را کاهش می دهد، اما به دلیل اتصال تنگاتنگ بین ارکستراتور و سایر خدماتی که در پردازش تراکنش تجاری شرکت می کنند، دارای اشکالاتی است. برای اجرای کارها در یک توالی، ارکستراتور نیاز به دانش دامنه در مورد مسئولیت های آن خدمات دارد. اگر می‌خواهید سرویس‌ها را اضافه یا حذف کنید، منطق موجود خراب می‌شود و باید بخش‌هایی از مسیر ارتباطی را دوباره سیم‌کشی کنید. در حالی که می توانید گردش کار را پیکربندی کنید، خدمات را به راحتی با یک ارکستراتور خوب طراحی شده اضافه یا حذف کنید، چنین پیاده سازی پیچیده و نگهداری آن سخت است.

![[Pasted image 20231203232640.png]]

## Solution

اجازه دهید هر سرویس تصمیم بگیرد که یک عملیات تجاری چه زمانی و چگونه پردازش می شود، به جای اینکه به یک ارکستراتور مرکزی وابسته باشد.  
  
یکی از راه‌های پیاده‌سازی رقص، استفاده از الگوی پیام‌رسانی ناهمزمان برای هماهنگ کردن عملیات تجاری است.

![[Pasted image 20231203232705.png]]

درخواست مشتری پیام ها را در صف پیام منتشر می کند. با رسیدن پیام ها، به مشترکین یا خدماتی که به آن پیام علاقه مند هستند هدایت می شوند. هر سرویس مشترک عملیات خود را همانطور که در پیام نشان داده شده است انجام می دهد و با موفقیت یا شکست عملیات به صف پیام پاسخ می دهد. در صورت موفقیت، سرویس می تواند پیامی را به همان صف یا صف پیام دیگری برگرداند تا در صورت نیاز سرویس دیگری بتواند گردش کار را ادامه دهد. اگر عملیاتی با شکست مواجه شود، گذرگاه پیام می تواند آن عملیات را دوباره امتحان کند.  
  
به این ترتیب، سرویس ها بدون وابستگی به ارکستراتور یا ارتباط مستقیم بین آنها، جریان کار را بین خود طراحی می کنند.  
  
از آنجایی که ارتباط نقطه به نقطه وجود ندارد، این الگو به کاهش اتصال بین خدمات کمک می کند. همچنین، می تواند گلوگاه عملکرد ایجاد شده توسط ارکستراتور را در زمانی که باید با تمام تراکنش ها سر و کار داشته باشد، برطرف کند.


## When to use this pattern

اگر انتظار دارید سرویس‌ها را مرتباً به‌روزرسانی یا جایگزین کنید، و در نهایت برخی از خدمات را اضافه یا حذف کنید، از الگوی رقص استفاده کنید. کل برنامه را می توان با تلاش کمتر و حداقل اختلال در خدمات موجود تغییر داد.  
  
اگر با گلوگاه اجرا در ارکستراتور مرکزی مواجه شدید، این الگو را در نظر بگیرید.  
  
این الگو یک مدل طبیعی برای معماری بدون سرور است که در آن همه سرویس‌ها می‌توانند کوتاه مدت یا رویداد محور باشند. سرویس‌ها می‌توانند به‌دلیل یک رویداد بچرخند، وظیفه خود را انجام دهند و پس از پایان کار حذف شوند.

## Issues and considerations

غیرمتمرکز کردن ارکستراتور می تواند باعث ایجاد مشکلاتی در هنگام مدیریت گردش کار شود.  
  
اگر یک سرویس نتواند یک عملیات تجاری را تکمیل کند، بازیابی آن شکست می تواند دشوار باشد. یکی از راه‌ها این است که سرویس با شلیک یک رویداد، شکست را نشان دهد. سرویس دیگری که در آن رویدادهای ناموفق مشترک می شود، اقدامات لازم را انجام می دهد، مانند اعمال تراکنش های جبرانی برای خنثی سازی عملیات موفق در یک درخواست. سرویس ناموفق ممکن است رویدادی را به دلیل خرابی فعال کند. در آن صورت، استفاده از مکانیسم تلاش مجدد و یا زمان سپری کردن آن را برای تشخیص آن عملیات به عنوان یک شکست در نظر بگیرید. برای مثال به بخش Example مراجعه کنید.  
  
هنگامی که می خواهید عملیات تجاری مستقل را به صورت موازی پردازش کنید، پیاده سازی یک گردش کار ساده است. می توانید از یک گذرگاه پیام استفاده کنید. با این حال، زمانی که طراحی رقص باید در یک سکانس اتفاق بیفتد، گردش کار می تواند پیچیده شود. به عنوان مثال، سرویس C تنها پس از اینکه سرویس A و سرویس B عملیات خود را با موفقیت کامل کردند، می تواند عملیات خود را آغاز کند. یک رویکرد این است که چندین گذرگاه پیام داشته باشید که پیام ها را به ترتیب مورد نیاز دریافت می کنند. برای اطلاعات بیشتر به بخش مثال مراجعه کنید.  
  
اگر تعداد خدمات به سرعت رشد کند، الگوی رقص به یک چالش تبدیل می شود. با توجه به تعداد بالای قطعات متحرک مستقل، گردش کار بین سرویس ها پیچیده می شود. همچنین ردیابی توزیع شده مشکل می شود.  
  
ارکستراتور به طور متمرکز انعطاف پذیری گردش کار را مدیریت می کند و می تواند به یک نقطه شکست تبدیل شود. از سوی دیگر، برای رقص، نقش بین همه خدمات توزیع می شود و انعطاف پذیری کمتر استحکام می یابد.  
  
هر سرویس نه تنها مسئول انعطاف پذیری عملیات خود است، بلکه همچنین مسئولیت گردش کار را نیز بر عهده دارد. این مسئولیت می تواند برای خدمات سنگین باشد و اجرای آن سخت باشد. هر سرویس باید شکست‌های گذرا، غیرگذرا و زمان‌بندی را دوباره امتحان کند تا در صورت نیاز، درخواست به‌خوبی خاتمه یابد. همچنین سرویس باید نسبت به اطلاع رسانی موفقیت یا عدم موفقیت عملیات کوشا باشد تا سایر سرویس ها بر این اساس عمل کنند.


## Example

این مثال الگوی رقص را با برنامه تحویل هواپیماهای بدون سرنشین نشان می دهد. وقتی مشتری درخواست وانت می کند ، برنامه یک هواپیمای بدون سرنشین را اختصاص می دهد و به مشتری اطلاع می دهد.  
  
نمونه ای از این الگوی در GitHub موجود است.

![[Pasted image 20231203232837.png]]

یک معامله تجاری مشتری منفرد به سه عملیات تجاری متمایز نیاز دارد: ایجاد یا به‌روزرسانی یک بسته، اختصاص یک هواپیمای بدون سرنشین برای تحویل بسته و بررسی وضعیت تحویل. این عملیات توسط سه میکروسرویس انجام می‌شود: بسته، زمان‌بندی هواپیمای بدون سرنشین و خدمات تحویل. به جای ارکستراتور مرکزی، سرویس ها از پیام برای همکاری و هماهنگ کردن درخواست بین خود استفاده می کنند.

### Design

تراکنش تجاری به صورت متوالی از طریق پرش های متعدد پردازش می شود. هر هاپ دارای یک اتوبوس پیام و سرویس تجاری مربوطه است.  
  
هنگامی که یک مشتری درخواست تحویل را از طریق یک نقطه پایانی HTTP ارسال می کند، سرویس Ingestion آن را دریافت می کند، یک رویداد عملیاتی را مطرح می کند و آن را به یک گذرگاه پیام ارسال می کند. اتوبوس سرویس تجاری مشترک شده را فراخوانی می کند و رویداد را در یک درخواست POST ارسال می کند. با دریافت رویداد، خدمات تجاری می تواند عملیات را با موفقیت، شکست انجام دهد، یا زمان درخواست ممکن است به پایان برسد. در صورت موفقیت آمیز بودن، سرویس با کد وضعیت Ok به گذرگاه پاسخ می دهد، رویداد عملیات جدیدی را مطرح می کند و آن را به گذرگاه پیام هاپ بعدی ارسال می کند. در صورت خرابی یا وقفه، سرویس با ارسال کد BadRequest به گذرگاه پیامی که درخواست اصلی POST را ارسال کرده است، خرابی را گزارش می دهد. گذرگاه پیام عملیات را بر اساس خط مشی سعی مجدد دوباره انجام می دهد. پس از انقضای آن دوره، گذرگاه پیام، عملیات ناموفق را پرچم‌گذاری می‌کند و پردازش بیشتر کل درخواست متوقف می‌شود.  
  
این گردش کار تا زمانی که کل درخواست پردازش شود ادامه می یابد.  
  
این طرح از چندین گذرگاه پیام برای پردازش کل معامله تجاری استفاده می کند. Microsoft Azure Event Grid سرویس پیام رسانی را ارائه می دهد. این برنامه در یک خوشه Azure Kubernetes Service (AKS) با دو کانتینر در یک غلاف مستقر شده است. یک کانتینر Ambassador را اجرا می کند که با Event Grid تعامل دارد در حالی که دیگری یک سرویس تجاری را اجرا می کند. رویکرد با دو کانتینر در یک غلاف عملکرد و مقیاس پذیری را بهبود می بخشد. سفیر و خدمات تجاری شبکه یکسانی را به اشتراک می گذارند که امکان تأخیر کم و توان عملیاتی بالا را فراهم می کند.  
  
برای جلوگیری از تکرار عملیات آبشاری که ممکن است به تلاش‌های متعدد منجر شود، فقط شبکه رویداد به‌جای سرویس کسب‌وکار، یک عملیات را دوباره امتحان می‌کند. با ارسال یک پیام به یک صف نامه مرده (DLQ) یک درخواست ناموفق را علامت گذاری می کند.  
  
خدمات کسب و کار برای اطمینان از اینکه عملیات امتحان مجدد منجر به منابع تکراری نمی شود، ناتوان هستند. به عنوان مثال، سرویس Package از عملیات upsert برای افزودن داده ها به ذخیره اطلاعات استفاده می کند.  
  
این مثال یک راه حل سفارشی را برای ارتباط بین تماس ها در همه سرویس ها و پرش های Event Grid پیاده سازی می کند.  
  
در اینجا یک نمونه کد است که الگوی رقص بین تمام خدمات تجاری را نشان می دهد. گردش کار تراکنش های اپلیکیشن Drone Delivery را نشان می دهد. کدهای مربوط به رسیدگی و ثبت استثناها برای اختصار حذف شده است.

```csharp
[HttpPost]
[Route("/api/[controller]/operation")]
[ProducesResponseType(typeof(void), 200)]
[ProducesResponseType(typeof(void), 400)]
[ProducesResponseType(typeof(void), 500)]

public async Task<IActionResult> Post([FromBody] EventGridEvent[] events)
{

   if (events == null)
   {
       return BadRequest("No Event for Choreography");
   }

   foreach(var e in events)
   {

        List<EventGridEvent> listEvents = new List<EventGridEvent>();
        e.Topic = eventRepository.GetTopic();
        e.EventTime = DateTime.Now;
        switch (e.EventType)
        {
            case Operations.ChoreographyOperation.ScheduleDelivery:
            {
                var packageGen = await packageServiceCaller.UpsertPackageAsync(delivery.PackageInfo).ConfigureAwait(false);
                if (packageGen is null)
                {
                    //BadRequest allows the event to be reprocessed by Event Grid
                    return BadRequest("Package creation failed.");
                }

                //we set the event type to the next choreography step
                e.EventType = Operations.ChoreographyOperation.CreatePackage;
                listEvents.Add(e);
                await eventRepository.SendEventAsync(listEvents);
                return Ok("Created Package Completed");
            }
            case Operations.ChoreographyOperation.CreatePackage:
            {
                var droneId = await droneSchedulerServiceCaller.GetDroneIdAsync(delivery).ConfigureAwait(false);
                if (droneId is null)
                {
                    //BadRequest allows the event to be reprocessed by Event Grid
                    return BadRequest("could not get a drone id");
                }
                e.Subject = droneId;
                e.EventType = Operations.ChoreographyOperation.GetDrone;
                listEvents.Add(e);
                await eventRepository.SendEventAsync(listEvents);
                return Ok("Drone Completed");
            }
            case Operations.ChoreographyOperation.GetDrone:
            {
                var deliverySchedule = await deliveryServiceCaller.ScheduleDeliveryAsync(delivery, e.Subject);
                return Ok("Delivery Completed");
            }
            return BadRequest();
    }
}
```

## Related resources

این الگوها را در طراحی خود برای رقص در نظر بگیرید.  
  
* با استفاده از الگوی طراحی سفیر، خدمات تجاری را مدولار کنید.  
  
* الگوی تسطیح بار مبتنی بر صف را برای رسیدگی به نوسانات حجم کار اجرا کنید.  
  
* از پیام‌های توزیع شده ناهمزمان از طریق الگوی ناشر-مشترک استفاده کنید.  
  
* از تراکنش های جبرانی برای خنثی سازی یک سری عملیات موفق در صورت شکست یک یا چند عملیات مرتبط استفاده کنید.  
  
* برای اطلاعات در مورد استفاده از کارگزار پیام در زیرساخت پیام رسانی، به گزینه های پیام رسانی ناهمزمان در Azure مراجعه کنید.