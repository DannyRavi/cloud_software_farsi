# ‏Circuit Breaker pattern

برطرف کردن خطا‌های که  زمان نامشخصی برای بررسی و حل  آنها وجود دارد. در این شرایط این الگو می‌تواند ثبات(stability) و تاب‌آوری(resiliency) یک برنامه را بهبود بخشد.

## موضوع و مشکل

در یک محیط توزیع‌شده، تماس‌ها با منابع و سرویس‌‌های ریموت ممکن است به دلیل خطا‌های گذرا (transient fault)، مانند اتصالات آهسته و کند در شبکه، timeoutها یا بیش از حد پاسخ دادن به درخواست‌ها  یا در دسترس نبودن منابع ریموت، با خطا مواجه شوند. این خطاها معمولاً پس از مدت کوتاهی خود را اصلاح می‌کنند و یک برنامه ابری با کیفیت باید با استفاده از یک استراتژی مانند [Retry pattern](./Retry%20pattern.md) آماده باشد تا آنها را مدیریت کند.

با این حال، ممکن است شرایطی نیز وجود داشته باشد که خطاها ناشی از رویداد‌های غیرمنتظره باشد و رفع آن شاید زیاد طول بکشد. شدت این خطاها از قطع جزئی اتصال تا خرابی کامل یک سرویس متفاوت است. در این شرایط ممکن است برای یک برنامه بیهوده باشد که به طور مداوم عملیاتی را که بعید به نظر می‌رسد موفقیت آمیز باشد را بارها امتحان کند و در عوض برنامه باید سریعاً بپذیرد که عملیات شکست خورده است و بر این اساس این شکست را مدیریت کند.

علاوه بر این، اگر یک سرویس بسیار تحت فشار باشد، خرابی در یک قسمت از سیستم ممکن است منجر به خرابی‌های پشت سر هم و متوالی شود. به عنوان مثال، عملیاتی که یک سرویس را فراخوانی می‌کند می‌تواند طوری config شود تا یک timeout را اجرا کند و اگر سرویس در این مدت مشخص پاسخ ندهد پس درنهایت با یک پیام شکست پاسخ خود را بدهد. با این حال، این استراتژی می‌تواند باعث شود که بسیاری از درخواست‌‌های همزمان برای همان عملیات تا پایان دوره زمانی مسدود شوند. این درخواست‌های مسدود شده ممکن است منابع مهم سیستم مانند حافظه، thread ها، اتصالات پایگاه داده و غیره را در خود نگه دارند. در نتیجه، این منابع ممکن است تمام شود و باعث خرابی سایر بخش‌‌های احتمالاً نامرتبط سیستم شود که نیاز به استفاده از منابع مشابه دارند. در این مواقع، ترجیح داده می‌شود که عملیات فوراً با شکست مواجه شود و فقط در صورت احتمال وقوع موفقیت  سعی کنید سرویس را فراخوانی کنید. توجه داشته باشید که تنظیم یک timeout کوتاه‌تر ممکن است به حل این مشکل کمک کند، اما مهلت زمانی(timeout) نباید آنقدر کوتاه باشد که عملیات در بیشتر مواقع با شکست مواجه شود، حتی اگر درخواست سرویس در نهایت با موفقیت انجام شود.

## راه حل

الگوی  قطع کننده مدار (Circuit Breaker) که توسط مایکل نایگارد در کتابش با عنوان  [Release It!](https://pragprog.com/titles/mnee2/)  رایج شده است، می‌تواند مانع از تلاش مکرر برنامه برای اجرای عملیاتی شود که احتمال شکست آن وجود دارد. اجازه دادن به ادامه کار بدون انتظار برای رفع عیب یا هدر دادن چرخه‌‌های CPU در حالی که مشخص می‌کند که حل مشکل طولانی مدت است. الگوی Circuit Breaker همچنین یک برنامه یا اپلیکیشن را قادر می‌سازد تا بررسی کند یا  تشخیص دهد  چه زمانی مشکل برطرف شده است. اگر به نظر می‌رسد مشکل برطرف شده است، برنامه می‌تواند سعی کند عملیات را فراخوانی کند.


>	هدف از الگوی Circuit Breaker با الگوی Retry متفاوت است. الگوی Retry یک برنامه را قادر می‌سازد تا یک عملیات را مجدداً امتحان کند به این امید که موفق شود. الگوی Circuit Breaker مانع از انجام عملیاتی می‌شود که احتمال شکست آن وجود دارد. یک اپلیکیشن یا برنامه می‌تواند این دو الگو را با استفاده از الگوی Retry برای فراخوانی عملیات از طریق  Circuit Breaker ترکیب کند. با این حال، منطق امتحان مجدد(Retry) باید نسبت به exception‌هایی که توسط قطع کننده مدار (Circuit Breaker) بازگردانده می‌شود حساس باشد و اگر  Circuit Breaker نشان می‌دهد که یک خطا گذرا نیست، از تلاش مجدد صرف نظر کند.

قطع کننده مدار به عنوان یک پروکسی برای عملیاتی کار می‌کند که احتمال وقوع خطا در آن وجود دارد. پراکسی باید تعداد خرابی‌‌های که تازه رخ داده است را کنترل کند و از این اطلاعات برای تصمیم‌گیری برای ادامه عملیات استفاده کند یا به به سرعت یک استثنا/exception را  بازگرداند.  
  
پروکسی را می‌توان به عنوان یک  ماشین حالت (state machine) با حالت‌‌های زیر پیاده سازی کرد که عملکرد یک  Circuit Breaker را تقلید می‌کند:


‏  **حالت بسته  (Closed)**: این request از application به عملیات پردازشی مسیر دهی می‌شود. پراکسی شماره و تعداد خرابی‌‌های اخیر را نگه می‌دارد و اگر فراخوانی عملیات ناموفق باشد، پراکسی شمارش این تعداد را افزایش می‌دهد. اگر تعداد خرابی‌‌های اخیر از یک آستانه مشخص در یک بازه زمانی معین بیشتر شود، پروکسی در حالت سوییچ  باز قرار می‌گیرد. در این مرحله، پراکسی یک تایمر زمان‌بندی را شروع می‌کند و زمانی که این تایمر منقضی شد، پراکسی آن سوویچ را در  حالت نیمه باز قرار می‌دهد.

 >	هدف این شمارنده یا تایمر این است که به سیستم زمان بدهد تا مشکلی را که باعث خرابی شده است را قبل از اینکه به برنامه اجازه دهد تا دوباره عملیات را شروع کند، برطرف کند.
   	
**حالت باز  (Open)**: که درخواست یا request  از برنامه بلافاصله با شکست مواجه می‌شود و یک استثنا/exception به application باز می‌گردد.

**حالت نیمه باز (Half-Open)**: تعداد محدودی از request‌های برنامه مجاز به عبور و فراخوانی عملیات هستند. در صورت موفقیت آمیز بودن این درخواست ها، فرض بر این است که عیبی که قبلاً باعث خرابی شده بود برطرف شده است و کلید مدار به حالت بسته تغییر می‌کند (شمارگر خرابی تنظیم مجدد یا reset شده است). اگر هر درخواستی با شکست مواجه شود،  Circuit Breaker فرض می‌کند که خطا همچنان وجود دارد، بنابراین به حالت باز برمی‌گردد و تایمر timeout را مجدداً راه‌اندازی می‌کند تا به سیستم یک timeout بیشتر برای بازیابی از خرابی بدهد.

حالت نیمه باز برای جلوگیری از طغیان کردن ناگهانی requestها در بازیابی سرویس مناسب است. زمانی که یک سرویس بازیابی می‌شود، ممکن است بتواند حجم محدودی از درخواست‌ها را تا زمانی که بازیابی کامل شود پشتیبانی کند، اما در حالی که بازیابی در حال انجام است، حجم زیاد کار می‌تواند باعث شود که سرویس دچار timeout  بشود یا دوباره از کار بیفتد.

![circuit-breaker-diagram](../assets/other/circuit-breaker-diagram.png)


در شکل بالا، شمارشگر خرابی (failure counter) مورد استفاده در حالت بسته بوده و بر اساس زمان کار می‌کند و به طور خودکار در فواصل زمانی خاصی reset می‌شود. این حالت باعث جلوگیری از ورود circuit breaker به حالت باز در صورت بروز خرابی‌های گاه به گاه کمک می‌کند. آستانه خرابی که circuit breaker را به حالت باز می‌رساند، تنها زمانی به دست می‌آید که تعداد معینی از خرابی در یک بازه زمانی مشخص رخ داده باشد. شمارنده مورد استفاده در حالت نیمه باز، تعداد تلاش‌های موفقیت آمیز برای فراخوانی عملیات را ثبت می‌کند. پس از موفقیت آمیز بودن تعداد معینی از فراخوانی‌‌های متوالی، کلید مدار به حالت بسته سوییچ می‌کند. اگر هر فراخوانی ناموفق باشد، قطع کننده مدار بلافاصله وارد حالت باز می‌شود و دفعه بعد که وارد حالت نیمه باز شد، شمارنده success دوباره reset می‌شود.


>	 چگونه بازیابی سیستم به صورت خارجی انجام می‌شود؟ احتمالاً با بازیابی یا راه اندازی مجدد یک مؤلفه خراب شده یا تعمیر کردن اتصال شبکه.


الگوی Circuit Breaker پایداری و ثباتی را فراهم می‌کند در حالی که سیستم پس از  خراب  شدن به سرعت بازیابی می‌شود و تأثیر آن بر کارایی برنامه را به حداقل می‌رساند. همینطور این الگو می‌تواند سرعت پاسخ دهی  سیستم را حفظ کند و این کار را به کمک رد کردن سریع درخواست‌‌های عملیاتی که احتمال شکست آن وجود دارد، به جای اینکه منتظر بماند تا درخواست دچار timeout شود یا  اصلا پاسخی برای درخواست برنگردد. اگر circuit breaker هر بار که تغییر حالت می‌دهد، رویدادی را اعلان می‌کند، این گزینه می‌تواند برای نظارت بر سلامت  (health monitor) بخشی از سیستم که توسط circuit breaker محافظت می‌شود  یا برای هشدار دادن به administrator هنگامی که یک circuit breaker به حالت باز می‌رود، استفاده شود.

این الگو  با توجه به نوع خرابی احتمالی قابل تنظیم است. به عنوان مثال، شما می‌توانید یک تایمر افزایش timeout را برای circuit breaker اعمال کنید. می‌توانید circuit breaker را در ابتدا برای چند ثانیه در حالت باز قرار دهید و سپس اگر خرابی برطرف نشد timeout را به چند دقیقه افزایش دهید و به همین ترتیب این کار را تکرار کنید. در برخی موارد، به جای بازگرداندن حالت باز که بیانگر شکست عملیات است و ایجاد یک exception/استثنا در ادامه آن، بازگرداندن یک مقدار پیش‌فرض که برای برنامه معنادار است می‌تواند مناسب‌تر باشد.

## مسائل و ملاحظات


هنگام تصمیم گیری در مورد نحوه اجرای این الگو باید نکات زیر را در نظر بگیرید:

**رسیدگی به استثناها - Exception Handling**. برنامه‌ای که عملیاتی را از طریق  circuit breaker فراخوانی می‌کند باید برای رسیدگی به استثنا‌های مطرح شده در صورت در دسترس نبودن عملیات آماده شود. نحوه رسیدگی به استثناها مختص و خاص هر برنامه خواهد بود. به عنوان مثال، یک برنامه می‌تواند به طور موقت کارایی خود را کاهش دهد و یک عملیات جایگزین را برای انجام همان کار یا به دست آوردن همان داده‌ها فراخوانی کند یا استثنایی را به کاربر گزارش دهد و از او بخواهد که بعداً دوباره امتحان و تلاش مجدد کند.

**نوع استثنا - Types of Exceptions**. یک درخواست ممکن است به دلایل زیادی با شکست مواجه شود که برخی از آنها ممکن است نشان دهنده نوع شدیدتر شکست نسبت به سایرین باشد. به عنوان مثال، یک درخواست ممکن است به دلیل از کار افتادن یک سرویس ریموت حدود چند دقیقه طول بکشد تا بازیابی شود یا بخاطر timeout به دلیل بارگیری موقت سرویس، با شکست مواجه شود. یک circuit breaker ممکن است بتواند انواع استثنا‌هایی(exception) را که رخ می‌دهند بررسی کند و بسته به ماهیت این استثناها، استراتژی خود را تنظیم کند. به عنوان مثال و در مقایسه با تعداد خرابی‌‌های ناشی از در دسترس نبودن سرویس، ممکن است به تعداد بیشتری از timeout exceptions نیاز داشته باشد تا circuit breaker در حالت باز قرار گیرد.

**‏Logging**. یک قطع کننده مدار باید تمام درخواست‌های ناموفق (و احتمالاً درخواست‌های موفقیت آمیز) را ثبت کند تا administrator بتواند بر سلامت عملیات‌ها نظارت کند.


**قابلیت بازیابی - Recoverability**. حتما باید circuit breaker را طوری پیکربندی کنید که با الگوی recovery احتمالی از عملیاتی که آن را محافظت می‌کند مطابقت داشته باشد. به عنوان مثال، اگر  circuit breaker برای مدت طولانی در حالت باز بماند، حتی اگر دلیل خرابی برطرف شده باشد، می‌تواند exception ایجاد کند. به طور مشابه،  circuit breaker می‌تواند در صورت تغییر سریع از حالت باز به حالت نیمه باز، نوسان داشته باشد و زمان پاسخگویی برنامه‌ها را کاهش دهد.

**‏تست کردن عملیات شکست خورده - Testing Failed Operations**. در حالت باز، به جای استفاده از شمارنده برای تعیین زمان تغییر به حالت نیمه باز، یک  circuit breaker می‌تواند به طور دوره ‌ای سرویس یا منبع ریموت را ping کند تا مشخص کند که آیا دوباره در دسترس است یا خیر. این ping می‌تواند به شکل تلاشی برای فراخوانی عملیاتی باشد که قبلاً ناموفق بوده است، یا می‌تواند از یک عملیات ویژه ارائه شده توسط سرویس ریموت به طور خاص برای آزمایش سلامت سرویس استفاده کند، همانطور که در الگوی [Health Endpoint Monitoring pattern](./Health%20Endpoint%20Monitoring%20pattern.md) توضیح داده شده است.


**تنظیم مجدد  دستی - Manual Override**. در سیستمی که زمان بازیابی برای یک عملیات ناموفق بسیار متغیر است، ارائه یک گزینه تنظیم مجدد دستی که به administrator امکان می‌دهد قطع کننده مدار را ببندد (و شمارنده خطا را بازنشانی کند) سودمند است. به طور مشابه، اگر عملیات محافظت شده توسط قطع کننده مدار موقتاً در دسترس نباشد، یک administrator می‌تواند یک circuit breaker را به حالت باز وادار کند (و timeout timer را مجدداً راه اندازی کند).

**همزمانی - Concurrency**. هر قطع کننده مدار می‌تواند توسط تعداد زیادی از نمونه(instances)‌های همزمان یک برنامه قابل دسترسی باشد. پیاده سازی نباید request‌های همزمان را مسدود کند یا به هر فراخوانی به یک عملیات سربار اضافی وارد کند.

**منابع متمایز - Resource Differentiation**. اگر ممکن است چندین   ارائه دهنده (provider) مستقل  وجود داشته باشد، هنگام استفاده از یک قطع کننده مدار برای یک resource بسیار محتاط باشید. به عنوان مثال، در یک data store که حاوی چندین قطعه(shards) است، ممکن است یک مورد کاملاً در دسترس باشد در حالی که دیگری مشکلی موقتی را تجربه می‌کند. اگر پاسخ‌‌های خطا در این سناریوها ادغام شوند در نتیجه امکان دارد  یک برنامه  سعی کند به برخی از موارد صحیح دسترسی داشته باشد، حتی زمانی که احتمال شکست بسیار زیاد است. برعکس این حالت در زمانی است که دسترسی به موارد دیگر ممکن است مسدود شود حتی اگر احتمال موفقیت آن وجود داشته باشد.


**شتاب دادن به قطع کننده مدار - Accelerated Circuit Breaking **. گاهی اوقات یک پاسخ خطا می‌تواند حاوی اطلاعات کافی باشد تا کلید مدار فوراً خاموش شود و برای  زمان کوتاهی خاموش بماند. به عنوان مثال، پاسخ خطا از یک منبع مشترک که دچار سرریز ناشی از بار زیاد شده است می‌تواند نشان دهد که تلاش مجدد یا retry کردن به هیچ وجه توصیه نمی‌شود و در عوض برنامه باید چند دقیقه دیگر دوباره درخواست خود را امتحان کند.


>	نکته:  یک سرویس می‌تواند HTTP 429 (Requests‌‌های خیلی زیاد) را برگرداند در صورتی که کلاینت درخواست‌‌های بیش از حد لازم را ارسال می‌کند یا HTTP 503 (سرویس در دسترس نیست) را برگرداند اگر سرویس در حال حاضر در دسترس نباشد. پاسخ‌‌های سرویس می‌تواند شامل اطلاعات اضافی مانند مدت زمان پیش بینی شده تاخیر باشد.


**اجرای مجدد درخواست ‌های ناموفق - Replaying Failed Requests**.  یک  circuit breaker در حالت سوییچ باز  به جای اینکه به سرعت از کار بیفتد می‌تواند جزئیات هر درخواست را در یک journal ثبت کند و ترتیبی دهد که این درخواستها زمانی که منابع یا سرویس ریموت در دسترس قرار می‌گیرد، دوباره اجرا شوند.

**تایم‌اوت نامناسب در سرویس ‌های خارجی - Inappropriate Timeouts on External Services**. قطع کننده مدار ممکن است نتواند به طور کامل از برنامه‌ها در برابر عملیاتی که در سرویس‌های خارجی که با یک timeout طولانی پیکربندی شده اند و با شکست مواجه می‌شوند، محافظت کند. اگر timeout بیش از حد طولانی باشد، ممکن است thread‌ای که از یک قطع کننده مدار استفاده می‌کند، برای مدت طولانی مسدود شود، قبل از اینکه قطع کننده مدار نشان دهد که عملیات شکست خورده است. در این زمان، بسیاری از نمونه‌‌های دیگر نیز ممکن است سعی کنند سرویس را از طریق قطع کننده مدار فراخوانی کنند و تعداد قابل توجهی از threadها را قبل از اینکه همه آنها شکست بخورند را ببندند.

## چه زمانی از این الگو استفاده کنیم

از این الگو استفاده کنید:

*‏  برای جلوگیری از فراخوانی‌‌های تکراری یک برنامه روی یک سرویس خاص یا منابع اشتراکی که این فراخوانی‌ها با احتمال زیاد شکست عملیاتی مواجه هستند.

این الگو توصیه نمی‌شود:

*‏ برای مدیریت دسترسی به منابع خصوصی داخلی در یک اپلیکیشن، مانند in-memory data structureها . در این محیط، استفاده از قطع کننده مدار باعث افزایش سربار(overhead) به سیستم شما می‌شود.  

*‏ به عنوان جایگزینی برای رسیدگی به استثناها (handling exceptions) در منطق تجاری برنامه.


## مثال

در یک برنامه تحت وب که چندین صفحه با داده‌‌های بدست آمده از یک سرویس خارجی پر می‌شوند. اگر سیستم حداقل مقدار caching را پیاده سازی کند، بیشتر بازدیدها به این صفحات باعث ایجاد  یک حالت رفت و برگشتی یا به اصطلاح  round trip  به سرویس مقصد می‌شود. اتصالات از برنامه تحت وب به سرویس را می‌توان با یک timeout در بازه زمانی (معمولاً 60 ثانیه) پیکربندی کرد و اگر سرویس در این زمان پاسخ ندهد، منطق موجود در  هر صفحه وب فرض می‌کند که سرویس در دسترس نیست و یک exception ایجاد می‌کند.

با این حال، اگر سرویس از کار بیفتد و سیستم بسیار پر مشغله یا تحت فشار کاری باشد، کاربران باید حدود تا 60 ثانیه منتظر بمانند تا یک exception رخ دهد. در نهایت منابعی مانند حافظه، ارتباطات شبکه و threadها ممکن است تمام شود و از اتصال سایر کاربران به سیستم جلوگیری کند، حتی اگر به صفحاتی که داده‌ها را از سرویس بازیابی می‌کنند دسترسی نداشته باشند.

مقیاس‌بندی(Scaling) سیستم با افزودن وب سرور‌های بیشتر و اجرای توزیع کننده بار (load balancing) ممکن است تا زمانی که منابع تمام می‌شوند به تأخیر بیفتد اما این مشکلی را حل نمی‌کند زیرا درخواست‌‌های کاربرها همچنان دارای پاسخ نیستند و همه سرور‌های وب ممکن است در نهایت منابع خود را تمام کنند.

کلاس `CircuitBreaker` اطلاعات وضعیت را در مورد circuit breaker در یک object که interface `ICircuitBreakerStateStore`  نشان داده شده در کد زیر را پیاده سازی می‌کند، حفظ می‌کند.

```csharp
interface ICircuitBreakerStateStore
{
  CircuitBreakerStateEnum State { get; }

  Exception LastException { get; }

  DateTime LastStateChangedDateUtc { get; }

  void Trip(Exception ex);

  void Reset();

  void HalfOpen();

  bool IsClosed { get; }
}
```

مشخصه `State` وضعیت فعلی circuit breaker را نشان می‌دهد و همانطور که توسط شمارش `CircuitBreakerStateEnum` تعریف شده است، `Open`، `HalfOpen` یا `Closed` خواهد بود. اگر کلید مدار بسته باشد، ویژگی `IsClosed` باید درست باشد، اما اگر باز یا نیمه باز باشد، باید نادرست باشد. متد Trip وضعیت circuit breaker را به حالت باز تغییر می‌دهد و استثنایی را که باعث تغییر حالت شده است به همراه تاریخ و ساعت وقوع استثنا ثبت می‌کند. ویژگی‌های `LastException` و `LastStateChangedDateUtc` این اطلاعات را برمی گرداند. متد `Reset` نیز circuit breaker را می‌بندد و روش `HalfOpen` نیر  circuit breaker را روی نیمه باز قرار می‌دهد.

کلاس `InMemoryCircuitBreakerStateStore` در این مثال شامل پیاده سازی interface `ICircuitBreakerStateStore` است. کلاس `CircuitBreaker` نمونه ‌ای از این کلاس را ایجاد می‌کند تا وضعیت CircuitBreaker را حفظ کند.

متد `ExecuteAction` در کلاس `CircuitBreaker` عملیاتی را که به عنوان یک `Action` delegate مشخص شده است، بسته بندی (wraps) می‌کند. اگر قطع کننده مدار بسته باشد، `ExecuteAction` delegate `Action` را فراخوانی می‌کند. اگر عملیات ناموفق باشد، یک کنترل کننده خطا `TrackException` را فراخوانی می‌کند که وضعیت circuit breaker را برای باز کردن آن را تنظیم می‌کند. مثال کد زیر این جریان را مشخص می‌کند.

```csharp
public class CircuitBreaker
{
  private readonly ICircuitBreakerStateStore stateStore =
    CircuitBreakerStateStoreFactory.GetCircuitBreakerStateStore();

  private readonly object halfOpenSyncObject = new object ();
  ...
  public bool IsClosed { get { return stateStore.IsClosed; } }

  public bool IsOpen { get { return !IsClosed; } }

  public void ExecuteAction(Action action)
  {
    ...
    if (IsOpen)
    {
      // The circuit breaker is Open.
      ... (see code sample below for details)
    }

    // The circuit breaker is Closed, execute the action.
    try
    {
      action();
    }
    catch (Exception ex)
    {
      // If an exception still occurs here, simply
      // retrip the breaker immediately.
      this.TrackException(ex);

      // Throw the exception so that the caller can tell
      // the type of exception that was thrown.
      throw;
    }
  }

  private void TrackException(Exception ex)
  {
    // For simplicity in this example, open the circuit breaker on the first exception.
    // In reality this would be more complex. A certain type of exception, such as one
    // that indicates a service is offline, might trip the circuit breaker immediately.
    // Alternatively it might count exceptions locally or across multiple instances and
    // use this value over time, or the exception/success ratio based on the exception
    // types, to open the circuit breaker.
    this.stateStore.Trip(ex);
  }
}
```

مثال زیر کدی را نشان می‌دهد (که از مثال قبلی حذف شده است) که در صورت بسته نبودن circuit breaker اجرا می‌شود. این مثال ابتدا بررسی می‌کند که آیا  circuit breaker برای مدتی بیشتر از زمان مشخص شده توسط فیلد محلی `OpenToHalfOpenWaitTime` در کلاس `CircuitBreaker` باز بوده است یا خیر. اگر اینطور باشد، متد `ExecuteAction` نیز circuit breaker را روی نیمه باز تنظیم می‌کند، سپس سعی می‌کند عملیات مشخص شده توسط delegate `Action` را انجام دهد.

در صورت موفقیت آمیز بودن عملیات، circuit breaker به حالت بسته بازنشانی می‌شود. اگر عملیات با شکست مواجه شود، به حالت باز برمی‌گردد و زمان وقوع exception به‌روزرسانی می‌شود تا circuit breaker قبل از تلاش مجدد برای انجام عملیات، مدت بیشتری منتظر بماند.

علاوه بر این، از یک قفل برای جلوگیری از تلاش  circuit breaker برای برقراری تماس همزمان با عملیات در حالی که نیمه باز است، استفاده می‌کند. تلاش همزمان برای فراخوانی عملیات به گونه‌ای انجام می‌شود که گویی circuit breaker باز است و با استثنایی که بعداً توضیح داده شد با شکست مواجه می‌شود.


```csharp
...
    if (IsOpen)
    {
      // The circuit breaker is Open. Check if the Open timeout has expired.
      // If it has, set the state to HalfOpen. Another approach might be to
      // check for the HalfOpen state that had be set by some other operation.
      if (stateStore.LastStateChangedDateUtc + OpenToHalfOpenWaitTime < DateTime.UtcNow)
      {
        // The Open timeout has expired. Allow one operation to execute. Note that, in
        // this example, the circuit breaker is set to HalfOpen after being
        // in the Open state for some period of time. An alternative would be to set
        // this using some other approach such as a timer, test method, manually, and
        // so on, and check the state here to determine how to handle execution
        // of the action.
        // Limit the number of threads to be executed when the breaker is HalfOpen.
        // An alternative would be to use a more complex approach to determine which
        // threads or how many are allowed to execute, or to execute a simple test
        // method instead.
        bool lockTaken = false;
        try
        {
          Monitor.TryEnter(halfOpenSyncObject, ref lockTaken);
          if (lockTaken)
          {
            // Set the circuit breaker state to HalfOpen.
            stateStore.HalfOpen();

            // Attempt the operation.
            action();

            // If this action succeeds, reset the state and allow other operations.
            // In reality, instead of immediately returning to the Closed state, a counter
            // here would record the number of successful operations and return the
            // circuit breaker to the Closed state only after a specified number succeed.
            this.stateStore.Reset();
            return;
          }
        }
        catch (Exception ex)
        {
          // If there's still an exception, trip the breaker again immediately.
          this.stateStore.Trip(ex);

          // Throw the exception so that the caller knows which exception occurred.
          throw;
        }
        finally
        {
          if (lockTaken)
          {
            Monitor.Exit(halfOpenSyncObject);
          }
        }
      }
      // The Open timeout hasn't yet expired. Throw a CircuitBreakerOpen exception to
      // inform the caller that the call was not actually attempted,
      // and return the most recent exception received.
      throw new CircuitBreakerOpenException(stateStore.LastException);
    }
    ...


```

برای استفاده از یک شی `CircuitBreaker` برای محافظت از یک عملیات، یک برنامه یک نمونه (instance) از کلاس `CircuitBreaker` ایجاد می‌کند و متد `ExecuteAction` را فراخوانی می‌کند و عملیاتی را که باید به عنوان پارامتر انجام شود را مشخص می‌کند. اگر عملیات به دلیل باز بودن `CircuitBreaker` شکست خورد، برنامه باید آماده باشد تا exception `CircuitBreakerOpenException` را بگیرد. کد زیر یک مثال را نشان می‌دهد:

```csharp
var breaker = new CircuitBreaker();

try
{
  breaker.ExecuteAction(() =>
  {
    // Operation protected by the circuit breaker.
    ...
  });
}
catch (CircuitBreakerOpenException ex)
{
  // Perform some different action when the breaker is open.
  // Last exception details are in the inner exception.
  ...
}
catch (Exception ex)
{
  ...
}
```


## منابع مرتبط

الگو‌های زیر نیز ممکن است هنگام اجرای این الگو مفید باشند:

*‏ الگوی [Reliable web app](https://learn.microsoft.com/en-us/azure/architecture/web-apps/guides/reliable-web-app/overview)  به شما نشان می‌دهد که چگونه الگوی قطع کننده مدار را برای برنامه‌ها و اپلیکیشن‌‌های تحت وب که مناسب اجرا روی محیط ابری هستند را اعمال کنید.

*‏ الگوی [Retry](./Retry%20pattern.md) توضیح می‌دهد که چگونه یک برنامه  می‌تواند با خرابی‌‌های موقت پیش‌بینی‌شده زمانی که سعی می‌کند به یک سرویس یا منبع شبکه وصل شود، با اجرای مجدد عملیاتی که قبلاً شکست خورده است، مقابله کند.

*‏ الگوی [Health Endpoint Monitoring](./Health%20Endpoint%20Monitoring%20pattern.md) یک  قطع کننده مدار ممکن است بتواند سلامت یک سرویس را با ارسال یک درخواست به endpoint ‌ای که توسط یک سرویس expose شده است را آزمایش کند. سرویس باید اطلاعاتی را که وضعیت آن را نشان می‌دهد را برگرداند.