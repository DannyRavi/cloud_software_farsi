درخواست‌های ارسال شده به سرویس‌ها را اولویت‌بندی کنید تا درخواست‌های دارای اولویت بالاتر سریع‌تر از درخواست‌هایی با اولویت پایین‌تر دریافت و پردازش شوند. این الگو در برنامه هایی مفید است که ضمانت های سطح سرویس متفاوتی را به مشتریان منحصر بفرد ارائه می دهند.

### **طرح صورت مسئله:**

برنامه‌ها می‌توانند وظایف خاصی را به سرویس‌های دیگر واگذار کنند، به عنوان مثال؛ برای انجام پردازش پس‌زمینه یا ادغام با سایر برنامه‌ها یا سرویس‌های دیگر در  محیط ابری از یک message queue معمولاً برای واگذاری تسک‌ها به پردازش پس‌زمینه استفاده می‌شود. در بسیاری از موارد، ترتیب دریافت درخواست‌ها توسط یک سرویس مهم نیست. با این حال، در برخی موارد، اولویت بندی درخواست های خاص ضروری است. این درخواست‌ها باید زودتر از درخواست‌های با اولویت پایین‌تر که قبلاً توسط برنامه ارسال شده‌اند، پردازش شوند.

## راه حل

یک صف معمولاً یک ساختار (first-in, first-out (FIFO است و مصرف کنندگان معمولاً پیام ها را به همان ترتیبی که در صف ارسال می شوند دریافت می کنند. با این حال، برخی از message queue ها از پیام رسانی اولویت دار پشتیبانی می کنند. برنامه‌ای که پیامی را ارسال می‌کند می‌تواند اولویتی را تعیین کند. پیام‌های موجود در صف به‌طور خودکار مرتب می‌شوند تا پیام‌هایی که اولویت بالاتری دارند قبل از پیام‌هایی که اولویت کمتری دارند دریافت شوند. این نمودار روند این کار را نشان می دهد:

![[Pasted image 20231205112924.png]]

```
توجه داشته باشید  
  
اکثر پیاده سازی های message queueها از چندین مصرف کننده(consumer) پشتیبانی می کنند. (به الگوی مصرف کنندگان رقیب  [Competing Consumers pattern](https://learn.microsoft.com/en-us/azure/architecture/patterns/competing-consumers)  مراجعه کنید.) تعداد فرآیندهای مصرف کننده را می توان بر اساس تقاضا کم و زیاد کرد.
```


در سیستم‌هایی که از message queue مبتنی بر اولویت پشتیبانی نمی‌کنند، یک راه‌حل جایگزین حفظ یک صف جداگانه برای هر اولویت است. برنامه وظیفه ارسال پیام ها به صف مناسب را بر عهده دارد. هر صف می تواند یک مجموعه جداگانه از مصرف کنندگان داشته باشد. صف‌های با اولویت بالاتر می‌توانند تعداد بیشتری از مصرف‌کنندگان(consumers) داشته باشند که با سخت‌افزار سریع‌تر از صف‌های با اولویت پایین‌تر کار می‌کنند. این نمودار استفاده از message queueهای جداگانه برای هر اولویت را نشان می دهد:

![[Pasted image 20231205112950.png]]
 
 یک تغییر در این استراتژی، پیاده‌سازی یک مجموعه واحد از مصرف‌کنندگان است که ابتدا پیام‌ها را در صف‌های اولویت بالا بررسی می‌کنند و تنها پس از بررسی مربوط به پیام‌هایی با اولویت‌ بالا، شروع به واکشی پیام‌ها از صف‌های با اولویت پایین‌تر می‌کنند. تفاوت‌های معنایی بین راه‌حلی که از یک مجموعه واحد از فرآیندهای مصرف‌کننده استفاده می‌کند (یا با یک صف که از پیام‌هایی با اولویت‌های متفاوت پشتیبانی می‌کند یا با صف‌های متعدد که هر کدام پیام‌های با اولویت واحد را مدیریت می‌کنند) و راه‌حلی که از چندین صف استفاده می‌کند وجود دارد. معمولا این کار با یک مجموعه (pool) مجزا برای هر صف ممکن است.  

در رویکرد single-pool، پیام‌های با اولویت بالاتر همیشه قبل از پیام‌های با اولویت پایین‌تر دریافت و پردازش می‌شوند. در تئوری، پیام های با اولویت پایین می توانند به طور مداوم جایگزین شوند و ممکن است هرگز پردازش نشوند. در رویکرد multiple pool، پیام‌های با اولویت پایین‌تر همیشه پردازش می‌شوند، اما نه به سرعت پیام‌های با اولویت بالاتر (بسته به اندازه نسبی مجموعه‌ها(pools) و منابع موجود برای آنها).  
  
استفاده از مکانیزم صف بندی اولویت ( priority-queuing) می تواند مزایای زیر را به همراه داشته باشد:

* این به برنامه‌ها اجازه می‌دهد تا نیازمندی‌های تجاری که نیازمند اولویت‌بندی availability یا performance هستند را برآورده کنند، مانند ارائه سطوح خدمات مختلف به گروه‌های مختلف مشتریان. 
  
* اگر از روش single-queue استفاده می کنید احتمالا می تواند به کاهش هزینه های عملیاتی کمک کند. می توانید در صورت نیاز تعداد مصرف کنندگان را کاهش دهید. پیام‌های با اولویت بالا همچنان ابتدا پردازش می‌شوند (اگرچه احتمالاً آهسته‌تر) و پیام‌های با اولویت پایین‌تر ممکن است برای مدت بیشتری به تأخیر بیفتند. اگر رویکرد multiple message queue را با مجموعه‌های جداگانه مصرف‌کننده برای هر صف پیاده‌سازی کنید، می‌توانید تعداد مصرف‌کنندگان را برای صف‌های با اولویت پایین‌تر کاهش دهید. حتی می‌توانید پردازش برخی از صف‌های با اولویت بسیار پایین را با متوقف کردن تمام مصرف‌کنندگانی که در آن صف‌ها به پیام‌ها گوش می‌دهند، متوقف کنید.  
  
* رویکرد multiple message queue می‌تواند با پارتیشن‌بندی پیام‌ها بر اساس نیازهای پردازش، به حداکثر کردن performance و scalability برنامه کمک کند. به عنوان مثال، می‌توانید تسک‌های حیاتی را اولویت‌بندی کنید تا توسط گیرنده‌هایی که بلافاصله اجرا می‌شوند  انجام شوند و تسک‌های کم اهمیت پس‌زمینه توسط گیرنده‌هایی که قرار است در زمان‌هایی که شلوغی کمتری دارند اجرا شوند.





## ملاحظات

هنگام تصمیم گیری در مورد نحوه اجرای این الگو به نکات زیر توجه کنید:  
  
* اولویت ها را در چارچوب راه حل‌ها تعریف کنید. به عنوان مثال، یک پیام با اولویت بالا می تواند به عنوان پیامی تعریف شود که باید در عرض 10 ثانیه پردازش شود. الزامات مربوط به رسیدگی به موارد با اولویت بالا و منابعی را که باید برای برآورده کردن معیارهای شما تخصیص داده شود، شناسایی کنید.  
  
* تصمیم بگیرید که آیا همه موارد با اولویت بالا باید قبل از هر مورد با اولویت پایین تر پردازش شوند یا خیر. اگر پیام‌ها توسط یک مجموعه از مصرف‌کنندگان پردازش می‌شوند، باید مکانیزمی ارائه کنید که می‌تواند تسکی را که در حال مدیریت یک پیام با اولویت پایین است، در صورتی که پیامی با اولویت بالاتر وارد صف شود، از پیش گرفته و به حالت تعلیق درآورد.  
  
* در رویکرد multiple queue، هنگامی که  یک single pool از فرآیندهای مصرف کننده استفاده می کنید که به جای یک مجموعه اختصاصی مصرف کننده برای هر صف، به همه صف ها گوش می دهند در نتیجه مصرف کننده باید الگوریتمی را اعمال کند که تضمین کند همیشه پیام ها را از صف های اولویت بالاتر قبل از پیام های صف های با اولویت پایین تر ارائه می دهد.
  
* سرعت پردازش را در صف‌های با اولویت بالا و پایین کنترل کنید تا مطمئن شوید که پیام‌های موجود در آن صف‌ها با نرخ‌های مورد انتظار پردازش می‌شوند.  
  
* اگر می‌خواهید تضمین کنید که پیام‌های با اولویت پایین پردازش می‌شوند، رویکرد multiple message queue را با مجموعه‌های (pools) متعدد مصرف‌کننده اجرا کنید. از طرف دیگر، در صفی که از اولویت بندی پیام پشتیبانی می کند، می توانید به صورت پویا اولویت یک پیام در صف را با بالا رفتن طول عمر آن افزایش دهید. با این حال، این رویکرد به صف پیام ارائه کننده (provider) این ویژگی بستگی دارد.  
  
* استراتژی استفاده از صف های جداگانه بر اساس اولویت پیام برای سیستم هایی توصیه می شود که دارای چند اولویت کاملاً مشخص هستند.  
  
* سیستم می تواند به طور منطقی اولویت های پیام را تعیین کند. برای مثال، به جای داشتن پیام‌های صریح با اولویت بالا و پایین، می‌توانید پیام‌ها را به‌عنوان «paying customer» یا «non-paying customer» تعیین کنید. سپس سیستم شما می تواند منابع بیشتری را به پردازش پیام های مشتریان پرداخت کننده (paying customers) اختصاص دهد.  
  
* ممکن است هزینه‌های مالی و پردازشی مربوط به بررسی یک صف برای یک پیام باشد. به عنوان مثال، برخی از سیستم‌های پیام‌رسان تجاری هر بار که پیامی پست یا بازیابی می‌شود هزینه کمی دریافت می‌کنند و هر بار که یک صف برای پیام‌ها درخواست می‌شود این هزینه‌ی زمانی افزایش می یابد در حالتی که چندین صف را بررسی کنید.  
  
* شما می توانید به صورت پویا اندازه یک مجموعه(pool) از مصرف کنندگان را بر اساس طول صفی که pool در حال سرویس دهی است تنظیم کنید برای اطلاعات بیشتر به  [Autoscaling guidance](https://learn.microsoft.com/en-us/previous-versions/msp-n-p/dn589774(v=pandp.10)) مراجعه کنید.

### چه زمانی از این الگو استفاده کنیم؟

این الگو در سناریوهایی مفید است که:  
  
* سیستم باید تسک‌های متعددی را انجام دهد که اولویت های متفاوتی دارند.  
  
* به کاربران یا مستاجران(tenants) مختلف باید با اولویت های متفاوتی سرویس دهی شود.

## مثال

سرویس ابری Azure مکانیزم صف بندی ای را که به طور بومی(native) از اولویت بندی خودکار پیام ها   پشتیبانی کند را ارائه نمی دهد . با این حال، موضوعات Azure Service Bus، اشتراک‌های Service Bus را ارائه می‌کند که از مکانیزم صف‌بندی پشتیبانی می‌کند که حتی امکان فیلتر کردن پیام را فراهم می‌کند و دارای طیف وسیعی از قابلیت‌های انعطاف‌پذیر است که Azure را برای اکثر پیاده‌سازی‌های صف اولویت ایده‌آل می‌کند.  
  
یک راه‌حل Azure پیاده‌سازی یک Service Bus topic است که یک برنامه می‌تواند پیام‌ها را به آن ارسال کند درست همانطور که در یک صف ارسال می‌کند. پیام‌ها می‌توانند حاوی metadataها به شکل ویژگی‌های سفارشی تعریف‌شده توسط برنامه باشند. می‌توانید اشتراک‌های Service Bus را با موضوع مرتبط کنید و اشتراک‌ها(subscriptions) می‌توانند پیام‌ها را بر اساس ویژگی‌هایشان فیلتر کنند. هنگامی که یک برنامه  پیامی را به topic ارسال می کند پیام به اشتراک(subscription) مناسب هدایت می شود، جایی که مصرف کننده می تواند آن را بخواند. فرآیندهای مصرف کننده می توانند پیام ها را از یک اشتراک با استفاده از همان معنایی که در صف پیام استفاده می کنند، بازیابی کنند. ( در واقع اشتراک یک  صف منطقی  است). این نمودار نحوه اجرای یک صف اولویت را با استفاده از موضوعات و اشتراک های سرویس اتوبوس نشان می دهد:

![[Pasted image 20231205113150.png]]

در نمودار قبلی، برنامه چندین پیام ایجاد می کند و یک ویژگی سفارشی به نام اولویت را در هر پیام اختصاص می دهد. اولویت دارای مقدار High یا Low است. برنامه این پیام ها را به یک topic ارسال می کند. موضوع دارای دو اشتراک مرتبط است که پیام ها را بر اساس ویژگی اولویتی فیلتر می کند. یک اشتراک پیام هایی را می پذیرد که ویژگی  اولویت (Priority) روی High تنظیم شده است. دیگری پیام هایی را با ویژگی اولویتی روی Low می پذیرد. مجموعه ای از مصرف کنندگان پیام های هر اشتراک را می خوانند. اشتراک با اولویت بالا دارای یک مجموعه بزرگتر است و این مصرف کنندگان ممکن است روی رایانه های قدرتمندتری که منابع در دسترس بیشتری نسبت به رایانه های دارای اولویت پایین دارند به خوبی کار کنند.  
  
هیچ چیز خاصی در مورد تعیین پیام های با اولویت بالا و پایین در این مثال وجود ندارد. آنها صرفاً برچسب هایی هستند که در هر پیام به عنوان ویژگی خاص مشخص می شوند. آنها برای هدایت پیام ها به یک اشتراک خاص استفاده می شوند. در صورت نیاز به اولویت‌های اضافی، ایجاد اشتراک‌ها و مجموعه‌های بیشتری از پردازشگر مصرف‌کننده برای رسیدگی به این اولویت‌ها نسبتاً آسان است.  
  
راه حل PriorityQueue در [GitHub](https://github.com/mspnp/cloud-design-patterns/tree/master/priority-queue) بر اساس این رویکرد است. این راه حل شامل پروژه های Azure Function با نام های `PriorityQueueConsumerHigh` و `PriorityQueueConsumerLow` می باشد. این پروژه های Azure Function از طریق تریگرها و اتصالات با Service Bus یکپارچه می شوند. آنها به اشتراک های مختلفی که در `ServiceBusTrigger` تعریف شده اند متصل می شوند و به پیام های دریافتی واکنش نشان می دهند.

```csharp
public static class PriorityQueueConsumerHighFn
{
    [FunctionName("HighPriorityQueueConsumerFunction")]
    public static void Run(
      [ServiceBusTrigger("messages", "highPriority", Connection = "ServiceBusConnection")]string highPriorityMessage,
      ILogger log)
    {
        log.LogInformation($"C# ServiceBus topic trigger function processed message: {highPriorityMessage}");
    }
}
```

به‌عنوان administrator، می‌توانید  توابع مربوط Azure App Service را پیکربندی کنید که به چند نمونه می‌توانند مقیاس شوند. شما می توانید این کار را با پیکربندی گزینه Enforce Scale Out Limit از پورتال Azure انجام دهید و حداکثر محدودیت مقیاس را برای هر عملکرد تعیین کنید. شما معمولاً باید نمونه های بیشتری از تابع PriorityQueueConsumerHigh نسبت به تابع PriorityQueueConsumerLow داشته باشید. این پیکربندی تضمین می‌کند که پیام‌های با اولویت بالا سریع‌تر از پیام‌های با اولویت پایین خوانده می‌شوند.  
  
پروژه دیگری، `PriorityQueueSender`، حاوی یک تابع Azure با زمان راه اندازی است که برای اجرا هر 30 ثانیه پیکربندی شده است. این تابع از طریق اتصال خروجی با Service Bus ادغام می شود و دسته ای از پیام های با اولویت پایین و بالا را به یک شی `IAsyncCollector` ارسال می کند. وقتی تابع پیام‌هایی را به موضوعی ارسال می‌کند که با اشتراک‌های استفاده شده توسط توابع `PriorityQueueConsumerHigh` و `PriorityQueueConsumerLow` مرتبط است، اولویت را با استفاده از ویژگی سفارشی اولویت مشخص می‌کند، همانطور که در اینجا نشان داده شده است:

```csharp
public static class PriorityQueueSenderFn
{
    [FunctionName("PriorityQueueSenderFunction")]
    public static async Task Run(
        [TimerTrigger("0,30 * * * * *")] TimerInfo myTimer,
        [ServiceBus("messages", Connection = "ServiceBusConnection")] IAsyncCollector<ServiceBusMessage> collector)
    {
        for (int i = 0; i < 10; i++)
        {
            var messageId = Guid.NewGuid().ToString();
            var lpMessage = new ServiceBusMessage() { MessageId = messageId };
            lpMessage.ApplicationProperties["Priority"] = Priority.Low;
            lpMessage.Body = BinaryData.FromString($"Low priority message with Id: {messageId}");
            await collector.AddAsync(lpMessage);

            messageId = Guid.NewGuid().ToString();
            var hpMessage = new ServiceBusMessage() { MessageId = messageId };
            hpMessage.ApplicationProperties["Priority"] = Priority.High;
            hpMessage.Body = BinaryData.FromString($"High priority message with Id: {messageId}");
            await collector.AddAsync(hpMessage);
        }
    }
}
```


## قدم بعدی

منابع زیر ممکن است هنگام اجرای این الگو برای شما مفید باشد:  
  
* نمونه ای که این الگو را در [GitHub](https://github.com/mspnp/cloud-design-patterns/tree/master/priority-queue) نشان می دهد.  
  
* [Asynchronous messaging primer](https://learn.microsoft.com/en-us/previous-versions/msp-n-p/dn589781(v=pandp.10)). یک سرویس مصرف کننده که یک درخواست را پردازش می کند، ممکن است نیاز به ارسال پاسخ به نمونه برنامه ای که درخواست را ارسال کرده است داشته باشد. این مقاله اطلاعاتی در مورد استراتژی هایی ارائه می دهد که می توانید برای اجرای پیام request/response استفاده کنید.  
  
* [Autoscaling guidance](https://learn.microsoft.com/en-us/previous-versions/msp-n-p/dn589774(v=pandp.10)). گاهی اوقات می‌توانید اندازه مجموعه‌ی فرآیندهای مصرف‌کننده‌ای را که یک صف را مدیریت می‌کنند، بر اساس طول صف تغییر دهید. این استراتژی می تواند به شما در بهبود کارایی کمک کند به خصوص برای مجموعه‌هایی که پیام های دارای اولویت بالا را مدیریت می کنند.

## منابع مرتبط

الگوهای زیر ممکن است هنگام اجرای این الگو برای شما مفید باشد:  
  
* الگوی مصرف کنندگان رقابتی([Competing Consumers pattern](https://learn.microsoft.com/en-us/azure/architecture/patterns/competing-consumers)) برای افزایش توان عملیاتی صف ها، می توانید چندین مصرف کننده را پیاده سازی کنید که به یک صف گوش می دهند و وظایف را به صورت موازی پردازش می کنند. این مصرف کنندگان برای پیام ها با هم رقابت می کنند، اما فقط یک نفر باید بتواند هر پیام را پردازش کند. این مقاله اطلاعات بیشتری در مورد مزایا و معایب اجرای این روش ارائه می دهد.  
  
* الگوی [Throttling](https://learn.microsoft.com/en-us/azure/architecture/patterns/throttling). شما می توانید throttling را با استفاده از صف اجرا کنید. می‌توانید از پیام‌های اولویت‌دار برای اطمینان از اینکه درخواست‌های برنامه‌های مهم یا برنامه‌هایی که توسط مشتریان با ارزش (high-value) اجرا می‌شوند، نسبت به درخواست‌های برنامه‌های کم اهمیت اولویت دارند استفاده کنید.