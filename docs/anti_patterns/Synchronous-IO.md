
---

### **ضدالگوی ورودی/خروجی همگام (Synchronous I/O)**

مسدود کردن نخ (thread) فراخواننده تا زمان تکمیل عملیات ورودی/خروجی، می‌تواند عملکرد را کاهش داده و بر مقیاس‌پذیری عمودی (vertical scalability) تأثیر منفی بگذارد.

#### **شرح مشکل**

یک عملیات ورودی/خروجی همگام، نخ فراخواننده را تا زمان تکمیل عملیات مسدود می‌کند. نخ فراخواننده در این فاصله زمانی وارد حالت انتظار (wait state) شده و قادر به انجام کار مفیدی نیست، که این امر موجب هدر رفتن منابع پردازشی می‌شود.

نمونه‌های رایج ورودی/خروجی عبارتند از:
*   بازیابی یا ذخیره‌سازی داده در پایگاه داده یا هر نوع حافظه پایدار (persistent storage).
*   ارسال درخواست به یک وب‌سرویس.
*   ارسال یا دریافت پیام از یک صف (queue).
*   نوشتن یا خواندن از یک فایل محلی.

این ضدالگو معمولاً به دلایل زیر رخ می‌دهد:
*   به نظر می‌رسد که این روش، شهودی‌ترین راه برای انجام یک عملیات است.
*   اپلیکیشن به پاسخی از یک درخواست نیاز دارد.
*   اپلیکیشن از کتابخانه‌ای استفاده می‌کند که فقط متدهای همگام برای ورودی/خروجی ارائه می‌دهد.
*   یک کتابخانه خارجی به صورت داخلی عملیات ورودی/خروجی همگام انجام می‌دهد. یک فراخوانی ورودی/خروجی همگام می‌تواند کل زنجیره فراخوانی (call chain) را مسدود کند.

کد زیر یک فایل را در حافظه blob استوریج Azure آپلود می‌کند. در دو نقطه، کد منتظر ورودی/خروجی همگام می‌ماند: متد `CreateIfNotExists` و متد `UploadFromStream`.

در اینجا مثالی از انتظار برای پاسخ از یک سرویس خارجی آورده شده است. متد `GetUserProfile` یک سرویس راه دور را فراخوانی می‌کند که یک `UserProfile` را برمی‌گرداند.

#### **چگونه مشکل را برطرف کنیم؟**

عملیات ورودی/خروجی همگام را با عملیات ناهمگام (asynchronous) جایگزین کنید. این کار، نخ فعلی را آزاد می‌کند تا به جای مسدود شدن، به انجام کارهای معنادار ادامه دهد و به بهبود بهره‌وری از منابع محاسباتی کمک می‌کند. انجام ورودی/خروجی به صورت ناهمگام به ویژه برای مدیریت افزایش ناگهانی درخواست‌ها از اپلیکیشن‌های کلاینت کارآمد است.

بسیاری از کتابخانه‌ها نسخه‌های همگام و ناهمگام متدها را ارائه می‌دهند. هر زمان که ممکن است، از نسخه‌های ناهمگام استفاده کنید. در زیر نسخه ناهمگام مثال قبلی که یک فایل را به Azure blob storage آپلود می‌کند، آورده شده است.

عملگر `await` کنترل را به محیط فراخواننده بازمی‌گرداند در حالی که عملیات ناهمگام در حال انجام است. کدی که پس از این دستور می‌آید، به عنوان یک ادامه (continuation) عمل می‌کند که پس از تکمیل عملیات ناهمگام اجرا می‌شود.

یک سرویس خوب طراحی‌شده نیز باید عملیات ناهمگام ارائه دهد. در زیر نسخه ناهمگام وب‌سرویسی که پروفایل‌های کاربری را برمی‌گرداند، آورده شده است. متد `GetUserProfileAsync` به وجود نسخه ناهمگامی از سرویس User Profile وابسته است.

برای کتابخانه‌هایی که نسخه‌های ناهمگام عملیات را ارائه نمی‌دهند، ممکن است بتوان پوشش‌های ناهمگام (asynchronous wrappers) در اطراف متدهای همگام منتخب ایجاد کرد. این رویکرد را با احتیاط دنبال کنید. اگرچه این کار ممکن است پاسخ‌دهی (responsiveness) را در نخی که پوشش ناهمگام را فراخوانی می‌کند، بهبود بخشد، اما در واقع منابع بیشتری مصرف می‌کند. ممکن است یک نخ اضافی ایجاد شود و سرباری برای همگام‌سازی کار انجام‌شده توسط این نخ وجود خواهد داشت. برخی از بده‌بستان‌ها (tradeoffs) در این پست وبلاگ مورد بحث قرار گرفته‌اند: «آیا باید برای متدهای همگام، پوشش‌های ناهمگام ارائه دهم؟»

در اینجا مثالی از یک پوشش ناهمگام برای یک متد همگام آورده شده است.

#### **ملاحظات**
*   عملیات ورودی/خروجی که انتظار می‌رود بسیار کوتاه‌مدت باشند و احتمالاً باعث رقابت (contention) نشوند، ممکن است به عنوان عملیات همگام عملکرد بهتری داشته باشند. مثالی از این موارد می‌تواند خواندن فایل‌های کوچک از یک درایو حالت جامد (SSD) باشد. سربار ارسال یک وظیفه به یک نخ دیگر و همگام‌سازی با آن نخ پس از تکمیل وظیفه، ممکن است از مزایای ورودی/خروجی ناهمگام بیشتر باشد. با این حال، این موارد نسبتاً نادر هستند و بیشتر عملیات ورودی/خروجی باید به صورت ناهمگام انجام شوند.
*   بهبود عملکرد ورودی/خروجی ممکن است باعث شود بخش‌های دیگر سیستم به گلوگاه (bottleneck) تبدیل شوند. برای مثال، آزاد کردن نخ‌ها ممکن است منجر به حجم بالاتری از درخواست‌های همزمان به منابع مشترک شود که به نوبه خود منجر به قحطی منابع (resource starvation) یا محدودسازی (throttling) می‌شود. اگر این موضوع به یک مشکل تبدیل شود، ممکن است نیاز به ارتقای افقی (scale out) تعداد وب‌سرورها یا پارتیشن‌بندی انبارهای داده برای کاهش رقابت داشته باشید.

#### **چگونه مشکل را شناسایی کنیم؟**
برای کاربران، اپلیکیشن ممکن است به صورت دوره‌ای غیرپاسخگو (unresponsive) به نظر برسد. اپلیکیشن ممکن است با استثناهای اتمام زمان مجاز (timeout exceptions) از کار بیفتد. این شکست‌ها همچنین می‌توانند خطاهای HTTP 500 (Internal Server) را برگردانند. در سرور، درخواست‌های ورودی کلاینت ممکن است تا زمانی که یک نخ در دسترس قرار گیرد، مسدود شوند که منجر به طولانی شدن بیش از حد صف درخواست‌ها (request queue) می‌شود و به صورت خطاهای HTTP 503 (Service Unavailable) ظاهر می‌شود.

برای شناسایی مشکل می‌توانید مراحل زیر را انجام دهید:
1.  سیستم در حال کار (production) را نظارت کرده و تعیین کنید که آیا نخ‌های کاری مسدود شده، توان عملیاتی (throughput) را محدود می‌کنند یا خیر.
2.  اگر درخواست‌ها به دلیل کمبود نخ مسدود می‌شوند، اپلیکیشن را بازبینی کنید تا مشخص شود کدام عملیات‌ها ممکن است ورودی/خروجی را به صورت همگام انجام دهند.
3.  برای هر عملیاتی که ورودی/خروجی همگام انجام می‌دهد، تست بار کنترل‌شده انجام دهید تا مشخص شود آیا آن عملیات‌ها بر عملکرد سیستم تأثیر می‌گذارند یا خیر.

#### **مثال تشخیصی**
بخش‌های زیر این مراحل را برای اپلیکیشن نمونه‌ای که قبلاً شرح داده شد، به کار می‌گیرند.

##### **نظارت بر عملکرد وب‌سرور**
برای اپلیکیشن‌های وب و وب‌رول‌های Azure، نظارت بر عملکرد وب‌سرور Internet Information Services (IIS) ارزشمند است. به طور خاص، به طول صف درخواست‌ها توجه ویژه‌ای داشته باشید تا مشخص شود آیا درخواست‌ها در دوره‌های فعالیت بالا منتظر نخ‌های در دسترس می‌مانند یا خیر. می‌توانید این اطلاعات را با فعال کردن Azure Diagnostics جمع‌آوری کنید.

##### **ابزار دقیق‌سنجی اپلیکیشن**
اپلیکیشن را ابزار دقیق‌سنجی (instrument) کنید تا ببینید درخواست‌ها پس از پذیرفته شدن چگونه مدیریت می‌شوند. ردیابی جریان یک درخواست می‌تواند به شناسایی اینکه آیا در حال انجام فراخوانی‌های کند و مسدود کردن نخ فعلی است، کمک کند. پروفایلینگ نخ‌ها نیز می‌تواند درخواست‌هایی را که مسدود می‌شوند، برجسته کند.

##### **تست بار اپلیکیشن**
نمودار زیر عملکرد متد همگام `GetUserProfile` را که قبلاً نشان داده شد، تحت بارهای مختلف تا ۴۰۰۰ کاربر همزمان نشان می‌دهد. اپلیکیشن یک برنامه ASP.NET است که در یک وب‌رول Azure Cloud Service اجرا می‌شود.

[نمودار ۱]

---

عملیات همگام به گونه‌ای کدنویسی شده که برای شبیه‌سازی ورودی/خروجی همگام، ۲ ثانیه متوقف (sleep) شود، بنابراین حداقل زمان پاسخ‌دهی کمی بیشتر از ۲ ثانیه است. زمانی که بار به حدود ۲۵۰۰ کاربر همزمان می‌رسد، میانگین زمان پاسخ‌دهی به یک سطح ثابت می‌رسد، اگرچه حجم درخواست‌ها در ثانیه همچنان افزایش می‌یابد. توجه داشته باشید که مقیاس این دو معیار لگاریتمی است. تعداد درخواست‌ها در ثانیه بین این نقطه و پایان تست دو برابر می‌شود.

به تنهایی، از این تست لزوماً مشخص نیست که آیا ورودی/خروجی همگام یک مشکل است یا خیر. تحت بار سنگین‌تر، اپلیکیشن ممکن است به یک نقطه بحرانی (tipping point) برسد که در آن وب‌سرور دیگر نتواند درخواست‌ها را به موقع پردازش کند و باعث شود اپلیکیشن‌های کلاینت استثناهای اتمام زمان مجاز دریافت کنند.

درخواست‌های ورودی توسط وب‌سرور IIS در صف قرار گرفته و به یک نخ در حال اجرا در استخر نخ ASP.NET تحویل داده می‌شوند. از آنجا که هر عملیات ورودی/خروجی را به صورت همگام انجام می‌دهد، نخ تا زمان تکمیل عملیات مسدود می‌شود. با افزایش بار کاری، در نهایت تمام نخ‌های ASP.NET در استخر نخ تخصیص داده شده و مسدود می‌شوند. در آن نقطه، هر درخواست ورودی دیگری باید در صف منتظر یک نخ در دسترس بماند. با افزایش طول صف، درخواست‌ها شروع به اتمام زمان مجاز می‌کنند.

##### **پیاده‌سازی راه‌حل و تأیید نتیجه**
نمودار بعدی نتایج تست بار نسخه ناهمگام کد را نشان می‌دهد.

[نمودار ۲]

---

توان عملیاتی بسیار بالاتر است. در همان مدت زمان تست قبلی، سیستم با موفقیت افزایشی تقریباً ده برابری در توان عملیاتی (که بر اساس درخواست در ثانیه اندازه‌گیری می‌شود) را مدیریت می‌کند. علاوه بر این، میانگین زمان پاسخ‌دهی نسبتاً ثابت است و تقریباً ۲۵ برابر کمتر از تست قبلی باقی می‌ماند.
