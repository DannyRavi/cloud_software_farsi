

---

### **ضدالگوی طوفان تلاش مجدد (Retry Storm)**

زمانی که یک سرویس در دسترس نیست یا مشغول است، تلاش مجدد بیش از حد مکرر کلاینت‌ها برای اتصال، می‌تواند بازیابی سرویس را با مشکل مواجه کرده و حتی مشکل را بدتر کند. همچنین، تلاش مجدد برای همیشه منطقی نیست، زیرا درخواست‌ها معمولاً فقط برای یک دوره زمانی مشخص معتبر هستند.

#### **شرح مشکل**

در محیط ابر، سرویس‌ها گاهی با مشکل مواجه شده و برای کلاینت‌ها غیرقابل دسترس می‌شوند یا مجبور به محدودسازی (throttling یا rate limiting) کلاینت‌های خود می‌شوند. اگرچه تلاش مجدد کلاینت‌ها برای اتصالات ناموفق به سرویس‌ها یک رویه خوب است، اما مهم است که این کار را بیش از حد مکرر یا برای مدت طولانی انجام ندهند. تلاش‌های مجدد در یک بازه زمانی کوتاه به احتمال زیاد موفقیت‌آمیز نخواهند بود، زیرا سرویس‌ها احتمالاً هنوز بازیابی نشده‌اند. علاوه بر این، زمانی که سرویس‌ها در حال تلاش برای بازیابی هستند، ارسال تعداد زیادی درخواست اتصال می‌تواند فشار بیشتری به آنها وارد کند و تلاش‌های مکرر حتی ممکن است سرویس را از پای درآورده و مشکل اصلی را تشدید کند.

مثال زیر سناریویی را نشان می‌دهد که در آن یک کلاینت به یک API مبتنی بر سرور متصل می‌شود. اگر درخواست موفقیت‌آمیز نباشد، کلاینت بلافاصله دوباره تلاش می‌کند و این کار را برای همیشه ادامه می‌دهد. اغلب، این نوع رفتار ظریف‌تر از این مثال است، اما اصل یکسانی بر آن حاکم است.

#### **چگونه مشکل را برطرف کنیم؟**

اپلیکیشن‌های کلاینت باید برای جلوگیری از ایجاد «طوفان تلاش مجدد»، برخی از بهترین شیوه‌ها را دنبال کنند.

*   **تعداد تلاش‌های مجدد را محدود کنید** و برای مدت طولانی به تلاش ادامه ندهید. اگرچه نوشتن یک حلقه `while(true)` ممکن است آسان به نظر برسد، اما تقریباً به طور قطع شما نمی‌خواهید برای مدت طولانی تلاش مجدد کنید، زیرا شرایطی که منجر به شروع درخواست شده، احتمالاً تغییر کرده است. در اکثر اپلیکیشن‌ها، تلاش مجدد برای چند ثانیه یا چند دقیقه کافی است.
*   **بین تلاش‌های مجدد وقفه ایجاد کنید.** اگر یک سرویس در دسترس نیست، تلاش مجدد فوری به احتمال زیاد موفقیت‌آمیز نخواهد بود. به تدریج مدت زمانی را که بین تلاش‌ها منتظر می‌مانید، افزایش دهید، برای مثال با استفاده از یک استراتژی عقب‌نشینی نمایی (exponential backoff).
*   **خطاها را به‌درستی مدیریت کنید.** اگر سرویس پاسخ نمی‌دهد، در نظر بگیرید که آیا منطقی است که تلاش را متوقف کرده و یک خطا به کاربر یا فراخواننده مؤلفه خود برگردانید. هنگام طراحی اپلیکیشن خود، این سناریوهای شکست را در نظر بگیرید.
*   **از الگوی Circuit Breaker استفاده کنید** که به طور خاص برای جلوگیری از «طوفان تلاش مجدد» طراحی شده است.
*   اگر سرور هدر پاسخ `retry-after` را ارائه می‌دهد، اطمینان حاصل کنید که تا قبل از اتمام بازه زمانی مشخص‌شده، دوباره تلاش نمی‌کنید.
*   هنگام ارتباط با سرویس‌های Azure از **SDKهای رسمی** استفاده کنید. این SDKها عموماً دارای سیاست‌های تلاش مجدد داخلی و محافظت در برابر ایجاد یا مشارکت در «طوفان تلاش مجدد» هستند. اگر با سرویسی ارتباط برقرار می‌کنید که SDK ندارد یا SDK آن منطق تلاش مجدد را به درستی مدیریت نمی‌کند، از کتابخانه‌ای مانند Polly (برای NET.) یا retry (برای JavaScript) برای مدیریت صحیح منطق تلاش مجدد خود استفاده کنید و از نوشتن کد توسط خودتان خودداری کنید.
*   اگر در محیطی کار می‌کنید که از آن پشتیبانی می‌کند، از یک **سرویس مش (service mesh)** یا لایه انتزاعی دیگری برای ارسال فراخوانی‌های خروجی استفاده کنید. معمولاً این ابزارها، مانند Dapr، از سیاست‌های تلاش مجدد پشتیبانی می‌کنند و به طور خودکار بهترین شیوه‌ها، مانند عقب‌نشینی پس از تلاش‌های مکرر، را دنبال می‌کنند. این رویکرد به این معنی است که نیازی به نوشتن کد تلاش مجدد توسط خودتان ندارید.
*   در صورت امکان، **درخواست‌ها را دسته‌بندی کرده** و از تجمیع درخواست‌ها (request pooling) استفاده کنید. بسیاری از SDKها دسته‌بندی درخواست‌ها و تجمیع اتصالات را برای شما مدیریت می‌کنند که تعداد کل تلاش‌های اتصال خروجی اپلیکیشن شما را کاهش می‌دهد، هرچند هنوز باید مراقب باشید که این اتصالات را بیش از حد مکرر بازآزمایی نکنید.

سرویس‌ها نیز باید از خود در برابر «طوفان تلاش مجدد» محافظت کنند.

*   **یک لایه گیت‌وی (gateway) اضافه کنید** تا بتوانید در حین یک حادثه، اتصالات را قطع کنید. این نمونه‌ای از الگوی Bulkhead است. Azure سرویس‌های گیت‌وی مختلفی برای انواع راه‌حل‌ها ارائه می‌دهد، از جمله Front Door، Application Gateway و API Management.
*   **درخواست‌ها را در گیت‌وی خود محدودسازی (throttle) کنید**، که تضمین می‌کند آنقدر درخواست قبول نخواهید کرد که مؤلفه‌های بک‌اند شما نتوانند به کار خود ادامه دهند.
*   اگر در حال محدودسازی هستید، یک هدر `retry-after` را بازگردانید تا به کلاینت‌ها کمک کنید بفهمند چه زمانی باید دوباره برای اتصال تلاش کنند.

#### **ملاحظات**

*   کلاینت‌ها باید نوع خطای بازگشتی را در نظر بگیرند. برخی از انواع خطاها نشان‌دهنده شکست سرویس نیستند، بلکه نشان می‌دهند که کلاینت یک درخواست نامعتبر ارسال کرده است. برای مثال، اگر یک اپلیکیشن کلاینت پاسخ خطای `400 Bad Request` دریافت کند، تلاش مجدد برای همان درخواست احتمالاً کمکی نخواهد کرد، زیرا سرور به شما می‌گوید که درخواست شما معتبر نیست.
*   کلاینت‌ها باید مدت زمانی را که برای تلاش مجدد منطقی است، در نظر بگیرند. مدت زمانی که باید تلاش مجدد کنید، بستگی به نیازمندی‌های تجاری شما و اینکه آیا می‌توانید به طور منطقی یک خطا را به کاربر یا فراخواننده برگردانید، دارد. در اکثر اپلیکیشن‌ها، تلاش مجدد برای چند ثانیه یا چند دقیقه کافی است.

#### **چگونه مشکل را شناسایی کنیم؟**

از دیدگاه کلاینت، علائم این مشکل می‌تواند شامل زمان پاسخ‌دهی یا پردازش بسیار طولانی، به همراه تله‌متری باشد که نشان‌دهنده تلاش‌های مکرر برای بازآزمایی اتصال است.

از دیدگاه سرویس، علائم این مشکل می‌تواند شامل تعداد زیادی درخواست از یک کلاینت در یک بازه زمانی کوتاه، یا تعداد زیادی درخواست از یک کلاینت در حین بازیابی از قطعی‌ها باشد. علائم همچنین می‌تواند شامل دشواری در بازیابی سرویس، یا شکست‌های زنجیره‌ای (cascading failures) مداوم سرویس درست پس از رفع یک خطا باشد.

#### **مثال تشخیصی**

بخش‌های زیر یک رویکرد برای شناسایی یک «طوفان تلاش مجدد» بالقوه را هم از سمت کلاینت و هم از سمت سرویس نشان می‌دهند.

##### **شناسایی از طریق تله‌متری کلاینت**

Azure Application Insights تله‌متری را از اپلیکیشن‌ها ثبت کرده و داده‌ها را برای کوئری و بصری‌سازی در دسترس قرار می‌دهد. اتصالات خروجی به عنوان وابستگی‌ها (dependencies) ردیابی می‌شوند و می‌توان به اطلاعات آنها دسترسی پیدا کرد و آنها را نموداری کرد تا مشخص شود چه زمانی یک کلاینت تعداد زیادی درخواست خروجی به یک سرویس یکسان ارسال می‌کند.

نمودار زیر از تب Metrics در پورتال Application Insights گرفته شده و متریک *Dependency failures* را به تفکیک *Remote dependency name* نمایش می‌دهد. این نمودار سناریویی را نشان می‌دهد که در آن تعداد زیادی (بیش از ۲۱,۰۰۰) تلاش اتصال ناموفق به یک وابستگی در مدت زمان کوتاهی وجود داشته است.

[نمودار]

---

##### **شناسایی از طریق تله‌متری سرور**

اپلیکیشن‌های سرور ممکن است بتوانند تعداد زیادی اتصال از یک کلاینت واحد را شناسایی کنند. در مثال زیر، Azure Front Door به عنوان یک گیت‌وی برای یک اپلیکیشن عمل می‌کند و برای ثبت تمام درخواست‌ها در یک فضای کاری Log Analytics پیکربندی شده است.

کوئری Kusto زیر را می‌توان در برابر Log Analytics اجرا کرد. این کوئری آدرس‌های IP کلاینت‌هایی را که در روز گذشته تعداد زیادی درخواست به اپلیکیشن ارسال کرده‌اند، شناسایی می‌کند.

[کوئری Kusto]

اجرای این کوئری در حین یک «طوفان تلاش مجدد»، تعداد زیادی تلاش اتصال از یک آدرس IP واحد را نشان می‌دهد.

[نتیجه کوئری]

----

#### **منابع مرتبط**
*   الگوی تلاش مجدد (Retry pattern)
*   الگوی مدارشکن (Circuit Breaker pattern)
*   بهترین شیوه‌های مدیریت خطای گذرا
