
---

### **ضدالگوی عدم استفاده از کش (No Caching)**

ضدالگوها، نقص‌های رایج در طراحی هستند که می‌توانند در شرایط پرفشار (stress situations)، نرم‌افزار یا اپلیکیشن شما را دچار اختلال کنند و نباید نادیده گرفته شوند. ضدالگوی «عدم استفاده از کش» زمانی رخ می‌دهد که یک اپلیکیشن ابری که درخواست‌های همزمان زیادی را مدیریت می‌کند، داده‌های یکسانی را به طور مکرر واکشی کند. این کار می‌تواند عملکرد و مقیاس‌پذیری را کاهش دهد.

زمانی که داده‌ها کش نمی‌شوند، این امر می‌تواند منجر به رفتارهای نامطلوب متعددی شود، از جمله:

*   واکشی مکرر اطلاعات یکسان از منبعی که دسترسی به آن از نظر سربار ورودی/خروجی (I/O overhead) یا تأخیر (latency)، پرهزینه است.
*   ساخت مکرر اشیاء یا ساختارهای داده یکسان برای درخواست‌های متعدد.
*   ایجاد فراخوانی‌های بیش از حد به یک سرویس راه دور که دارای سهمیه (quota) است و کلاینت‌ها را پس از یک حد معین، محدود (throttle) می‌کند.

این مشکلات به نوبه خود می‌توانند منجر به زمان پاسخ‌دهی ضعیف، افزایش رقابت بر سر منابع (contention) در انبار داده و مقیاس‌پذیری ضعیف شوند.

#### **مثال‌هایی از ضدالگوی عدم استفاده از کش**

مثال زیر از Entity Framework برای اتصال به یک پایگاه داده استفاده می‌کند. هر درخواست کلاینت منجر به یک فراخوانی به پایگاه داده می‌شود، حتی اگر چندین درخواست دقیقاً داده‌های یکسانی را واکشی کنند. هزینه درخواست‌های مکرر، از نظر سربار ورودی/خروجی و هزینه‌های دسترسی به داده، می‌تواند به سرعت انباشته شود.

این ضدالگو معمولاً به دلایل زیر رخ می‌دهد:

*   عدم استفاده از کش پیاده‌سازی ساده‌تری دارد و تحت بارهای کم به خوبی کار می‌کند. کشینگ کد را پیچیده‌تر می‌کند.
*   مزایا و معایب استفاده از کش به وضوح درک نشده است.
*   نگرانی در مورد سربار نگهداری دقت و به‌روز بودن داده‌های کش‌شده وجود دارد.
*   اپلیکیشن از یک سیستم داخلی (on-premises) منتقل شده است که در آن تأخیر شبکه مسئله‌ای نبوده و سیستم روی سخت‌افزارهای گران‌قیمت و با کارایی بالا اجرا می‌شده، بنابراین کشینگ در طراحی اولیه در نظر گرفته نشده بود.
*   توسعه‌دهندگان از امکان استفاده از کش در یک سناریوی خاص آگاه نیستند. برای مثال، ممکن است هنگام پیاده‌سازی یک Web API به استفاده از ETags فکر نکنند.

#### **چگونه ضدالگوی عدم استفاده از کش را برطرف کنیم؟**

محبوب‌ترین استراتژی کشینگ، استراتژی «عنداللزوم» یا Cache-Aside است.

*   **هنگام خواندن (On read):** اپلیکیشن سعی می‌کند داده‌ها را از کش بخواند. اگر داده در کش نباشد، اپلیکیشن آن را از منبع داده بازیابی کرده و به کش اضافه می‌کند.
*   **هنگام نوشتن (On write):** اپلیکیشن تغییر را مستقیماً در منبع داده می‌نویسد و مقدار قدیمی را از کش حذف می‌کند. این داده در دفعه بعدی که مورد نیاز باشد، بازیابی شده و به کش اضافه خواهد شد.

این رویکرد برای داده‌هایی که به طور مکرر تغییر می‌کنند، مناسب است. در ادامه، مثال قبلی با استفاده از الگوی Cache-Aside به‌روزرسانی شده است.

[کد نمونه]

---

توجه کنید که متد `GetAsync` اکنون به جای فراخوانی مستقیم پایگاه داده، کلاس `CacheService` را فراخوانی می‌کند. کلاس `CacheService` ابتدا سعی می‌کند آیتم را از Azure Cache for Redis دریافت کند. اگر مقدار در کش پیدا نشود، `CacheService` یک تابع لامبدا (lambda function) را که توسط فراخواننده به آن پاس داده شده، اجرا می‌کند. این تابع لامبدا مسئول واکشی داده از پایگاه داده است. این پیاده‌سازی، مخزن (repository) را از راه‌حل کشینگ خاص جدا می‌کند و `CacheService` را از پایگاه داده مستقل می‌سازد.

#### **ملاحظات برای استراتژی کشینگ**

*   اگر کش در دسترس نباشد، شاید به دلیل یک شکست گذرا (transient failure)، به کلاینت خطا برنگردانید. در عوض، داده‌ها را از منبع داده اصلی واکشی کنید. با این حال، آگاه باشید که در حین بازیابی کش، منبع داده اصلی ممکن است با هجوم درخواست‌ها مواجه شود و منجر به اتمام زمان مجاز (timeouts) و شکست در اتصال گردد. (در نهایت، این یکی از انگیزه‌های اصلی استفاده از کش است.) از تکنیکی مانند الگوی Circuit Breaker برای جلوگیری از تحت فشار قرار دادن منبع داده استفاده کنید.
*   اپلیکیشن‌هایی که داده‌های پویا را کش می‌کنند باید طوری طراحی شوند که از سازگاری نهایی (eventual consistency) پشتیبانی کنند.
*   برای Web APIها، می‌توانید با گنجاندن هدر `Cache-Control` در پیام‌های درخواست و پاسخ و استفاده از `ETags` برای شناسایی نسخه‌های اشیاء، از کشینگ سمت کلاینت (client-side) پشتیبانی کنید.
*   لازم نیست کل موجودیت‌ها را کش کنید. اگر بخش عمده‌ای از یک موجودیت ایستا است و تنها بخش کوچکی به طور مکرر تغییر می‌کند، عناصر ایستا را کش کرده و عناصر پویا را از منبع داده بازیابی کنید. این رویکرد می‌تواند به کاهش حجم ورودی/خروجی در برابر منبع داده کمک کند.
*   در برخی موارد، اگر داده‌های ناپایدار (volatile) عمر کوتاهی دارند، کش کردن آن‌ها می‌تواند مفید باشد. برای مثال، دستگاهی را در نظر بگیرید که به طور مداوم به‌روزرسانی‌های وضعیت را ارسال می‌کند. ممکن است منطقی باشد که این اطلاعات را به محض رسیدن کش کرده و اصلاً آن را در یک انبار داده پایدار ننویسید.
*   برای جلوگیری از کهنه شدن (stale) داده‌ها، بسیاری از راه‌حل‌های کشینگ از دوره‌های انقضای قابل تنظیم پشتیبانی می‌کنند، به طوری که داده‌ها پس از یک بازه زمانی مشخص به طور خودکار از کش حذف می‌شوند. ممکن است لازم باشد زمان انقضا را برای سناریوی خود تنظیم کنید. داده‌هایی که بسیار ایستا هستند می‌توانند برای مدت طولانی‌تری نسبت به داده‌های ناپایداری که ممکن است به سرعت کهنه شوند، در کش بمانند.
*   اگر راه‌حل کشینگ، انقضای داخلی ارائه نمی‌دهد، ممکن است نیاز به پیاده‌سازی یک فرآیند پس‌زمینه (background process) داشته باشید که گاهی کش را پاکسازی کند تا از رشد بی‌رویه آن جلوگیری شود.
*   علاوه بر کش کردن داده‌ها از یک منبع داده خارجی، می‌توانید از کشینگ برای ذخیره نتایج محاسبات پیچیده استفاده کنید. اما قبل از انجام این کار، اپلیکیشن را ابزار دقیق‌سنجی (instrument) کنید تا مشخص شود آیا اپلیکیشن واقعاً به دلیل پردازش CPU دچار تنگنا شده است (CPU-bound).
*   ممکن است مفید باشد که هنگام شروع به کار اپلیکیشن، کش را آماده‌سازی اولیه (prime) کنید. کش را با داده‌هایی که به احتمال زیاد استفاده خواهند شد، پر کنید.
*   همیشه ابزار دقیق‌سنجی را برای تشخیص موفقیت‌ها و خطاهای کش (cache hits and cache misses) در نظر بگیرید. از این اطلاعات برای تنظیم سیاست‌های کشینگ، مانند اینکه چه داده‌هایی کش شوند و چه مدت قبل از انقضا در کش نگهداری شوند، استفاده کنید.
*   اگر عدم استفاده از کش یک گلوگاه (bottleneck) باشد، اضافه کردن کش ممکن است حجم درخواست‌ها را آنقدر افزایش دهد که بخش فرانت‌اند وب (web front end) دچار بار اضافی شود. کلاینت‌ها ممکن است شروع به دریافت خطاهای HTTP 503 (Service Unavailable) کنند. اینها نشانه‌ای هستند که باید فرانت‌اند را به صورت افقی ارتقا دهید (scale out).

---

#### **چگونه ضدالگوی عدم استفاده از کش را شناسایی کنیم؟**

برای شناسایی اینکه آیا عدم استفاده از کش باعث مشکلات عملکردی شده است، می‌توانید مراحل زیر را انجام دهید:

1.  طراحی اپلیکیشن را بازبینی کنید. فهرستی از تمام انبارهای داده‌ای که اپلیکیشن استفاده می‌کند، تهیه کنید. برای هر کدام، تعیین کنید که آیا اپلیکیشن از کش استفاده می‌کند یا خیر. در صورت امکان، تعیین کنید که داده‌ها هر چند وقت یکبار تغییر می‌کنند. کاندیداهای اولیه خوب برای کشینگ شامل داده‌هایی هستند که به کندی تغییر می‌کنند و داده‌های مرجع ایستایی که به طور مکرر خوانده می‌شوند.
2.  اپلیکیشن را ابزار دقیق‌سنجی کرده و سیستم در حال اجرا را نظارت کنید تا بفهمید اپلیکیشن هر چند وقت یکبار داده‌ها را بازیابی یا اطلاعات را محاسبه می‌کند.
3.  اپلیکیشن را در یک محیط آزمایشی پروفایل کنید تا معیارهای سطح پایینی در مورد سربار مرتبط با عملیات دسترسی به داده یا سایر محاسبات مکرر به دست آورید.
4.  در یک محیط آزمایشی تست بار انجام دهید تا مشخص شود سیستم تحت یک بار کاری عادی و تحت بار سنگین چگونه پاسخ می‌دهد. تست بار باید الگوی دسترسی به داده مشاهده‌شده در محیط اصلی را با استفاده از بارهای کاری واقع‌بینانه شبیه‌سازی کند.
5.  آمار دسترسی به داده برای انبارهای داده زیربنایی را بررسی کرده و ببینید که درخواست‌های داده یکسان چقدر تکرار می‌شوند.

#### **مثال تشخیصی**

بخش‌های زیر این مراحل را برای اپلیکیشن نمونه‌ای که قبلاً شرح داده شد، به کار می‌گیرند.

##### **ابزار دقیق‌سنجی و نظارت بر سیستم در حال اجرا**

اپلیکیشن را ابزار دقیق‌سنجی کرده و آن را نظارت کنید تا اطلاعاتی در مورد درخواست‌های خاصی که کاربران در حین کار اپلیکیشن در محیط اصلی (production) ارسال می‌کنند، به دست آورید.

تصویر زیر داده‌های نظارتی ثبت‌شده توسط New Relic را در طول یک تست بار نشان می‌دهد. در این مورد، تنها عملیات HTTP GET انجام‌شده `Person/GetAsync` است. اما در یک محیط واقعی، دانستن فراوانی نسبی هر درخواست می‌تواند به شما در مورد اینکه کدام منابع باید کش شوند، بینش دهد.

[نمودار ۱]

---

اگر به تحلیل عمیق‌تری نیاز دارید، می‌توانید از یک پروفایلر برای ثبت داده‌های عملکرد سطح پایین در یک محیط آزمایشی (نه سیستم اصلی) استفاده کنید. به معیارهایی مانند نرخ درخواست‌های ورودی/خروجی، مصرف حافظه و استفاده از CPU نگاه کنید. این معیارها ممکن است تعداد زیادی درخواست به یک انبار داده یا سرویس، یا پردازش‌های تکراری که محاسبات یکسانی را انجام می‌دهند، نشان دهند.

##### **تست بار اپلیکیشن**

نمودار زیر نتایج تست بار اپلیکیشن نمونه را نشان می‌دهد. تست بار یک بار پله‌ای تا ۸۰۰ کاربر را شبیه‌سازی می‌کند که یک سری عملیات معمول را انجام می‌دهند.

[نمودار ۲]

---

تعداد تست‌های موفق انجام‌شده در هر ثانیه به یک سطح ثابت می‌رسد و در نتیجه، درخواست‌های اضافی کند می‌شوند. میانگین زمان تست به طور پیوسته با بار کاری افزایش می‌یابد. زمان پاسخ‌دهی پس از رسیدن بار کاربران به اوج، ثابت می‌شود.

##### **بررسی آمار دسترسی به داده**

آمار دسترسی به داده و سایر اطلاعات ارائه‌شده توسط یک انبار داده می‌تواند اطلاعات مفیدی ارائه دهد، مانند اینکه کدام کوئری‌ها بیشتر تکرار می‌شوند. برای مثال، در Microsoft SQL Server، نمای مدیریتی `sys.dm_exec_query_stats` اطلاعات آماری برای کوئری‌های اخیراً اجراشده را دارد. متن هر کوئری در نمای `sys.dm_exec_sql_text` موجود است. می‌توانید از ابزاری مانند SQL Server Management Studio برای اجرای کوئری SQL زیر و تعیین فراوانی اجرای کوئری‌ها استفاده کنید.

ستون `UseCount` در نتایج نشان می‌دهد که هر کوئری چند بار اجرا شده است. تصویر زیر نشان می‌دهد که سومین کوئری بیش از ۲۵۰,۰۰۰ بار اجرا شده است که به طور قابل توجهی بیشتر از هر کوئری دیگری است.

[تصویر نتایج کوئری]

---

در زیر کوئری SQL که باعث این همه درخواست به پایگاه داده شده، آمده است:

[کوئری SQL]

این همان کوئری است که Entity Framework در متد `GetByIdAsync` که قبلاً نشان داده شد، تولید می‌کند.

##### **پیاده‌سازی راه‌حل استراتژی کش و تأیید نتیجه**

پس از اضافه کردن کش، تست‌های بار را تکرار کرده و نتایج را با تست‌های بار قبلی (بدون کش) مقایسه کنید. در زیر نتایج تست بار پس از اضافه کردن کش به اپلیکیشن نمونه آمده است.

[نمودار ۳]

---

حجم تست‌های موفق هنوز به یک سطح ثابت می‌رسد، اما در بار کاربری بالاتری. نرخ درخواست در این بار به طور قابل توجهی بالاتر از قبل است. میانگین زمان تست هنوز با بار افزایش می‌یابد، اما حداکثر زمان پاسخ‌دهی ۰.۰۵ میلی‌ثانیه است، در حالی که قبلاً ۱ میلی‌ثانیه بود—یک بهبود ۲۰ برابری.

---
#### **منابع مرتبط**
*   بهترین شیوه‌های پیاده‌سازی API
*   الگوی Cache-Aside
*   بهترین شیوه‌های کشینگ
*   الگوی Circuit Breaker
