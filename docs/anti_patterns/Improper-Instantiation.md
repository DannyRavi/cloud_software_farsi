بسیار خب، در ادامه بازبینی و روان‌سازی متن دوم برای شما ارائه می‌شود.

---

### **ضدالگو (Antipattern): نمونه‌سازی نادرست (Improper Instantiation)**

گاهی اوقات، نمونه‌های جدیدی از یک کلاس به طور مداوم ایجاد می‌شوند، در حالی که آن کلاس برای این طراحی شده که یک بار ایجاد و سپس به اشتراک گذاشته شود. این رفتار می‌تواند به عملکرد آسیب بزند و «ضدالگوی نمونه‌سازی نادرست» نامیده می‌شود. ضدالگو یک راهکار رایج برای یک مسئله تکرارشونده است که معمولاً ناکارآمد بوده و حتی ممکن است نتیجه معکوس داشته باشد.

#### **شرح مشکل**

بسیاری از کتابخانه‌ها، انتزاعی (abstraction) از منابع خارجی ارائه می‌دهруют. این کلاس‌ها در داخل خود، معمولاً اتصالاتشان به آن منبع را مدیریت کرده و به عنوان «واسط» (broker) عمل می‌کنند که کلاینت‌ها می‌توانند برای دسترسی به منبع از آن‌ها استفاده کنند. در ادامه چند نمونه از کلاس‌های واسط که با اپلیکیشن‌های Azure مرتبط هستند، آورده شده است:

*   **System.Net.Http.HttpClient:** برای برقراری ارتباط با یک وب‌سرویس از طریق HTTP.
*   **Microsoft.ServiceBus.Messaging.QueueClient:** برای ارسال و دریافت پیام در یک صف Service Bus.
*   **Microsoft.Azure.Documents.Client.DocumentClient:** برای اتصال به یک نمونه Azure Cosmos DB.
*   **StackExchange.Redis.ConnectionMultiplexer:** برای اتصال به Redis، از جمله Azure Cache for Redis.

این کلاس‌ها برای این طراحی شده‌اند که یک بار نمونه‌سازی شده و در طول عمر اپلیکیشن، مجدداً استفاده شوند. اما، این تصور اشتباه رایج وجود دارد که این کلاس‌ها باید فقط در مواقع لزوم ایجاد و به سرعت آزاد شوند. (کلاس‌های ذکر شده در اینجا مربوط به کتابخانه‌های NET. هستند، اما این الگو مختص NET. نیست.) مثال زیر در ASP.NET یک نمونه از `HttpClient` برای ارتباط با یک سرویس راه دور ایجاد می‌کند.

در یک اپلیکیشن وب، این روش مقیاس‌پذیر (scalable) نیست. به ازای هر درخواست کاربر، یک شیء `HttpClient` جدید ایجاد می‌شود. تحت بار سنگین، وب‌سرور ممکن است تعداد سوکت‌های موجود را به اتمام برساند و منجر به خطاهای `SocketException` شود.

این مشکل تنها به کلاس `HttpClient` محدود نمی‌شود. کلاس‌های دیگری که منابع را کپسوله (wrap) می‌کنند یا ایجاد آن‌ها پرهزینه است، ممکن است مشکلات مشابهی ایجاد کنند. مثال زیر یک نمونه از کلاس `ExpensiveToCreateService` ایجاد می‌کند. در اینجا مشکل لزوماً تمام شدن سوکت‌ها نیست، بلکه صرفاً مدت زمانی است که برای ایجاد هر نمونه صرف می‌شود. ایجاد و از بین بردن مداوم نمونه‌های این کلاس ممکن است بر مقیاس‌پذیری سیستم تأثیر منفی بگذارد.

#### **چگونه ضدالگوی نمونه‌سازی نادرست را برطرف کنیم؟**

اگر کلاسی که منبع خارجی را کپسوله می‌کند، قابل اشتراک‌گذاری و امن برای نخ‌ها (thread-safe) باشد، یک نمونه سینگلتون (singleton) مشترک یا استخری (pool) از نمونه‌های قابل استفاده مجدد از آن کلاس ایجاد کنید.

مثال زیر از یک نمونه استاتیک `HttpClient` استفاده می‌کند و در نتیجه، اتصال را بین تمام درخواست‌ها به اشتراک می‌گذارد.

#### **ملاحظات**

عنصر کلیدی این ضدالگو، ایجاد و از بین بردن مکرر نمونه‌های یک شیء قابل اشتراک‌گذاری است. اگر کلاسی قابل اشتراک‌گذاری نباشد (یعنی thread-safe نباشد)، این ضدالگو در مورد آن صدق نمی‌کند.

نوع منبع مشترک ممکن است تعیین کند که شما باید از سینگلتون استفاده کنید یا یک استخر ایجاد نمایید. کلاس `HttpClient` برای اشتراک‌گذاری طراحی شده، نه برای استخرسازی (pooling). اشیاء دیگر ممکن است از استخرسازی پشتیبانی کنند و به سیستم امکان دهند که بار کاری را بین چندین نمونه توزیع کند.

اشیاءی که بین چندین درخواست به اشتراک می‌گذارید باید امن برای نخ‌ها (thread-safe) باشند. کلاس `HttpClient` برای استفاده به این روش طراحی شده است، اما کلاس‌های دیگر ممکن است از درخواست‌های همزمان پشتیبانی نکنند، بنابراین مستندات موجود را بررسی کنید.

در مورد تنظیم خصوصیات (properties) روی اشیاء مشترک مراقب باشید، زیرا این کار می‌تواند منجر به شرایط رقابتی (race conditions) شود. برای مثال، تنظیم `DefaultRequestHeaders` در کلاس `HttpClient` قبل از هر درخواست، می‌تواند یک شرایط رقابتی ایجاد کند. چنین خصوصیاتی را یک بار تنظیم کنید (مثلاً در هنگام راه‌اندازی)، و اگر نیاز به پیکربندی‌های متفاوتی دارید، نمونه‌های جداگانه ایجاد کنید.

برخی از انواع منابع، کمیاب هستند و نباید برای مدت طولانی نگه داشته شوند. اتصالات پایگاه داده یک نمونه از این موارد هستند. نگه داشتن یک اتصال باز پایگاه داده که مورد نیاز نیست، ممکن است مانع دسترسی سایر کاربران همزمان به پایگاه داده شود.

در NET. Framework، بسیاری از اشیاءی که با منابع خارجی ارتباط برقرار می‌کنند، با استفاده از متدهای static factory کلاس‌های دیگری که این اتصالات را مدیریت می‌کنند، ایجاد می‌شوند. این اشیاء برای ذخیره و استفاده مجدد در نظر گرفته شده‌اند، نه اینکه دور انداخته و دوباره ایجاد شوند. برای مثال، در Azure Service Bus، شیء `QueueClient` از طریق یک شیء `MessagingFactory` ایجاد می‌شود. در داخل، `MessagingFactory` اتصالات را مدیریت می‌کند. برای اطلاعات بیشتر، به «بهترین شیوه‌ها برای بهبود عملکرد با استفاده از پیام‌رسانی Service Bus» مراجعه کنید.

#### **چگونه ضدالگوی نمونه‌سازی نادرست را شناسایی کنیم؟**

علائم این مشکل شامل کاهش توان عملیاتی یا افزایش نرخ خطا، به همراه یک یا چند مورد از موارد زیر است:

*   افزایش استثناها (exceptions) که نشان‌دهنده اتمام منابعی مانند سوکت‌ها، اتصالات پایگاه داده، دستگیره‌های فایل (file handles) و غیره است.
*   افزایش مصرف حافظه و عملیات جمع‌آوری زباله (garbage collection).
*   افزایش فعالیت شبکه، دیسک یا پایگاه داده.

برای شناسایی این مشکل می‌توانید مراحل زیر را انجام دهید:

1.  نظارت بر فرآیندهای سیستم در حال کار (production)، برای شناسایی نقاطی که زمان پاسخ‌دهی کند می‌شود یا سیستم به دلیل کمبود منابع از کار می‌افتد.
2.  بررسی داده‌های تله‌متری ثبت‌شده در این نقاط برای تعیین اینکه کدام عملیات‌ها ممکن است در حال ایجاد و از بین بردن اشیاء مصرف‌کننده منابع باشند.
3.  هر عملیات مشکوک را در یک محیط آزمایشی کنترل‌شده (و نه در سیستم اصلی) تست بار کنید.
4.  کد منبع را بازبینی کرده و نحوه مدیریت اشیاء واسط (broker) را بررسی کنید.

به ردپای پشته (stack traces) برای عملیات‌هایی که کند اجرا می‌شوند یا زمانی که سیستم تحت بار است استثنا تولید می‌کنند، نگاه کنید. این اطلاعات می‌تواند به شناسایی نحوه استفاده این عملیات‌ها از منابع کمک کند. استثناها می‌توانند به تعیین اینکه آیا خطاها ناشی از اتمام منابع مشترک هستند، کمک کنند.

#### **مثال تشخیصی**
بخش‌های زیر این مراحل را برای اپلیکیشن نمونه‌ای که قبلاً شرح داده شد، به کار می‌گیرند.

##### **شناسایی نقاط کندی یا شکست**
تصویر زیر نتایج تولیدشده با استفاده از New Relic APM را نشان می‌دهد که عملیات‌هایی با زمان پاسخ‌دهی ضعیف را مشخص می‌کند. در این مورد، متد `GetProductAsync` در کنترلر `NewHttpClientInstancePerRequest` ارزش بررسی بیشتر را دارد. توجه کنید که با اجرای این عملیات‌ها، نرخ خطا نیز افزایش می‌یابد.

[نمودار ۱]

---

##### **بررسی داده‌های تله‌متری و یافتن ارتباطات**
تصویر بعدی داده‌های ثبت‌شده با استفاده از پروفایلینگ نخ‌ها (thread profiling) را در همان دوره زمانی تصویر قبل نشان می‌دهد. سیستم زمان قابل توجهی را صرف باز کردن اتصالات سوکت، و حتی زمان بیشتری را صرف بستن آن‌ها و مدیریت استثناهای سوکت می‌کند.

[نمودار ۲]

---

##### **انجام تست بار**

از تست بار برای شبیه‌سازی عملیات‌های معمولی که کاربران ممکن است انجام دهند، استفاده کنید. این کار می‌تواند به شناسایی بخش‌هایی از سیستم که تحت بارهای مختلف از اتمام منابع رنج می‌برند، کمک کند. این تست‌ها را در یک محیط کنترل‌شده و نه در سیستم اصلی انجام دهید. نمودار زیر توان عملیاتی درخواست‌های پردازش‌شده توسط کنترلر `NewHttpClientInstancePerRequest` را با افزایش بار کاربران تا ۱۰۰ کاربر همزمان نشان می‌دهد.

[نمودار ۳]

---

در ابتدا، با افزایش بار کاری، حجم درخواست‌های پردازش‌شده در ثانیه افزایش می‌یابد. اما در حدود ۳۰ کاربر، حجم درخواست‌های موفق به یک حد آستانه می‌رسد و سیستم شروع به تولید استثنا می‌کند. از آن پس، حجم استثناها به تدریج با بار کاربران افزایش می‌یابد.

تست بار این شکست‌ها را به عنوان خطاهای HTTP 500 (Internal Server) گزارش داد. بررسی تله‌متری نشان داد که این خطاها ناشی از اتمام منابع سوکت در سیستم بوده است، زیرا تعداد بیشتری از اشیاء `HttpClient` ایجاد می‌شدند.

نمودار بعدی یک تست مشابه را برای کنترلری نشان می‌دهد که شیء سفارشی `ExpensiveToCreateService` را ایجاد می‌کند.

[نمودار ۴]

---

این بار، کنترلر هیچ استثنایی تولید نمی‌کند، اما توان عملیاتی همچنان به یک سطح ثابت می‌رسد، در حالی که میانگین زمان پاسخ‌دهی تا ۲۰ برابر افزایش می‌یابد. (نمودار از مقیاس لگاریتمی برای زمان پاسخ‌دهی و توان عملیاتی استفاده می‌کند.) تله‌متری نشان داد که ایجاد نمونه‌های جدید از `ExpensiveToCreateService` دلیل اصلی مشکل بوده است.

##### **پیاده‌سازی راه‌حل و تأیید نتیجه**

پس از تغییر متد `GetProductAsync` برای اشتراک‌گذاری یک نمونه `HttpClient` واحد، تست بار دوم عملکرد بهبودیافته‌ای را نشان داد. هیچ خطایی گزارش نشد و سیستم توانست بار فزاینده‌ای تا ۵۰۰ درخواست در ثانیه را مدیریت کند. میانگین زمان پاسخ‌دهی در مقایسه با تست قبلی به نصف کاهش یافت.

[نمودار ۵]

---

برای مقایسه، تصویر زیر تله‌متری ردپای پشته را نشان می‌دهد. این بار، سیستم بیشتر وقت خود را صرف انجام کار واقعی می‌کند، نه باز و بسته کردن سوکت‌ها.

[نمودار ۶]

---

نمودار بعدی یک تست بار مشابه را با استفاده از یک نمونه مشترک از شیء `ExpensiveToCreateService` نشان می‌دهد. باز هم، حجم درخواست‌های پردازش‌شده متناسب با بار کاربران افزایش می‌یابد، در حالی که میانگین زمان پاسخ‌دهی پایین باقی می‌ماند.

[نمودار ۷]
