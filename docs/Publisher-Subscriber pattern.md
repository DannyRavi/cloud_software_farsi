
برنامه‌ای را فعال کنید تا رویدادها را به‌صورت ناهمزمان به چندین مصرف‌کننده (consumer)  که نیازمند این رویدادها هستند، اعلام کند. بدون اینکه فرستنده‌ها به گیرنده‌ها متصل شوند.  
  
نام دیگر این الگو Pub/sub messaging می باشد.

## Context and problem

در برنامه های cloud-based و توزیع شده(distributed)، اجزای سیستم اغلب نیاز به ارائه اطلاعات به اجزای دیگر هنگام وقوع رویدادها دارند.  
  
پیام‌رسانی ناهمزمان (Asynchronous messaging) روشی مؤثر برای جدا کردن فرستندگان از مصرف‌کنندگان(consumers) و جلوگیری از block شدن فرستنده برای منتظر ماندن برای پاسخ است. با این حال، استفاده از یک صف پیام اختصاصی برای هر مصرف کننده به طور موثر برای بسیاری از مصرف کنندگان دیگر قابل scale شدن نیست. همچنین ممکن است برخی از مصرف کنندگان  فقط به زیر مجموعه ای از اطلاعات نیازمند باشند. پس چگونه فرستنده می تواند رویدادها را به همه مصرف کنندگان نیازمند بدون اطلاع از هویت آنها اعلام کند؟

## Solution

یک زیر سیستم پیام رسانی ناهمزمان را معرفی کنید که شامل موارد زیر است:  
  
* یک کانال پیام ورودی که توسط فرستنده استفاده می شود. فرستنده رویدادها را با استفاده از یک قالب پیام شناخته شده در پیام ها بسته بندی می کند و این پیام ها را از طریق کانال ورودی ارسال می کند. فرستنده در این الگو ناشر (_publisher_) نیز نامیده می شود.

```
توجه داشته باشید  
  
پیام یک بسته ای از داده ها است. همینطور رویداد یک پیامی است که سایر اجزا را در مورد تغییرات یا اقداماتی که رخ داده است مطلع می کند.
```

* یک خروجی کانال پیام رسانی فقط برای یک مصرف کننده می‌باشد. این مصرف کنندگان به عنوان مشترک(_subscribers_) شناخته می شوند.  
  
* مکانیزمی برای کپی کردن هر پیام از کانال ورودی به کانال های خروجی برای همه مشترکین که نیازمند به آن پیام هستند مورد نیاز است. این عملیات معمولاً توسط یک واسطه مانند message broker یا event bus انجام می شود.

نمودار زیر اجزای منطقی این الگو را نشان می دهد:

![[Pasted image 20231205113912.png]]

پیام‌رسانی Pub/sub مزایای زیر را دارد:  
  
* این سیستم های فرعی را که هنوز نیاز به ارتباط دارند جدا می کند. زیرسیستم ها را می توان به طور مستقل مدیریت کرد و پیام ها را می توان به درستی مدیریت کرد حتی اگر یک یا چند گیرنده آفلاین باشند.  
  
* مقیاس پذیری(scalability) را افزایش می دهد و پاسخگویی سمت ارسال کننده پیام را بهبود می بخشد. فرستنده می تواند به سرعت یک پیام واحد را به کانال ورودی ارسال کند، سپس به مسئولیت های پردازش اصلی خود بازگردد. زیرساخت پیام رسانی مسئول اطمینان از تحویل پیام ها به مشترکین نیازمند است.  
  
* قابلیت اطمینان(reliability) را بهبود می بخشد. پیام‌رسانی ناهمزمان به برنامه‌ها کمک می‌کند تا تحت بارهای افزایش‌یافته به آرامی کار کنند و خرابی‌های متناوب را به طور مؤثرتری مدیریت کنند.  
  
* امکان پردازش معوق یا برنامه ریزی شده را فراهم می کند. مشترکین می‌توانند منتظر دریافت پیام‌ها تا ساعات کم مصرف باشند، یا پیام‌ها می‌توانند طبق یک برنامه زمان‌بندی خاص مسیریابی یا پردازش شوند.  
  
* یکپارچگی ساده‌تر بین سیستم‌هایی که از پلتفرم‌ها، زبان‌های برنامه‌نویسی یا پروتکل‌های ارتباطی مختلف استفاده می‌کنند و همچنین بین سیستم‌های داخلی و برنامه‌های کاربردی در حال اجرا در فضای ابری را امکان‌پذیر می‌سازد.  
  
* این workflows ناهمزمان را در سراسر یک تشکیلات تسهیل می کند.  
  
* تست پذیری را بهبود می بخشد. کانال‌ها را می‌توان نظارت کرد و پیام‌ها را می‌توان به عنوان بخشی از استراتژی تست یکپارچه‌سازی کلی بازرسی یا ثبت کرد.  
  
* این جداسازی نگرانی ها(separation of concerns) را برای applicationهای شما فراهم می کند. هر برنامه می‌تواند بر قابلیت‌های اصلی خود تمرکز کند، در حالی که زیرساخت پیام‌رسانی هر چیزی را که برای مسیریابی مطمئن پیام‌ها به چندین مصرف‌کننده(consumer) لازم است، مدیریت می‌کند.

## Issues and considerations

هنگام تصمیم گیری در مورد نحوه اجرای این الگو به نکات زیر توجه کنید:  
  
* **‏Existing technologies** .اکیداً توصیه می شود از محصولات و سرئیس‌های پیام رسانی موجود که از مدل  publish-subscribe پشتیبانی می کنند، به جای ساختن مدل خود استفاده کنید. در Azure، استفاده از Service Bus، Event Hubs یا Event Grid را در نظر بگیرید. فناوری‌های دیگری که می‌توانند برای پیام‌رسانی pub/sub استفاده شوند عبارتند از Redis، RabbitMQ و Apache Kafka.  
  
* **‏Subscription handling**. زیرساخت پیام‌رسانی باید مکانیسم‌هایی را فراهم کند که مصرف‌کنندگان بتوانند از آن برای اشتراک یا لغو اشتراک کانال‌های موجود استفاده کنند.  
  
* **‏Security**. اتصال به هر کانال پیام باید توسط سیاست امنیتی محدود شود تا از استراق سمع توسط کاربران یا برنامه های غیرمجاز جلوگیری شود.  
  
* **‏Subsets of messages** (زیر مجموعه پیام ها). مشترکین(Subscribers) معمولاً فقط به زیر مجموعه ای از پیام های توزیع شده توسط یک publisher علاقه مند هستند. سرویس های پیام رسانی اغلب به مشترکین(subscribers) اجازه می دهند مجموعه پیام های دریافتی توسط موراد زیر محدود و کنترل شوند:  
  
*  **‏Topics** یا موضوعات. هر topic دارای یک کانال خروجی اختصاصی است و هر مصرف کننده می تواند در تمام topicهای مرتبط مشترک شود.  
*  **‏Content filtering** (فیلتر کردن محتوا) پیام ها بر اساس محتوای هر پیام بازرسی و توزیع می شوند. هر مشترک می تواند محتوای مورد نظر خود را مشخص کند.  
* **‏Wildcard subscribers**. در نظر بگیرید که به مشترکین اجازه دهید از طریق <mark style="background: #FF5582A6;">wildcardها</mark> در چندین topic مشترک شوند.  

* **‏Bi-directional communication** (ارتباط دو طرفه) کانال های موجود در سیستم publish-subscribe به عنوان کانال یک سویه تلقی می شوند. اگر یک مشترک(subscriber) خاص نیاز به ارسال تأییدیه یا ارسال وضعیت به publisher دارد، از الگوی [Request/Reply](http://www.enterpriseintegrationpatterns.com/patterns/messaging/RequestReply.html) استفاده کنید. این الگو از یک کانال برای ارسال پیام به subscriber و یک کانال دیگر برای  پاسخ جداگانه جهت برقراری ارتباط با publisher استفاده می کند.  
  
* **‏Message ordering.** (سفارش پیام). این که با چه ترتیبی نمونه‌های مصرف‌کننده(consumer) پیام‌ها را دریافت می‌کنند حالت مشخص و واضحی نبوده و قطعا نشان‌دهنده ترتیب ایجاد پیام‌ها نیست. سیستم را طوری طراحی کنید که اطمینان حاصل شود که پردازش پیام‌ها وابستگی به ترتیب پیام ها نداشته باشد. 
  
* **Message priority** (اولویت پیام). برخی راه حل ها ممکن است نیاز داشته باشند که پیام ها به ترتیب خاصی پردازش شوند. الگوی صف اولویت( [Priority Queue pattern](https://learn.microsoft.com/en-us/azure/architecture/patterns/priority-queue)) مکانیزمی را برای اطمینان از ارسال پیام های خاص قبل از سایر پیام‌ها فراهم می کند.  
  
* **Poison messages** (پیام های سمی). یک پیام نادرست، یا تسک‌ای که نیاز به دسترسی به منابعی دارد که در دسترس نیستند، می‌تواند باعث از کار افتادن یک نمونه سرویس شود. سیستم باید از بازگرداندن چنین پیام هایی به صف جلوگیری کند. در عوض، جزئیات این پیام‌ها را در جای دیگری ضبط و ذخیره کنید تا در صورت لزوم بتوان آن‌ها را تجزیه و تحلیل کرد. برخی از message brokerها، مانند Azure Service Bus، این را از طریق  [dead-letter queue functionality](https://learn.microsoft.com/en-us/azure/service-bus-messaging/service-bus-dead-letter-queues) پشتیبانی می کنند.  
  
* **Repeated messages** (پیام های تکراری). ممکن است همان پیام بیش از یک بار ارسال شود. به عنوان مثال، ممکن است فرستنده پس از ارسال یک پیام با مشکل مواجه شود. سپس یک نمونه جدید از فرستنده ممکن است راه اندازی شود و پیام را تکرار کند. زیرساخت پیام باید تشخیص و حذف پیام تکراری (همچنین به عنوان de-duping شناخته می شود) را بر اساس شناسه پیام پیاده سازی کند تا حداکثر یک بار تحویل پیام ها را ارائه دهد. از طرف دیگر، اگر از زیرساخت پیام‌رسانی استفاده می‌کنید که پیام‌های تکراری را حذف نمی‌کند، مطمئن شوید که منطق پردازش پیام ضعیف([message processing logic is idempotent](https://learn.microsoft.com/en-us/azure/architecture/reference-architectures/containers/aks-mission-critical/mission-critical-data-platform#idempotent-message-processing)) است.  
  
* **Message expiration** (انقضای پیام). یک پیام ممکن است عمر محدودی داشته باشد. اگر در آن  مدت خاص پردازش نشود، ممکن است دیگر اثر گذار نباشد و  کنار گذاشته شود. یک ارسال کننده پیام می تواند زمان انقضا را به عنوان بخشی از داده های پیام مشخص کند. یک گیرنده می تواند این اطلاعات را قبل از تصمیم گیری در مورد اجرای business logic مرتبط با پیام بررسی کند.  
  
* **Message scheduling.** (برنامه ریزی پیام). یک پیام ممکن است به طور موقت محدود شود و نباید تا تاریخ و زمان خاصی پردازش شود. پیام نباید تا این زمان در دسترس گیرنده باشد.

## When to use this pattern

از این الگو زمانی استفاده کنید که:  
  
* یک برنامه باید اطلاعات را برای تعداد قابل توجهی از مصرف کنندگان(consumers) پخش کند.  
  
* یک application نیاز به ارتباط با یک یا چند برنامه یا سرویس مستقل دارد که ممکن است از پلتفرم ها، زبان های برنامه نویسی و پروتکل های ارتباطی متفاوتی استفاده کنند.  
  
* یک application ای که می تواند بدون نیاز به دریافت پاسخ های بلادرنگ از سوی مصرف کنندگان(consumers)، اطلاعات را برای آن مصرف کنندگان ارسال کند. در واقع حالت هایی که پردازش‌ و پاسخ های کمتر بلادرنگ یا real-time مورد نیاز باشد.  
  
* سیستم های در حال ادغام برای پشتیبانی از یک مدل سازگاری نهایی برای داده های خود طراحی شده اند.  
  
* یک application باید اطلاعات را به چندین مصرف کننده منتقل کند، که ممکن است نیازهای availability یا uptime schedules متفاوتی نسبت به ارسال کننده پیام داشته باشند.  
  
* این الگو ممکن است زمانی مفید نباشد که:  
  
* یک application فقط تعداد کمی از مصرف کنندگان(consumers) دارد که به اطلاعات متفاوتی با برنامه تولید کننده(producing) نیاز دارند. 
  
* یک application به تعامل تقریباً لحظه ای با مصرف کنندگان نیاز دارد.

## Example

نمودار زیر یک معماری یکپارچه سازی سازمانی را نشان می دهد که از Service Bus برای هماهنگ کردن workflowها و شبکه رویداد (Event Grid) برای اطلاع رسانی به سیستم های فرعی از رویدادهای رخ داده استفاده می کند. برای اطلاعات بیشتر،  [Enterprise integration on Azure using message queues and events](https://learn.microsoft.com/en-us/azure/architecture/example-scenario/integration/queues-events) را ببینید.

![[Pasted image 20231205114153.png]]

## Next steps

راهنمایی زیر ممکن است هنگام اجرای این الگو  دارای ارتباط باشد:  
  
* ([Choose between Azure services that deliver messages](https://learn.microsoft.com/en-us/azure/event-grid/compare-messaging-services)) بین سرویس‌های Azure که پیام‌ها را ارائه می‌کنند، یکی را انتخاب کنید.  
  
* [Asynchronous Messaging Primer](https://learn.microsoft.com/en-us/previous-versions/msp-n-p/dn589781(v=pandp.10)) (شروع کننده پیام رسانی ناهمزمان). صف های پیام یک مکانیسم ارتباطی ناهمزمان هستند. اگر یک سرویس مصرف کننده نیاز به ارسال پاسخ به یک application  داشته باشد، ممکن است لازم باشد که نوعی پیام پاسخ را پیاده سازی کند. Asynchronous Messaging Primer اطلاعاتی در مورد نحوه اجرای پیام request/reply با استفاده از صف های پیام ارائه می دهد.  
  
* الگوهای زیر ممکن است هنگام اجرای این الگو مرتبط باشند:  
  
* الگوی [Observer pattern](https://en.wikipedia.org/wiki/Observer_pattern) این  الگوی Publish-Subscribe با جدا کردن subjectها از observerها از طریق پیام‌رسانی ناهمزمان(synchronous messaging)، بر روی الگوی Observer ایجاد می‌شود.  
  
* الگوی[Message Broker pattern](https://en.wikipedia.org/wiki/Message_broker). بسیاری از زیرسیستم های پیام رسانی که از مدل publish-subscribe پشتیبانی می کنند از طریق یک message broker پیاده سازی می شوند.  
  
* این پست وبلاگ ([This blog post](https://particular.net/blog/you-dont-need-ordered-delivery)) روش‌های مختلف مدیریت پیام‌هایی را  توضیح می‌دهد.

## Related resources

- The [Event-driven architecture style](https://learn.microsoft.com/en-us/azure/architecture/guide/architecture-styles/event-driven) is an architecture style that uses pub/sub messaging.
- [Idempotent message processing](https://learn.microsoft.com/en-us/azure/architecture/reference-architectures/containers/aks-mission-critical/mission-critical-data-platform#idempotent-message-processing)
- [Enterprise integration on Azure using message queues and events](https://learn.microsoft.com/en-us/azure/architecture/example-scenario/integration/queues-events)