وظیفه ای را که پردازش پیچیده ای را انجام می دهد به یک سری عناصر جداگانه که می توانند دوباره استفاده شوند تجزیه کنید. انجام این کار می‌تواند عملکرد، مقیاس‌پذیری و قابلیت استفاده مجدد را با اجازه دادن به عناصر وظیفه که پردازش را انجام می‌دهند به طور مستقل گسترش و مقیاس‌بندی شوند، بهبود بخشد.
## Context and problem

یک برنامه کاربردی می تواند وظایف مختلفی را انجام دهد که از نظر پیچیدگی در اطلاعاتی که پردازش می کند متفاوت است. یک رویکرد ساده اما غیر قابل انعطاف برای اجرای یک برنامه کاربردی، انجام این پردازش در یک ماژول یکپارچه است. با این حال، این رویکرد احتمالاً فرصت‌های ایجاد مجدد کد، بهینه‌سازی یا استفاده مجدد از آن را در صورتی که بخش‌هایی از همان پردازش در جای دیگری در برنامه مورد نیاز باشد، کاهش می‌دهد.  
  
نمودار زیر مشکلات پردازش داده ها را با استفاده از رویکرد یکپارچه نشان می دهد. یک برنامه کاربردی داده ها را از دو منبع دریافت و پردازش می کند. داده های هر منبع توسط یک ماژول جداگانه پردازش می شود که یک سری وظایف را برای تبدیل داده ها قبل از انتقال نتیجه به منطق تجاری برنامه انجام می دهد.

![[Pasted image 20231203230659.png]]

برخی از وظایفی که ماژول های یکپارچه انجام می دهند از نظر عملکردی مشابه هستند، اما ماژول ها به طور جداگانه طراحی شده اند. کدی که وظایف را پیاده‌سازی می‌کند در یک ماژول به صورت نزدیک همراه است. استفاده مجدد و مقیاس پذیری در طول توسعه در نظر گرفته نشد.  
  
با این حال، وظایف پردازشی انجام شده توسط هر ماژول، یا الزامات استقرار برای هر کار، ممکن است با به روز رسانی الزامات تجاری تغییر کند. برخی از وظایف ممکن است کارهای محاسباتی فشرده ای باشند که می توانند از اجرای بر روی سخت افزار قدرتمند بهره مند شوند. سایر وظایف ممکن است به چنین منابع گران قیمتی نیاز نداشته باشند. همچنین، ممکن است در آینده به پردازش بیشتری نیاز باشد، یا ترتیب انجام وظایف پردازش ممکن است تغییر کند. راه حلی برای رفع این مشکلات و افزایش احتمال استفاده مجدد از کد مورد نیاز است.


## Solution

پردازش مورد نیاز برای هر جریان را به مجموعه‌ای از مؤلفه‌ها (یا فیلترها) جداگانه تقسیم کنید، که هر کدام یک کار واحد را انجام می‌دهند. برای دستیابی به یک فرمت استاندارد از داده هایی که هر جزء دریافت و ارسال می کند، فیلترها را می توان در خط لوله ترکیب کرد. انجام این کار از تکرار کد جلوگیری می کند و حذف یا جایگزینی اجزا یا ادغام اجزای اضافی را در صورت تغییر نیازهای پردازش آسان می کند. این نمودار راه حلی را نشان می دهد که با لوله ها و فیلترها پیاده سازی شده است:

![[Pasted image 20231203230749.png]]


مدت زمان پردازش یک درخواست به سرعت کندترین فیلترها در خط لوله بستگی دارد. یک یا چند فیلتر می تواند گلوگاه باشد، به خصوص اگر تعداد زیادی درخواست در یک جریان از یک منبع داده خاص ظاهر شود. مزیت اصلی ساختار خط لوله این است که فرصت هایی را برای اجرای نمونه های موازی فیلترهای کند فراهم می کند که سیستم را قادر می سازد بار را پخش کند و توان عملیاتی را بهبود بخشد.  
  
فیلترهایی که یک خط لوله را تشکیل می‌دهند می‌توانند روی ماشین‌های مختلف اجرا شوند، که به آنها امکان می‌دهد به طور مستقل مقیاس شوند و از خاصیت ارتجاعی که بسیاری از محیط‌های ابری ارائه می‌دهند بهره ببرند. فیلتری که از نظر محاسباتی فشرده است، می‌تواند روی سخت‌افزار با کارایی بالا اجرا شود، در حالی که فیلترهای کم‌تقاضا روی سخت‌افزار کالایی ارزان‌تر میزبانی می‌شوند. حتی نیازی نیست که فیلترها در یک مرکز داده یا موقعیت جغرافیایی یکسان باشند، بنابراین هر عنصر در یک خط لوله در محیطی نزدیک به منابع مورد نیاز اجرا می شود. این نمودار نمونه ای را نشان می دهد که برای داده های منبع 1 روی خط لوله اعمال شده است:

![[Pasted image 20231203230806.png]]

اگر ورودی و خروجی یک فیلتر به صورت جریانی ساختار یافته باشد، می توانید پردازش هر فیلتر را به صورت موازی انجام دهید. اولین فیلتر در خط لوله می تواند کار خود را شروع کند و نتایج خود را خروجی دهد که قبل از اینکه فیلتر اول کار خود را کامل کند مستقیماً به ترتیب به فیلتر بعدی منتقل می شود.  
  
یکی دیگر از مزایای این مدل انعطاف پذیری است که می تواند ارائه دهد. اگر فیلتری از کار بیفتد یا دستگاهی که روی آن کار می‌کند دیگر در دسترس نباشد، خط لوله می‌تواند کاری را که فیلتر انجام می‌داد تغییر دهد و آن را به نمونه دیگری از جزء هدایت کند. خرابی یک فیلتر لزوماً منجر به خرابی کل خط لوله نمی شود.  
  
استفاده از الگوی لوله‌ها و فیلترها همراه با الگوی تراکنش جبران‌کننده یک رویکرد جایگزین برای اجرای تراکنش‌های توزیع‌شده است. شما می توانید یک تراکنش توزیع شده را به وظایف جداگانه و قابل جبران تقسیم کنید، که هر یک از آنها می توانند از طریق فیلتری که الگوی تراکنش جبرانی را نیز پیاده سازی می کند، پیاده سازی شوند. می‌توانید فیلترها را در یک خط لوله به‌عنوان وظایف میزبان مجزا که نزدیک به داده‌هایی که آنها نگهداری می‌کنند اجرا کنید.
## Issues and considerations

هنگام تصمیم گیری در مورد نحوه اجرای این الگو به نکات زیر توجه کنید:  
  
* **پیچیدگی**. افزایش انعطاف‌پذیری که این الگو فراهم می‌کند نیز می‌تواند پیچیدگی ایجاد کند، به خصوص اگر فیلترها در خط لوله در سرورهای مختلف توزیع شوند.  
  
* **قابلیت اطمینان**. از زیرساختی استفاده کنید که تضمین کند داده های جریان یافته بین فیلترها در خط لوله از بین نمی روند.  
  
* **ناتوانی**. اگر فیلتری در خط لوله پس از دریافت پیام از کار بیفتد و کار به نمونه دیگری از فیلتر تغییر کند، ممکن است بخشی از کار قبلاً کامل شده باشد. اگر کار برخی از جنبه های وضعیت جهانی را به روز کند (مانند اطلاعات ذخیره شده در یک پایگاه داده)، یک به روز رسانی واحد می تواند تکرار شود. اگر فیلتری پس از ارسال نتایج به فیلتر بعدی در خط لوله، اما قبل از اینکه نشان دهد کار خود را با موفقیت به پایان رسانده است، مشکل مشابهی ممکن است رخ دهد. در این موارد، همان کار می تواند توسط نمونه دیگری از فیلتر تکرار شود و باعث شود نتایج یکسان دو بار ارسال شود. این سناریو می تواند منجر به فیلترهای بعدی در خط لوله شود که همان داده ها را دو بار پردازش می کند. بنابراین، فیلترها در یک خط لوله باید به گونه ای طراحی شوند که فاقد قدرت باشند. برای اطلاعات بیشتر، الگوهای عدم توانایی را در وبلاگ جاناتان الیور ببینید.  
  
* **پیام های تکراری** اگر فیلتری در خط لوله پس از ارسال پیام به مرحله بعدی خط لوله از کار بیفتد، ممکن است نمونه دیگری از فیلتر اجرا شود و یک کپی از همان پیام را به خط لوله ارسال کند. این سناریو می تواند باعث شود دو نمونه از یک پیام به فیلتر بعدی منتقل شود. برای جلوگیری از این مشکل، خط لوله باید پیام های تکراری را شناسایی و حذف کند.

```
توجه داشته باشید  
  
اگر خط لوله را با استفاده از صف‌های پیام (مانند صف‌های اتوبوس سرویس Azure) پیاده‌سازی کنید، زیرساخت صف پیام ممکن است شناسایی و حذف خودکار پیام تکراری را فراهم کند.
```

* **زمینه و حالت**. در یک خط لوله، هر فیلتر اساسا به صورت مجزا اجرا می شود و نباید هیچ فرضی در مورد نحوه فراخوانی آن داشته باشد. بنابراین، هر فیلتر باید زمینه کافی برای انجام کار خود را داشته باشد. این زمینه می تواند مقدار قابل توجهی از اطلاعات دولتی را شامل شود.
## When to use this pattern

* پردازش مورد نیاز یک برنامه به راحتی می تواند به مجموعه ای از مراحل مستقل تقسیم شود.  
  
* مراحل پردازش انجام شده توسط یک برنامه کاربردی دارای الزامات مقیاس پذیری متفاوتی هستند.

```
توجه داشته باشید  
  
می توانید فیلترهایی را که باید در یک فرآیند با هم مقیاس شوند گروه بندی کنید. برای اطلاعات بیشتر، الگوی تلفیق منابع را محاسبه کنید.
```

* برای اجازه دادن به ترتیب مجدد مراحل پردازشی که توسط یک برنامه کاربردی انجام می شود، یا امکان افزودن و حذف مراحل، به انعطاف پذیری نیاز دارید.  
  
* این سیستم می تواند از توزیع پردازش برای مراحل در سرورهای مختلف بهره مند شود.  
  
* شما به یک راه حل قابل اعتماد نیاز دارید که اثرات شکست را در یک مرحله در حین پردازش داده ها به حداقل برساند.  
  
این الگو ممکن است زمانی مفید نباشد که:  
  
* مراحل پردازش انجام شده توسط یک برنامه مستقل نیستند، یا باید با هم به عنوان بخشی از یک تراکنش واحد انجام شوند.  
  
* مقدار اطلاعات زمینه یا حالتی که برای یک مرحله مورد نیاز است، این رویکرد را ناکارآمد می کند. ممکن است بتوانید اطلاعات وضعیت را در یک پایگاه داده حفظ کنید، اما اگر بار اضافی روی پایگاه داده باعث مشاجره بیش از حد شود، از این استراتژی استفاده نکنید.

## Example

شما می توانید از دنباله ای از صف های پیام برای ارائه زیرساخت های مورد نیاز برای اجرای خط لوله استفاده کنید. یک صف پیام اولیه پیام های پردازش نشده را دریافت می کند. مؤلفه‌ای که به‌عنوان یک کار فیلتر پیاده‌سازی می‌شود، به پیامی در این صف گوش می‌دهد، کار خود را انجام می‌دهد و سپس پیام تبدیل‌شده را به صف بعدی در دنباله پست می‌کند. یکی دیگر از وظایف فیلتر می‌تواند به پیام‌های موجود در این صف گوش دهد، آنها را پردازش کند، نتایج را در صف دیگری ارسال کند، و غیره تا زمانی که داده‌های کاملاً تبدیل‌شده در پیام نهایی در صف ظاهر شوند. این نمودار خط لوله ای را نشان می دهد که از صف های پیام استفاده می کند:

![[Pasted image 20231203231137.png]]


اگر در حال ساخت راه‌حلی در Azure هستید، می‌توانید از صف‌های سرویس اتوبوس برای ارائه یک مکانیسم صف قابل اعتماد و مقیاس‌پذیر استفاده کنید. کلاس ServiceBusPipeFilter نشان داده شده در کد سی شارپ زیر نشان می دهد که چگونه می توانید فیلتری را پیاده سازی کنید که پیام های ورودی را از یک صف دریافت می کند، پیام ها را پردازش می کند و نتایج را در صف دیگری ارسال می کند.

```
توجه داشته باشید  
  
کلاس ServiceBusPipeFilter در پروژه PipesAndFilters.Shared تعریف شده است که در GitHub در دسترس است.
```

```csharp
public class ServiceBusPipeFilter
{
  ...
  private readonly string inQueuePath;
  private readonly string outQueuePath;
  ...
  private QueueClient inQueue;
  private QueueClient outQueue;
  ...

  public ServiceBusPipeFilter(..., string inQueuePath, string outQueuePath = null)
  {
     ...
     this.inQueuePath = inQueuePath;
     this.outQueuePath = outQueuePath;
  }

  public void Start()
  {
    ...
    // Create the outbound filter queue if it doesn't exist.
    ...
    this.outQueue = QueueClient.CreateFromConnectionString(...);

    ...
    // Create the inbound and outbound queue clients.
    this.inQueue = QueueClient.CreateFromConnectionString(...);
  }

  public void OnPipeFilterMessageAsync(
    Func<BrokeredMessage, Task<BrokeredMessage>> asyncFilterTask, ...)
  {
    ...

    this.inQueue.OnMessageAsync(
      async (msg) =>
    {
      ...
      // Process the filter and send the output to the
      // next queue in the pipeline.
      var outMessage = await asyncFilterTask(msg);

      // Send the message from the filter processor
      // to the next queue in the pipeline.
      if (outQueue != null)
      {
        await outQueue.SendAsync(outMessage);
      }

      // Note: There's a chance that the same message could be sent twice
      // or that a message could be processed by an upstream or downstream
      // filter at the same time.
      // This would happen in a situation where processing of a message was
      // completed, it was sent to the next pipe/queue, and it then failed
      // to complete when using the PeekLock method.
      // In a real-world implementation, you should consider idempotent message 
      // processing and concurrency.     
    },
    options);
  }

  public async Task Close(TimeSpan timespan)
  {
    // Pause the processing threads.
    this.pauseProcessingEvent.Reset();

    // There's no clean approach for waiting for the threads to complete
    // the processing. This example simply stops any new processing, waits
    // for the existing thread to complete, closes the message pump,
    // and finally returns.
    Thread.Sleep(timespan);

    this.inQueue.Close();
    ...
  }

  ...
}
```

متد Start در کلاس ServiceBusPipeFilter به یک جفت صف ورودی و خروجی متصل می شود و متد Close از صف ورودی جدا می شود. متد OnPipeFilterMessageAsync پردازش واقعی پیام ها را انجام می دهد و پارامتر asyncFilterTask این روش پردازشی را که باید انجام شود را مشخص می کند. روش OnPipeFilterMessageAsync منتظر پیام های دریافتی در صف ورودی است، کد مشخص شده توسط پارامتر asyncFilterTask را بر روی هر پیامی که می رسد اجرا می کند و نتایج را در صف خروجی پست می کند. صف ها توسط سازنده مشخص می شوند.  
  
راه حل نمونه فیلترها را در مجموعه ای از نقش های کارگر پیاده سازی می کند. هر نقش کارگر بسته به پیچیدگی پردازش تجاری که انجام می دهد یا منابعی که برای پردازش مورد نیاز است، می تواند به طور مستقل مقیاس شود. علاوه بر این، چندین نمونه از هر نقش کارگر را می توان به صورت موازی اجرا کرد تا توان عملیاتی را بهبود بخشد.  
  
کد زیر یک نقش کارگر Azure به نام PipeFilterARoleEntry را نشان می دهد که در پروژه PipeFilterA در حل نمونه تعریف شده است.


```csharp
public class PipeFilterARoleEntry : RoleEntryPoint
{
  ...
  private ServiceBusPipeFilter pipeFilterA;

  public override bool OnStart()
  {
    ...
    this.pipeFilterA = new ServiceBusPipeFilter(
      ...,
      Constants.QueueAPath,
      Constants.QueueBPath);

    this.pipeFilterA.Start();
    ...
  }

  public override void Run()
  {
    this.pipeFilterA.OnPipeFilterMessageAsync(async (msg) =>
    {
      // Clone the message and update it.
      // Properties set by the broker (Deliver count, enqueue time, ...)
      // aren't cloned and must be copied over if required.
      var newMsg = msg.Clone();

      await Task.Delay(500); // DOING WORK

      Trace.TraceInformation("Filter A processed message:{0} at {1}",
        msg.MessageId, DateTime.UtcNow);

      newMsg.Properties.Add(Constants.FilterAMessageKey, "Complete");

      return newMsg;
    });

    ...
  }

  ...
}
```

این نقش حاوی یک شی ServiceBusPipeFilter است. روش OnStart در نقش به صف هایی که پیام های ورودی را دریافت می کنند و پیام های خروجی ارسال می کنند متصل می شود. (نام صف ها در کلاس Constants تعریف شده است.) متد Run متد OnPipeFilterMessageAsync را برای انجام پردازش روی هر پیامی که دریافت می شود فراخوانی می کند. (در این مثال، پردازش با انتظار برای مدت کوتاهی شبیه سازی می شود.) هنگامی که پردازش کامل شد، یک پیام جدید ساخته می شود که حاوی نتایج است (در این حالت یک ویژگی سفارشی به پیام ورودی اضافه می شود) و این پیام به صف خروجی ارسال می شود.  
  
کد نمونه حاوی نقش کارگر دیگری به نام PipeFilterBRoleEntry است. این در پروژه PipeFilterB است. این نقش شبیه PipeFilterARoleEntry است، اما پردازش های متفاوتی را در متد Run انجام می دهد. در راه حل مثال، این دو نقش برای ساخت یک خط لوله ترکیب می شوند. صف خروجی برای نقش PipeFilterARoleEntry صف ورودی برای نقش PipeFilterBRoleEntry است.  
  
راه حل نمونه همچنین دو نقش دیگر به نام های InitialSenderRoleEntry (در پروژه InitialSender) و FinalReceiverRoleEntry (در پروژه FinalReceiver) ارائه می دهد. نقش InitialSenderRoleEntry پیام اولیه را در خط لوله ارائه می دهد. متد OnStart به یک صف متصل می شود و روش Run یک متد را در آن صف ارسال می کند. صف، صف ورودی است که توسط نقش PipeFilterARoleEntry استفاده می شود، بنابراین ارسال یک پیام به آن باعث می شود که پیام توسط نقش PipeFilterARoleEntry دریافت و پردازش شود. سپس پیام پردازش شده از نقش PipeFilterBRoleEntry عبور می کند.  
  
صف ورودی برای نقش FinalReceiveRoleEntry صف خروجی برای نقش PipeFilterBRoleEntry است. متد Run در نقش FinalReceiveRoleEntry که در کد زیر نشان داده شده است، پیام را دریافت کرده و پردازش نهایی را انجام می دهد. سپس مقادیر ویژگی های سفارشی اضافه شده توسط فیلترهای موجود در خط لوله را به خروجی ردیابی می نویسد.

```csharp
public class FinalReceiverRoleEntry : RoleEntryPoint
{
  ...
  // Final queue/pipe in the pipeline to process data from.
  private ServiceBusPipeFilter queueFinal;

  public override bool OnStart()
  {
    ...
    // Set up the queue.
    this.queueFinal = new ServiceBusPipeFilter(...,Constants.QueueFinalPath);
    this.queueFinal.Start();
    ...
  }

  public override void Run()
  {
    this.queueFinal.OnPipeFilterMessageAsync(
      async (msg) =>
      {
        await Task.Delay(500); // DOING WORK

        // The pipeline message was received.
        Trace.TraceInformation(
          "Pipeline Message Complete - FilterA:{0} FilterB:{1}",
          msg.Properties[Constants.FilterAMessageKey],
          msg.Properties[Constants.FilterBMessageKey]);

        return null;
      });
    ...
  }

  ...
}
```

## Next steps

هنگام اجرای این الگو ممکن است منابع زیر برای شما مفید باشد:  
  
نمونه ای که این الگو را در GitHub نشان می دهد  
الگوهای ناتوانی، در وبلاگ جاناتان الیور

## Related resources

الگوهای زیر ممکن است هنگام اجرای این الگو نیز مرتبط باشند:  
  
* الگوی مصرف کنندگان رقابتی یک خط لوله می تواند شامل چندین نمونه از یک یا چند فیلتر باشد. این رویکرد برای اجرای نمونه های موازی فیلترهای کند مفید است. این سیستم را قادر می سازد تا بار را پخش کند و توان عملیاتی را بهبود بخشد. هر نمونه از یک فیلتر برای ورودی با نمونه های دیگر رقابت می کند، اما دو نمونه از یک فیلتر نباید قادر به پردازش داده های مشابه باشند. این مقاله رویکرد را توضیح می دهد.  
* محاسبه الگوی تلفیق منابع ممکن است بتوان فیلترهایی را گروه بندی کرد که باید در یک فرآیند واحد مقیاس شوند. این مقاله اطلاعات بیشتری در مورد مزایا و معاوضه های این استراتژی ارائه می دهد.  
* الگوی تراکنش جبرانی می‌توانید یک فیلتر را به‌عنوان عملیاتی که می‌توان معکوس کرد، یا دارای یک عملیات جبران‌کننده است که در صورت بروز مشکل، حالت را به نسخه قبلی بازیابی می‌کند، پیاده‌سازی کنید. این مقاله توضیح می دهد که چگونه می توانید این الگو را برای حفظ یا دستیابی به ثبات نهایی پیاده سازی کنید.

